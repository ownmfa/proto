// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: api/ownmfa_app_identity.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_api_2fownmfa_5fapp_5fidentity_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_api_2fownmfa_5fapp_5fidentity_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4024000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4024004 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/empty.pb.h"
#include "google/protobuf/timestamp.pb.h"
#include "google/protobuf/field_mask.pb.h"
#include "google/api/annotations.pb.h"
#include "google/api/field_behavior.pb.h"
#include "protoc-gen-openapiv2/options/annotations.pb.h"
#include "validate/validate.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_api_2fownmfa_5fapp_5fidentity_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_api_2fownmfa_5fapp_5fidentity_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_api_2fownmfa_5fapp_5fidentity_2eproto;
namespace ownmfa {
namespace api {
class ActivateIdentityRequest;
struct ActivateIdentityRequestDefaultTypeInternal;
extern ActivateIdentityRequestDefaultTypeInternal _ActivateIdentityRequest_default_instance_;
class App;
struct AppDefaultTypeInternal;
extern AppDefaultTypeInternal _App_default_instance_;
class AppleiOSTOTPMethod;
struct AppleiOSTOTPMethodDefaultTypeInternal;
extern AppleiOSTOTPMethodDefaultTypeInternal _AppleiOSTOTPMethod_default_instance_;
class BackupsCodesMethod;
struct BackupsCodesMethodDefaultTypeInternal;
extern BackupsCodesMethodDefaultTypeInternal _BackupsCodesMethod_default_instance_;
class ChallengeIdentityRequest;
struct ChallengeIdentityRequestDefaultTypeInternal;
extern ChallengeIdentityRequestDefaultTypeInternal _ChallengeIdentityRequest_default_instance_;
class CreateAppRequest;
struct CreateAppRequestDefaultTypeInternal;
extern CreateAppRequestDefaultTypeInternal _CreateAppRequest_default_instance_;
class CreateIdentityRequest;
struct CreateIdentityRequestDefaultTypeInternal;
extern CreateIdentityRequestDefaultTypeInternal _CreateIdentityRequest_default_instance_;
class CreateIdentityResponse;
struct CreateIdentityResponseDefaultTypeInternal;
extern CreateIdentityResponseDefaultTypeInternal _CreateIdentityResponse_default_instance_;
class DeleteAppRequest;
struct DeleteAppRequestDefaultTypeInternal;
extern DeleteAppRequestDefaultTypeInternal _DeleteAppRequest_default_instance_;
class DeleteIdentityRequest;
struct DeleteIdentityRequestDefaultTypeInternal;
extern DeleteIdentityRequestDefaultTypeInternal _DeleteIdentityRequest_default_instance_;
class EmailMethod;
struct EmailMethodDefaultTypeInternal;
extern EmailMethodDefaultTypeInternal _EmailMethod_default_instance_;
class GetAppRequest;
struct GetAppRequestDefaultTypeInternal;
extern GetAppRequestDefaultTypeInternal _GetAppRequest_default_instance_;
class GetIdentityRequest;
struct GetIdentityRequestDefaultTypeInternal;
extern GetIdentityRequestDefaultTypeInternal _GetIdentityRequest_default_instance_;
class GoogleAuthHOTPMethod;
struct GoogleAuthHOTPMethodDefaultTypeInternal;
extern GoogleAuthHOTPMethodDefaultTypeInternal _GoogleAuthHOTPMethod_default_instance_;
class GoogleAuthTOTPMethod;
struct GoogleAuthTOTPMethodDefaultTypeInternal;
extern GoogleAuthTOTPMethodDefaultTypeInternal _GoogleAuthTOTPMethod_default_instance_;
class HardwareHOTPMethod;
struct HardwareHOTPMethodDefaultTypeInternal;
extern HardwareHOTPMethodDefaultTypeInternal _HardwareHOTPMethod_default_instance_;
class HardwareTOTPMethod;
struct HardwareTOTPMethodDefaultTypeInternal;
extern HardwareTOTPMethodDefaultTypeInternal _HardwareTOTPMethod_default_instance_;
class Identity;
struct IdentityDefaultTypeInternal;
extern IdentityDefaultTypeInternal _Identity_default_instance_;
class ListAppsRequest;
struct ListAppsRequestDefaultTypeInternal;
extern ListAppsRequestDefaultTypeInternal _ListAppsRequest_default_instance_;
class ListAppsResponse;
struct ListAppsResponseDefaultTypeInternal;
extern ListAppsResponseDefaultTypeInternal _ListAppsResponse_default_instance_;
class ListIdentitiesRequest;
struct ListIdentitiesRequestDefaultTypeInternal;
extern ListIdentitiesRequestDefaultTypeInternal _ListIdentitiesRequest_default_instance_;
class ListIdentitiesResponse;
struct ListIdentitiesResponseDefaultTypeInternal;
extern ListIdentitiesResponseDefaultTypeInternal _ListIdentitiesResponse_default_instance_;
class PushoverMethod;
struct PushoverMethodDefaultTypeInternal;
extern PushoverMethodDefaultTypeInternal _PushoverMethod_default_instance_;
class SMSMethod;
struct SMSMethodDefaultTypeInternal;
extern SMSMethodDefaultTypeInternal _SMSMethod_default_instance_;
class SecurityQuestionsMethod;
struct SecurityQuestionsMethodDefaultTypeInternal;
extern SecurityQuestionsMethodDefaultTypeInternal _SecurityQuestionsMethod_default_instance_;
class SoftwareHOTPMethod;
struct SoftwareHOTPMethodDefaultTypeInternal;
extern SoftwareHOTPMethodDefaultTypeInternal _SoftwareHOTPMethod_default_instance_;
class SoftwareTOTPMethod;
struct SoftwareTOTPMethodDefaultTypeInternal;
extern SoftwareTOTPMethodDefaultTypeInternal _SoftwareTOTPMethod_default_instance_;
class UpdateAppRequest;
struct UpdateAppRequestDefaultTypeInternal;
extern UpdateAppRequestDefaultTypeInternal _UpdateAppRequest_default_instance_;
class VerifyIdentityRequest;
struct VerifyIdentityRequestDefaultTypeInternal;
extern VerifyIdentityRequestDefaultTypeInternal _VerifyIdentityRequest_default_instance_;
}  // namespace api
}  // namespace ownmfa
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace ownmfa {
namespace api {
enum IdentityStatus : int {
  UNVERIFIED = 0,
  ACTIVATED = 3,
  IdentityStatus_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  IdentityStatus_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool IdentityStatus_IsValid(int value);
constexpr IdentityStatus IdentityStatus_MIN = static_cast<IdentityStatus>(0);
constexpr IdentityStatus IdentityStatus_MAX = static_cast<IdentityStatus>(3);
constexpr int IdentityStatus_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
IdentityStatus_descriptor();
template <typename T>
const std::string& IdentityStatus_Name(T value) {
  static_assert(std::is_same<T, IdentityStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to IdentityStatus_Name().");
  return IdentityStatus_Name(static_cast<IdentityStatus>(value));
}
template <>
inline const std::string& IdentityStatus_Name(IdentityStatus value) {
  return ::google::protobuf::internal::NameOfDenseEnum<IdentityStatus_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool IdentityStatus_Parse(absl::string_view name, IdentityStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<IdentityStatus>(
      IdentityStatus_descriptor(), name, value);
}
enum Hash : int {
  SHA512 = 0,
  SHA256 = 1,
  SHA1 = 2,
  Hash_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Hash_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Hash_IsValid(int value);
constexpr Hash Hash_MIN = static_cast<Hash>(0);
constexpr Hash Hash_MAX = static_cast<Hash>(2);
constexpr int Hash_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
Hash_descriptor();
template <typename T>
const std::string& Hash_Name(T value) {
  static_assert(std::is_same<T, Hash>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Hash_Name().");
  return Hash_Name(static_cast<Hash>(value));
}
template <>
inline const std::string& Hash_Name(Hash value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Hash_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool Hash_Parse(absl::string_view name, Hash* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Hash>(
      Hash_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class App final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ownmfa.api.App) */ {
 public:
  inline App() : App(nullptr) {}
  ~App() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR App(::google::protobuf::internal::ConstantInitialized);

  App(const App& from);
  App(App&& from) noexcept
    : App() {
    *this = ::std::move(from);
  }

  inline App& operator=(const App& from) {
    CopyFrom(from);
    return *this;
  }
  inline App& operator=(App&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const App& default_instance() {
    return *internal_default_instance();
  }
  static inline const App* internal_default_instance() {
    return reinterpret_cast<const App*>(
               &_App_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(App& a, App& b) {
    a.Swap(&b);
  }
  inline void Swap(App* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(App* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  App* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<App>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const App& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const App& from) {
    App::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(App* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ownmfa.api.App";
  }
  protected:
  explicit App(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kOrgIdFieldNumber = 2,
    kNameFieldNumber = 3,
    kDisplayNameFieldNumber = 4,
    kEmailFieldNumber = 5,
    kPushoverKeyFieldNumber = 6,
    kSubjectTemplateFieldNumber = 7,
    kTextBodyTemplateFieldNumber = 8,
    kHtmlBodyTemplateFieldNumber = 9,
    kCreatedAtFieldNumber = 10,
    kUpdatedAtFieldNumber = 11,
  };
  // string id = 1 [(.google.api.field_behavior) = OUTPUT_ONLY];
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string org_id = 2 [json_name = "orgID", (.google.api.field_behavior) = OUTPUT_ONLY];
  void clear_org_id() ;
  const std::string& org_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_org_id(Arg_&& arg, Args_... args);
  std::string* mutable_org_id();
  PROTOBUF_NODISCARD std::string* release_org_id();
  void set_allocated_org_id(std::string* ptr);

  private:
  const std::string& _internal_org_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_org_id(
      const std::string& value);
  std::string* _internal_mutable_org_id();

  public:
  // string name = 3 [(.validate.rules) = {
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* ptr);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string display_name = 4 [(.validate.rules) = {
  void clear_display_name() ;
  const std::string& display_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_display_name(Arg_&& arg, Args_... args);
  std::string* mutable_display_name();
  PROTOBUF_NODISCARD std::string* release_display_name();
  void set_allocated_display_name(std::string* ptr);

  private:
  const std::string& _internal_display_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_display_name(
      const std::string& value);
  std::string* _internal_mutable_display_name();

  public:
  // string email = 5 [(.validate.rules) = {
  void clear_email() ;
  const std::string& email() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_email(Arg_&& arg, Args_... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* ptr);

  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(
      const std::string& value);
  std::string* _internal_mutable_email();

  public:
  // string pushover_key = 6 [(.validate.rules) = {
  void clear_pushover_key() ;
  const std::string& pushover_key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_pushover_key(Arg_&& arg, Args_... args);
  std::string* mutable_pushover_key();
  PROTOBUF_NODISCARD std::string* release_pushover_key();
  void set_allocated_pushover_key(std::string* ptr);

  private:
  const std::string& _internal_pushover_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pushover_key(
      const std::string& value);
  std::string* _internal_mutable_pushover_key();

  public:
  // string subject_template = 7 [(.validate.rules) = {
  void clear_subject_template() ;
  const std::string& subject_template() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subject_template(Arg_&& arg, Args_... args);
  std::string* mutable_subject_template();
  PROTOBUF_NODISCARD std::string* release_subject_template();
  void set_allocated_subject_template(std::string* ptr);

  private:
  const std::string& _internal_subject_template() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subject_template(
      const std::string& value);
  std::string* _internal_mutable_subject_template();

  public:
  // string text_body_template = 8 [(.validate.rules) = {
  void clear_text_body_template() ;
  const std::string& text_body_template() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_text_body_template(Arg_&& arg, Args_... args);
  std::string* mutable_text_body_template();
  PROTOBUF_NODISCARD std::string* release_text_body_template();
  void set_allocated_text_body_template(std::string* ptr);

  private:
  const std::string& _internal_text_body_template() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text_body_template(
      const std::string& value);
  std::string* _internal_mutable_text_body_template();

  public:
  // bytes html_body_template = 9 [(.validate.rules) = {
  void clear_html_body_template() ;
  const std::string& html_body_template() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_html_body_template(Arg_&& arg, Args_... args);
  std::string* mutable_html_body_template();
  PROTOBUF_NODISCARD std::string* release_html_body_template();
  void set_allocated_html_body_template(std::string* ptr);

  private:
  const std::string& _internal_html_body_template() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_html_body_template(
      const std::string& value);
  std::string* _internal_mutable_html_body_template();

  public:
  // .google.protobuf.Timestamp created_at = 10 [(.google.api.field_behavior) = OUTPUT_ONLY];
  bool has_created_at() const;
  void clear_created_at() ;
  const ::google::protobuf::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_created_at();
  ::google::protobuf::Timestamp* mutable_created_at();
  void set_allocated_created_at(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_created_at(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_created_at();

  private:
  const ::google::protobuf::Timestamp& _internal_created_at() const;
  ::google::protobuf::Timestamp* _internal_mutable_created_at();

  public:
  // .google.protobuf.Timestamp updated_at = 11 [(.google.api.field_behavior) = OUTPUT_ONLY];
  bool has_updated_at() const;
  void clear_updated_at() ;
  const ::google::protobuf::Timestamp& updated_at() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_updated_at();
  ::google::protobuf::Timestamp* mutable_updated_at();
  void set_allocated_updated_at(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_updated_at(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_updated_at();

  private:
  const ::google::protobuf::Timestamp& _internal_updated_at() const;
  ::google::protobuf::Timestamp* _internal_mutable_updated_at();

  public:
  // @@protoc_insertion_point(class_scope:ownmfa.api.App)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<4, 11, 2, 106, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr org_id_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr display_name_;
    ::google::protobuf::internal::ArenaStringPtr email_;
    ::google::protobuf::internal::ArenaStringPtr pushover_key_;
    ::google::protobuf::internal::ArenaStringPtr subject_template_;
    ::google::protobuf::internal::ArenaStringPtr text_body_template_;
    ::google::protobuf::internal::ArenaStringPtr html_body_template_;
    ::google::protobuf::Timestamp* created_at_;
    ::google::protobuf::Timestamp* updated_at_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fownmfa_5fapp_5fidentity_2eproto;
};// -------------------------------------------------------------------

class CreateAppRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ownmfa.api.CreateAppRequest) */ {
 public:
  inline CreateAppRequest() : CreateAppRequest(nullptr) {}
  ~CreateAppRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CreateAppRequest(::google::protobuf::internal::ConstantInitialized);

  CreateAppRequest(const CreateAppRequest& from);
  CreateAppRequest(CreateAppRequest&& from) noexcept
    : CreateAppRequest() {
    *this = ::std::move(from);
  }

  inline CreateAppRequest& operator=(const CreateAppRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateAppRequest& operator=(CreateAppRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateAppRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateAppRequest* internal_default_instance() {
    return reinterpret_cast<const CreateAppRequest*>(
               &_CreateAppRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CreateAppRequest& a, CreateAppRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateAppRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateAppRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateAppRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateAppRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateAppRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CreateAppRequest& from) {
    CreateAppRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateAppRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ownmfa.api.CreateAppRequest";
  }
  protected:
  explicit CreateAppRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppFieldNumber = 1,
  };
  // .ownmfa.api.App app = 1 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  bool has_app() const;
  void clear_app() ;
  const ::ownmfa::api::App& app() const;
  PROTOBUF_NODISCARD ::ownmfa::api::App* release_app();
  ::ownmfa::api::App* mutable_app();
  void set_allocated_app(::ownmfa::api::App* value);
  void unsafe_arena_set_allocated_app(::ownmfa::api::App* value);
  ::ownmfa::api::App* unsafe_arena_release_app();

  private:
  const ::ownmfa::api::App& _internal_app() const;
  ::ownmfa::api::App* _internal_mutable_app();

  public:
  // @@protoc_insertion_point(class_scope:ownmfa.api.CreateAppRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::ownmfa::api::App* app_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fownmfa_5fapp_5fidentity_2eproto;
};// -------------------------------------------------------------------

class GetAppRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ownmfa.api.GetAppRequest) */ {
 public:
  inline GetAppRequest() : GetAppRequest(nullptr) {}
  ~GetAppRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetAppRequest(::google::protobuf::internal::ConstantInitialized);

  GetAppRequest(const GetAppRequest& from);
  GetAppRequest(GetAppRequest&& from) noexcept
    : GetAppRequest() {
    *this = ::std::move(from);
  }

  inline GetAppRequest& operator=(const GetAppRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAppRequest& operator=(GetAppRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAppRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAppRequest* internal_default_instance() {
    return reinterpret_cast<const GetAppRequest*>(
               &_GetAppRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(GetAppRequest& a, GetAppRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetAppRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAppRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetAppRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetAppRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetAppRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetAppRequest& from) {
    GetAppRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAppRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ownmfa.api.GetAppRequest";
  }
  protected:
  explicit GetAppRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // @@protoc_insertion_point(class_scope:ownmfa.api.GetAppRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 35, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fownmfa_5fapp_5fidentity_2eproto;
};// -------------------------------------------------------------------

class UpdateAppRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ownmfa.api.UpdateAppRequest) */ {
 public:
  inline UpdateAppRequest() : UpdateAppRequest(nullptr) {}
  ~UpdateAppRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateAppRequest(::google::protobuf::internal::ConstantInitialized);

  UpdateAppRequest(const UpdateAppRequest& from);
  UpdateAppRequest(UpdateAppRequest&& from) noexcept
    : UpdateAppRequest() {
    *this = ::std::move(from);
  }

  inline UpdateAppRequest& operator=(const UpdateAppRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateAppRequest& operator=(UpdateAppRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateAppRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateAppRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateAppRequest*>(
               &_UpdateAppRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(UpdateAppRequest& a, UpdateAppRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateAppRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateAppRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateAppRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateAppRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateAppRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UpdateAppRequest& from) {
    UpdateAppRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateAppRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ownmfa.api.UpdateAppRequest";
  }
  protected:
  explicit UpdateAppRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppFieldNumber = 1,
    kUpdateMaskFieldNumber = 2,
  };
  // .ownmfa.api.App app = 1 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  bool has_app() const;
  void clear_app() ;
  const ::ownmfa::api::App& app() const;
  PROTOBUF_NODISCARD ::ownmfa::api::App* release_app();
  ::ownmfa::api::App* mutable_app();
  void set_allocated_app(::ownmfa::api::App* value);
  void unsafe_arena_set_allocated_app(::ownmfa::api::App* value);
  ::ownmfa::api::App* unsafe_arena_release_app();

  private:
  const ::ownmfa::api::App& _internal_app() const;
  ::ownmfa::api::App* _internal_mutable_app();

  public:
  // .google.protobuf.FieldMask update_mask = 2;
  bool has_update_mask() const;
  void clear_update_mask() ;
  const ::google::protobuf::FieldMask& update_mask() const;
  PROTOBUF_NODISCARD ::google::protobuf::FieldMask* release_update_mask();
  ::google::protobuf::FieldMask* mutable_update_mask();
  void set_allocated_update_mask(::google::protobuf::FieldMask* value);
  void unsafe_arena_set_allocated_update_mask(::google::protobuf::FieldMask* value);
  ::google::protobuf::FieldMask* unsafe_arena_release_update_mask();

  private:
  const ::google::protobuf::FieldMask& _internal_update_mask() const;
  ::google::protobuf::FieldMask* _internal_mutable_update_mask();

  public:
  // @@protoc_insertion_point(class_scope:ownmfa.api.UpdateAppRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 2, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::ownmfa::api::App* app_;
    ::google::protobuf::FieldMask* update_mask_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fownmfa_5fapp_5fidentity_2eproto;
};// -------------------------------------------------------------------

class DeleteAppRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ownmfa.api.DeleteAppRequest) */ {
 public:
  inline DeleteAppRequest() : DeleteAppRequest(nullptr) {}
  ~DeleteAppRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteAppRequest(::google::protobuf::internal::ConstantInitialized);

  DeleteAppRequest(const DeleteAppRequest& from);
  DeleteAppRequest(DeleteAppRequest&& from) noexcept
    : DeleteAppRequest() {
    *this = ::std::move(from);
  }

  inline DeleteAppRequest& operator=(const DeleteAppRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteAppRequest& operator=(DeleteAppRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteAppRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteAppRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteAppRequest*>(
               &_DeleteAppRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(DeleteAppRequest& a, DeleteAppRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteAppRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteAppRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteAppRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteAppRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeleteAppRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DeleteAppRequest& from) {
    DeleteAppRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteAppRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ownmfa.api.DeleteAppRequest";
  }
  protected:
  explicit DeleteAppRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // @@protoc_insertion_point(class_scope:ownmfa.api.DeleteAppRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 38, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fownmfa_5fapp_5fidentity_2eproto;
};// -------------------------------------------------------------------

class ListAppsRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ownmfa.api.ListAppsRequest) */ {
 public:
  inline ListAppsRequest() : ListAppsRequest(nullptr) {}
  ~ListAppsRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ListAppsRequest(::google::protobuf::internal::ConstantInitialized);

  ListAppsRequest(const ListAppsRequest& from);
  ListAppsRequest(ListAppsRequest&& from) noexcept
    : ListAppsRequest() {
    *this = ::std::move(from);
  }

  inline ListAppsRequest& operator=(const ListAppsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListAppsRequest& operator=(ListAppsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListAppsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListAppsRequest* internal_default_instance() {
    return reinterpret_cast<const ListAppsRequest*>(
               &_ListAppsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ListAppsRequest& a, ListAppsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListAppsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListAppsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListAppsRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListAppsRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListAppsRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ListAppsRequest& from) {
    ListAppsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListAppsRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ownmfa.api.ListAppsRequest";
  }
  protected:
  explicit ListAppsRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPageTokenFieldNumber = 2,
    kPageSizeFieldNumber = 1,
  };
  // string page_token = 2;
  void clear_page_token() ;
  const std::string& page_token() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_page_token(Arg_&& arg, Args_... args);
  std::string* mutable_page_token();
  PROTOBUF_NODISCARD std::string* release_page_token();
  void set_allocated_page_token(std::string* ptr);

  private:
  const std::string& _internal_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(
      const std::string& value);
  std::string* _internal_mutable_page_token();

  public:
  // int32 page_size = 1 [(.validate.rules) = {
  void clear_page_size() ;
  ::int32_t page_size() const;
  void set_page_size(::int32_t value);

  private:
  ::int32_t _internal_page_size() const;
  void _internal_set_page_size(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:ownmfa.api.ListAppsRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 45, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr page_token_;
    ::int32_t page_size_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fownmfa_5fapp_5fidentity_2eproto;
};// -------------------------------------------------------------------

class ListAppsResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ownmfa.api.ListAppsResponse) */ {
 public:
  inline ListAppsResponse() : ListAppsResponse(nullptr) {}
  ~ListAppsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ListAppsResponse(::google::protobuf::internal::ConstantInitialized);

  ListAppsResponse(const ListAppsResponse& from);
  ListAppsResponse(ListAppsResponse&& from) noexcept
    : ListAppsResponse() {
    *this = ::std::move(from);
  }

  inline ListAppsResponse& operator=(const ListAppsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListAppsResponse& operator=(ListAppsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListAppsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListAppsResponse* internal_default_instance() {
    return reinterpret_cast<const ListAppsResponse*>(
               &_ListAppsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ListAppsResponse& a, ListAppsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListAppsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListAppsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListAppsResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListAppsResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListAppsResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ListAppsResponse& from) {
    ListAppsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListAppsResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ownmfa.api.ListAppsResponse";
  }
  protected:
  explicit ListAppsResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppsFieldNumber = 1,
    kNextPageTokenFieldNumber = 2,
    kTotalSizeFieldNumber = 3,
  };
  // repeated .ownmfa.api.App apps = 1;
  int apps_size() const;
  private:
  int _internal_apps_size() const;

  public:
  void clear_apps() ;
  ::ownmfa::api::App* mutable_apps(int index);
  ::google::protobuf::RepeatedPtrField< ::ownmfa::api::App >*
      mutable_apps();
  private:
  const ::google::protobuf::RepeatedPtrField<::ownmfa::api::App>& _internal_apps() const;
  ::google::protobuf::RepeatedPtrField<::ownmfa::api::App>* _internal_mutable_apps();
  public:
  const ::ownmfa::api::App& apps(int index) const;
  ::ownmfa::api::App* add_apps();
  const ::google::protobuf::RepeatedPtrField< ::ownmfa::api::App >&
      apps() const;
  // string next_page_token = 2;
  void clear_next_page_token() ;
  const std::string& next_page_token() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_next_page_token(Arg_&& arg, Args_... args);
  std::string* mutable_next_page_token();
  PROTOBUF_NODISCARD std::string* release_next_page_token();
  void set_allocated_next_page_token(std::string* ptr);

  private:
  const std::string& _internal_next_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_page_token(
      const std::string& value);
  std::string* _internal_mutable_next_page_token();

  public:
  // int32 total_size = 3;
  void clear_total_size() ;
  ::int32_t total_size() const;
  void set_total_size(::int32_t value);

  private:
  ::int32_t _internal_total_size() const;
  void _internal_set_total_size(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:ownmfa.api.ListAppsResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 1, 51, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::ownmfa::api::App > apps_;
    ::google::protobuf::internal::ArenaStringPtr next_page_token_;
    ::int32_t total_size_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fownmfa_5fapp_5fidentity_2eproto;
};// -------------------------------------------------------------------

class SoftwareHOTPMethod final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ownmfa.api.SoftwareHOTPMethod) */ {
 public:
  inline SoftwareHOTPMethod() : SoftwareHOTPMethod(nullptr) {}
  ~SoftwareHOTPMethod() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SoftwareHOTPMethod(::google::protobuf::internal::ConstantInitialized);

  SoftwareHOTPMethod(const SoftwareHOTPMethod& from);
  SoftwareHOTPMethod(SoftwareHOTPMethod&& from) noexcept
    : SoftwareHOTPMethod() {
    *this = ::std::move(from);
  }

  inline SoftwareHOTPMethod& operator=(const SoftwareHOTPMethod& from) {
    CopyFrom(from);
    return *this;
  }
  inline SoftwareHOTPMethod& operator=(SoftwareHOTPMethod&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SoftwareHOTPMethod& default_instance() {
    return *internal_default_instance();
  }
  static inline const SoftwareHOTPMethod* internal_default_instance() {
    return reinterpret_cast<const SoftwareHOTPMethod*>(
               &_SoftwareHOTPMethod_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SoftwareHOTPMethod& a, SoftwareHOTPMethod& b) {
    a.Swap(&b);
  }
  inline void Swap(SoftwareHOTPMethod* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SoftwareHOTPMethod* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SoftwareHOTPMethod* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SoftwareHOTPMethod>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SoftwareHOTPMethod& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SoftwareHOTPMethod& from) {
    SoftwareHOTPMethod::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SoftwareHOTPMethod* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ownmfa.api.SoftwareHOTPMethod";
  }
  protected:
  explicit SoftwareHOTPMethod(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountNameFieldNumber = 4,
    kHashFieldNumber = 1,
    kDigitsFieldNumber = 2,
    kCounterFieldNumber = 3,
  };
  // string account_name = 4 [(.validate.rules) = {
  void clear_account_name() ;
  const std::string& account_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_account_name(Arg_&& arg, Args_... args);
  std::string* mutable_account_name();
  PROTOBUF_NODISCARD std::string* release_account_name();
  void set_allocated_account_name(std::string* ptr);

  private:
  const std::string& _internal_account_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account_name(
      const std::string& value);
  std::string* _internal_mutable_account_name();

  public:
  // .ownmfa.api.Hash hash = 1;
  void clear_hash() ;
  ::ownmfa::api::Hash hash() const;
  void set_hash(::ownmfa::api::Hash value);

  private:
  ::ownmfa::api::Hash _internal_hash() const;
  void _internal_set_hash(::ownmfa::api::Hash value);

  public:
  // int32 digits = 2 [(.validate.rules) = {
  void clear_digits() ;
  ::int32_t digits() const;
  void set_digits(::int32_t value);

  private:
  ::int32_t _internal_digits() const;
  void _internal_set_digits(::int32_t value);

  public:
  // int32 counter = 3;
  void clear_counter() ;
  ::int32_t counter() const;
  void set_counter(::int32_t value);

  private:
  ::int32_t _internal_counter() const;
  void _internal_set_counter(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:ownmfa.api.SoftwareHOTPMethod)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4, 0, 50, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr account_name_;
    int hash_;
    ::int32_t digits_;
    ::int32_t counter_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fownmfa_5fapp_5fidentity_2eproto;
};// -------------------------------------------------------------------

class SoftwareTOTPMethod final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ownmfa.api.SoftwareTOTPMethod) */ {
 public:
  inline SoftwareTOTPMethod() : SoftwareTOTPMethod(nullptr) {}
  ~SoftwareTOTPMethod() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SoftwareTOTPMethod(::google::protobuf::internal::ConstantInitialized);

  SoftwareTOTPMethod(const SoftwareTOTPMethod& from);
  SoftwareTOTPMethod(SoftwareTOTPMethod&& from) noexcept
    : SoftwareTOTPMethod() {
    *this = ::std::move(from);
  }

  inline SoftwareTOTPMethod& operator=(const SoftwareTOTPMethod& from) {
    CopyFrom(from);
    return *this;
  }
  inline SoftwareTOTPMethod& operator=(SoftwareTOTPMethod&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SoftwareTOTPMethod& default_instance() {
    return *internal_default_instance();
  }
  static inline const SoftwareTOTPMethod* internal_default_instance() {
    return reinterpret_cast<const SoftwareTOTPMethod*>(
               &_SoftwareTOTPMethod_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SoftwareTOTPMethod& a, SoftwareTOTPMethod& b) {
    a.Swap(&b);
  }
  inline void Swap(SoftwareTOTPMethod* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SoftwareTOTPMethod* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SoftwareTOTPMethod* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SoftwareTOTPMethod>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SoftwareTOTPMethod& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SoftwareTOTPMethod& from) {
    SoftwareTOTPMethod::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SoftwareTOTPMethod* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ownmfa.api.SoftwareTOTPMethod";
  }
  protected:
  explicit SoftwareTOTPMethod(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountNameFieldNumber = 3,
    kHashFieldNumber = 1,
    kDigitsFieldNumber = 2,
  };
  // string account_name = 3 [(.validate.rules) = {
  void clear_account_name() ;
  const std::string& account_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_account_name(Arg_&& arg, Args_... args);
  std::string* mutable_account_name();
  PROTOBUF_NODISCARD std::string* release_account_name();
  void set_allocated_account_name(std::string* ptr);

  private:
  const std::string& _internal_account_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account_name(
      const std::string& value);
  std::string* _internal_mutable_account_name();

  public:
  // .ownmfa.api.Hash hash = 1;
  void clear_hash() ;
  ::ownmfa::api::Hash hash() const;
  void set_hash(::ownmfa::api::Hash value);

  private:
  ::ownmfa::api::Hash _internal_hash() const;
  void _internal_set_hash(::ownmfa::api::Hash value);

  public:
  // int32 digits = 2 [(.validate.rules) = {
  void clear_digits() ;
  ::int32_t digits() const;
  void set_digits(::int32_t value);

  private:
  ::int32_t _internal_digits() const;
  void _internal_set_digits(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:ownmfa.api.SoftwareTOTPMethod)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 0, 50, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr account_name_;
    int hash_;
    ::int32_t digits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fownmfa_5fapp_5fidentity_2eproto;
};// -------------------------------------------------------------------

class GoogleAuthHOTPMethod final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ownmfa.api.GoogleAuthHOTPMethod) */ {
 public:
  inline GoogleAuthHOTPMethod() : GoogleAuthHOTPMethod(nullptr) {}
  ~GoogleAuthHOTPMethod() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GoogleAuthHOTPMethod(::google::protobuf::internal::ConstantInitialized);

  GoogleAuthHOTPMethod(const GoogleAuthHOTPMethod& from);
  GoogleAuthHOTPMethod(GoogleAuthHOTPMethod&& from) noexcept
    : GoogleAuthHOTPMethod() {
    *this = ::std::move(from);
  }

  inline GoogleAuthHOTPMethod& operator=(const GoogleAuthHOTPMethod& from) {
    CopyFrom(from);
    return *this;
  }
  inline GoogleAuthHOTPMethod& operator=(GoogleAuthHOTPMethod&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GoogleAuthHOTPMethod& default_instance() {
    return *internal_default_instance();
  }
  static inline const GoogleAuthHOTPMethod* internal_default_instance() {
    return reinterpret_cast<const GoogleAuthHOTPMethod*>(
               &_GoogleAuthHOTPMethod_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(GoogleAuthHOTPMethod& a, GoogleAuthHOTPMethod& b) {
    a.Swap(&b);
  }
  inline void Swap(GoogleAuthHOTPMethod* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GoogleAuthHOTPMethod* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GoogleAuthHOTPMethod* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GoogleAuthHOTPMethod>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GoogleAuthHOTPMethod& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GoogleAuthHOTPMethod& from) {
    GoogleAuthHOTPMethod::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GoogleAuthHOTPMethod* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ownmfa.api.GoogleAuthHOTPMethod";
  }
  protected:
  explicit GoogleAuthHOTPMethod(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountNameFieldNumber = 1,
  };
  // string account_name = 1 [(.validate.rules) = {
  void clear_account_name() ;
  const std::string& account_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_account_name(Arg_&& arg, Args_... args);
  std::string* mutable_account_name();
  PROTOBUF_NODISCARD std::string* release_account_name();
  void set_allocated_account_name(std::string* ptr);

  private:
  const std::string& _internal_account_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account_name(
      const std::string& value);
  std::string* _internal_mutable_account_name();

  public:
  // @@protoc_insertion_point(class_scope:ownmfa.api.GoogleAuthHOTPMethod)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 52, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr account_name_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fownmfa_5fapp_5fidentity_2eproto;
};// -------------------------------------------------------------------

class GoogleAuthTOTPMethod final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ownmfa.api.GoogleAuthTOTPMethod) */ {
 public:
  inline GoogleAuthTOTPMethod() : GoogleAuthTOTPMethod(nullptr) {}
  ~GoogleAuthTOTPMethod() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GoogleAuthTOTPMethod(::google::protobuf::internal::ConstantInitialized);

  GoogleAuthTOTPMethod(const GoogleAuthTOTPMethod& from);
  GoogleAuthTOTPMethod(GoogleAuthTOTPMethod&& from) noexcept
    : GoogleAuthTOTPMethod() {
    *this = ::std::move(from);
  }

  inline GoogleAuthTOTPMethod& operator=(const GoogleAuthTOTPMethod& from) {
    CopyFrom(from);
    return *this;
  }
  inline GoogleAuthTOTPMethod& operator=(GoogleAuthTOTPMethod&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GoogleAuthTOTPMethod& default_instance() {
    return *internal_default_instance();
  }
  static inline const GoogleAuthTOTPMethod* internal_default_instance() {
    return reinterpret_cast<const GoogleAuthTOTPMethod*>(
               &_GoogleAuthTOTPMethod_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(GoogleAuthTOTPMethod& a, GoogleAuthTOTPMethod& b) {
    a.Swap(&b);
  }
  inline void Swap(GoogleAuthTOTPMethod* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GoogleAuthTOTPMethod* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GoogleAuthTOTPMethod* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GoogleAuthTOTPMethod>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GoogleAuthTOTPMethod& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GoogleAuthTOTPMethod& from) {
    GoogleAuthTOTPMethod::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GoogleAuthTOTPMethod* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ownmfa.api.GoogleAuthTOTPMethod";
  }
  protected:
  explicit GoogleAuthTOTPMethod(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountNameFieldNumber = 1,
  };
  // string account_name = 1 [(.validate.rules) = {
  void clear_account_name() ;
  const std::string& account_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_account_name(Arg_&& arg, Args_... args);
  std::string* mutable_account_name();
  PROTOBUF_NODISCARD std::string* release_account_name();
  void set_allocated_account_name(std::string* ptr);

  private:
  const std::string& _internal_account_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account_name(
      const std::string& value);
  std::string* _internal_mutable_account_name();

  public:
  // @@protoc_insertion_point(class_scope:ownmfa.api.GoogleAuthTOTPMethod)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 52, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr account_name_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fownmfa_5fapp_5fidentity_2eproto;
};// -------------------------------------------------------------------

class AppleiOSTOTPMethod final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:ownmfa.api.AppleiOSTOTPMethod) */ {
 public:
  inline AppleiOSTOTPMethod() : AppleiOSTOTPMethod(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AppleiOSTOTPMethod(::google::protobuf::internal::ConstantInitialized);

  AppleiOSTOTPMethod(const AppleiOSTOTPMethod& from);
  AppleiOSTOTPMethod(AppleiOSTOTPMethod&& from) noexcept
    : AppleiOSTOTPMethod() {
    *this = ::std::move(from);
  }

  inline AppleiOSTOTPMethod& operator=(const AppleiOSTOTPMethod& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppleiOSTOTPMethod& operator=(AppleiOSTOTPMethod&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppleiOSTOTPMethod& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppleiOSTOTPMethod* internal_default_instance() {
    return reinterpret_cast<const AppleiOSTOTPMethod*>(
               &_AppleiOSTOTPMethod_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(AppleiOSTOTPMethod& a, AppleiOSTOTPMethod& b) {
    a.Swap(&b);
  }
  inline void Swap(AppleiOSTOTPMethod* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppleiOSTOTPMethod* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AppleiOSTOTPMethod* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AppleiOSTOTPMethod>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AppleiOSTOTPMethod& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AppleiOSTOTPMethod& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ownmfa.api.AppleiOSTOTPMethod";
  }
  protected:
  explicit AppleiOSTOTPMethod(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ownmfa.api.AppleiOSTOTPMethod)
 private:
  class _Internal;

  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_api_2fownmfa_5fapp_5fidentity_2eproto;
};// -------------------------------------------------------------------

class HardwareHOTPMethod final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ownmfa.api.HardwareHOTPMethod) */ {
 public:
  inline HardwareHOTPMethod() : HardwareHOTPMethod(nullptr) {}
  ~HardwareHOTPMethod() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR HardwareHOTPMethod(::google::protobuf::internal::ConstantInitialized);

  HardwareHOTPMethod(const HardwareHOTPMethod& from);
  HardwareHOTPMethod(HardwareHOTPMethod&& from) noexcept
    : HardwareHOTPMethod() {
    *this = ::std::move(from);
  }

  inline HardwareHOTPMethod& operator=(const HardwareHOTPMethod& from) {
    CopyFrom(from);
    return *this;
  }
  inline HardwareHOTPMethod& operator=(HardwareHOTPMethod&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HardwareHOTPMethod& default_instance() {
    return *internal_default_instance();
  }
  static inline const HardwareHOTPMethod* internal_default_instance() {
    return reinterpret_cast<const HardwareHOTPMethod*>(
               &_HardwareHOTPMethod_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(HardwareHOTPMethod& a, HardwareHOTPMethod& b) {
    a.Swap(&b);
  }
  inline void Swap(HardwareHOTPMethod* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HardwareHOTPMethod* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HardwareHOTPMethod* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HardwareHOTPMethod>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HardwareHOTPMethod& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const HardwareHOTPMethod& from) {
    HardwareHOTPMethod::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HardwareHOTPMethod* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ownmfa.api.HardwareHOTPMethod";
  }
  protected:
  explicit HardwareHOTPMethod(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecretFieldNumber = 4,
    kHashFieldNumber = 1,
    kDigitsFieldNumber = 2,
    kCounterFieldNumber = 3,
  };
  // bytes secret = 4 [(.validate.rules) = {
  void clear_secret() ;
  const std::string& secret() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_secret(Arg_&& arg, Args_... args);
  std::string* mutable_secret();
  PROTOBUF_NODISCARD std::string* release_secret();
  void set_allocated_secret(std::string* ptr);

  private:
  const std::string& _internal_secret() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_secret(
      const std::string& value);
  std::string* _internal_mutable_secret();

  public:
  // .ownmfa.api.Hash hash = 1;
  void clear_hash() ;
  ::ownmfa::api::Hash hash() const;
  void set_hash(::ownmfa::api::Hash value);

  private:
  ::ownmfa::api::Hash _internal_hash() const;
  void _internal_set_hash(::ownmfa::api::Hash value);

  public:
  // int32 digits = 2 [(.validate.rules) = {
  void clear_digits() ;
  ::int32_t digits() const;
  void set_digits(::int32_t value);

  private:
  ::int32_t _internal_digits() const;
  void _internal_set_digits(::int32_t value);

  public:
  // int32 counter = 3;
  void clear_counter() ;
  ::int32_t counter() const;
  void set_counter(::int32_t value);

  private:
  ::int32_t _internal_counter() const;
  void _internal_set_counter(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:ownmfa.api.HardwareHOTPMethod)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr secret_;
    int hash_;
    ::int32_t digits_;
    ::int32_t counter_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fownmfa_5fapp_5fidentity_2eproto;
};// -------------------------------------------------------------------

class HardwareTOTPMethod final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ownmfa.api.HardwareTOTPMethod) */ {
 public:
  inline HardwareTOTPMethod() : HardwareTOTPMethod(nullptr) {}
  ~HardwareTOTPMethod() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR HardwareTOTPMethod(::google::protobuf::internal::ConstantInitialized);

  HardwareTOTPMethod(const HardwareTOTPMethod& from);
  HardwareTOTPMethod(HardwareTOTPMethod&& from) noexcept
    : HardwareTOTPMethod() {
    *this = ::std::move(from);
  }

  inline HardwareTOTPMethod& operator=(const HardwareTOTPMethod& from) {
    CopyFrom(from);
    return *this;
  }
  inline HardwareTOTPMethod& operator=(HardwareTOTPMethod&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HardwareTOTPMethod& default_instance() {
    return *internal_default_instance();
  }
  static inline const HardwareTOTPMethod* internal_default_instance() {
    return reinterpret_cast<const HardwareTOTPMethod*>(
               &_HardwareTOTPMethod_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(HardwareTOTPMethod& a, HardwareTOTPMethod& b) {
    a.Swap(&b);
  }
  inline void Swap(HardwareTOTPMethod* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HardwareTOTPMethod* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HardwareTOTPMethod* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HardwareTOTPMethod>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HardwareTOTPMethod& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const HardwareTOTPMethod& from) {
    HardwareTOTPMethod::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HardwareTOTPMethod* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ownmfa.api.HardwareTOTPMethod";
  }
  protected:
  explicit HardwareTOTPMethod(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecretFieldNumber = 3,
    kHashFieldNumber = 1,
    kDigitsFieldNumber = 2,
  };
  // bytes secret = 3 [(.validate.rules) = {
  void clear_secret() ;
  const std::string& secret() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_secret(Arg_&& arg, Args_... args);
  std::string* mutable_secret();
  PROTOBUF_NODISCARD std::string* release_secret();
  void set_allocated_secret(std::string* ptr);

  private:
  const std::string& _internal_secret() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_secret(
      const std::string& value);
  std::string* _internal_mutable_secret();

  public:
  // .ownmfa.api.Hash hash = 1;
  void clear_hash() ;
  ::ownmfa::api::Hash hash() const;
  void set_hash(::ownmfa::api::Hash value);

  private:
  ::ownmfa::api::Hash _internal_hash() const;
  void _internal_set_hash(::ownmfa::api::Hash value);

  public:
  // int32 digits = 2 [(.validate.rules) = {
  void clear_digits() ;
  ::int32_t digits() const;
  void set_digits(::int32_t value);

  private:
  ::int32_t _internal_digits() const;
  void _internal_set_digits(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:ownmfa.api.HardwareTOTPMethod)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr secret_;
    int hash_;
    ::int32_t digits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fownmfa_5fapp_5fidentity_2eproto;
};// -------------------------------------------------------------------

class SMSMethod final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ownmfa.api.SMSMethod) */ {
 public:
  inline SMSMethod() : SMSMethod(nullptr) {}
  ~SMSMethod() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SMSMethod(::google::protobuf::internal::ConstantInitialized);

  SMSMethod(const SMSMethod& from);
  SMSMethod(SMSMethod&& from) noexcept
    : SMSMethod() {
    *this = ::std::move(from);
  }

  inline SMSMethod& operator=(const SMSMethod& from) {
    CopyFrom(from);
    return *this;
  }
  inline SMSMethod& operator=(SMSMethod&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SMSMethod& default_instance() {
    return *internal_default_instance();
  }
  static inline const SMSMethod* internal_default_instance() {
    return reinterpret_cast<const SMSMethod*>(
               &_SMSMethod_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(SMSMethod& a, SMSMethod& b) {
    a.Swap(&b);
  }
  inline void Swap(SMSMethod* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SMSMethod* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SMSMethod* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SMSMethod>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SMSMethod& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SMSMethod& from) {
    SMSMethod::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SMSMethod* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ownmfa.api.SMSMethod";
  }
  protected:
  explicit SMSMethod(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPhoneFieldNumber = 1,
  };
  // string phone = 1 [(.validate.rules) = {
  void clear_phone() ;
  const std::string& phone() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_phone(Arg_&& arg, Args_... args);
  std::string* mutable_phone();
  PROTOBUF_NODISCARD std::string* release_phone();
  void set_allocated_phone(std::string* ptr);

  private:
  const std::string& _internal_phone() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_phone(
      const std::string& value);
  std::string* _internal_mutable_phone();

  public:
  // @@protoc_insertion_point(class_scope:ownmfa.api.SMSMethod)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 34, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr phone_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fownmfa_5fapp_5fidentity_2eproto;
};// -------------------------------------------------------------------

class PushoverMethod final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ownmfa.api.PushoverMethod) */ {
 public:
  inline PushoverMethod() : PushoverMethod(nullptr) {}
  ~PushoverMethod() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PushoverMethod(::google::protobuf::internal::ConstantInitialized);

  PushoverMethod(const PushoverMethod& from);
  PushoverMethod(PushoverMethod&& from) noexcept
    : PushoverMethod() {
    *this = ::std::move(from);
  }

  inline PushoverMethod& operator=(const PushoverMethod& from) {
    CopyFrom(from);
    return *this;
  }
  inline PushoverMethod& operator=(PushoverMethod&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PushoverMethod& default_instance() {
    return *internal_default_instance();
  }
  static inline const PushoverMethod* internal_default_instance() {
    return reinterpret_cast<const PushoverMethod*>(
               &_PushoverMethod_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(PushoverMethod& a, PushoverMethod& b) {
    a.Swap(&b);
  }
  inline void Swap(PushoverMethod* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PushoverMethod* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PushoverMethod* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PushoverMethod>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PushoverMethod& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const PushoverMethod& from) {
    PushoverMethod::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PushoverMethod* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ownmfa.api.PushoverMethod";
  }
  protected:
  explicit PushoverMethod(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPushoverKeyFieldNumber = 1,
  };
  // string pushover_key = 1 [(.validate.rules) = {
  void clear_pushover_key() ;
  const std::string& pushover_key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_pushover_key(Arg_&& arg, Args_... args);
  std::string* mutable_pushover_key();
  PROTOBUF_NODISCARD std::string* release_pushover_key();
  void set_allocated_pushover_key(std::string* ptr);

  private:
  const std::string& _internal_pushover_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pushover_key(
      const std::string& value);
  std::string* _internal_mutable_pushover_key();

  public:
  // @@protoc_insertion_point(class_scope:ownmfa.api.PushoverMethod)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 46, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr pushover_key_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fownmfa_5fapp_5fidentity_2eproto;
};// -------------------------------------------------------------------

class EmailMethod final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ownmfa.api.EmailMethod) */ {
 public:
  inline EmailMethod() : EmailMethod(nullptr) {}
  ~EmailMethod() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EmailMethod(::google::protobuf::internal::ConstantInitialized);

  EmailMethod(const EmailMethod& from);
  EmailMethod(EmailMethod&& from) noexcept
    : EmailMethod() {
    *this = ::std::move(from);
  }

  inline EmailMethod& operator=(const EmailMethod& from) {
    CopyFrom(from);
    return *this;
  }
  inline EmailMethod& operator=(EmailMethod&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EmailMethod& default_instance() {
    return *internal_default_instance();
  }
  static inline const EmailMethod* internal_default_instance() {
    return reinterpret_cast<const EmailMethod*>(
               &_EmailMethod_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(EmailMethod& a, EmailMethod& b) {
    a.Swap(&b);
  }
  inline void Swap(EmailMethod* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EmailMethod* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EmailMethod* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EmailMethod>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EmailMethod& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const EmailMethod& from) {
    EmailMethod::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EmailMethod* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ownmfa.api.EmailMethod";
  }
  protected:
  explicit EmailMethod(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEmailFieldNumber = 1,
  };
  // string email = 1 [(.validate.rules) = {
  void clear_email() ;
  const std::string& email() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_email(Arg_&& arg, Args_... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* ptr);

  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(
      const std::string& value);
  std::string* _internal_mutable_email();

  public:
  // @@protoc_insertion_point(class_scope:ownmfa.api.EmailMethod)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 36, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr email_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fownmfa_5fapp_5fidentity_2eproto;
};// -------------------------------------------------------------------

class BackupsCodesMethod final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ownmfa.api.BackupsCodesMethod) */ {
 public:
  inline BackupsCodesMethod() : BackupsCodesMethod(nullptr) {}
  ~BackupsCodesMethod() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BackupsCodesMethod(::google::protobuf::internal::ConstantInitialized);

  BackupsCodesMethod(const BackupsCodesMethod& from);
  BackupsCodesMethod(BackupsCodesMethod&& from) noexcept
    : BackupsCodesMethod() {
    *this = ::std::move(from);
  }

  inline BackupsCodesMethod& operator=(const BackupsCodesMethod& from) {
    CopyFrom(from);
    return *this;
  }
  inline BackupsCodesMethod& operator=(BackupsCodesMethod&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BackupsCodesMethod& default_instance() {
    return *internal_default_instance();
  }
  static inline const BackupsCodesMethod* internal_default_instance() {
    return reinterpret_cast<const BackupsCodesMethod*>(
               &_BackupsCodesMethod_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(BackupsCodesMethod& a, BackupsCodesMethod& b) {
    a.Swap(&b);
  }
  inline void Swap(BackupsCodesMethod* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BackupsCodesMethod* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BackupsCodesMethod* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BackupsCodesMethod>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BackupsCodesMethod& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const BackupsCodesMethod& from) {
    BackupsCodesMethod::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BackupsCodesMethod* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ownmfa.api.BackupsCodesMethod";
  }
  protected:
  explicit BackupsCodesMethod(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPasscodesFieldNumber = 1,
  };
  // int32 passcodes = 1 [(.validate.rules) = {
  void clear_passcodes() ;
  ::int32_t passcodes() const;
  void set_passcodes(::int32_t value);

  private:
  ::int32_t _internal_passcodes() const;
  void _internal_set_passcodes(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:ownmfa.api.BackupsCodesMethod)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::int32_t passcodes_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fownmfa_5fapp_5fidentity_2eproto;
};// -------------------------------------------------------------------

class SecurityQuestionsMethod final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ownmfa.api.SecurityQuestionsMethod) */ {
 public:
  inline SecurityQuestionsMethod() : SecurityQuestionsMethod(nullptr) {}
  ~SecurityQuestionsMethod() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SecurityQuestionsMethod(::google::protobuf::internal::ConstantInitialized);

  SecurityQuestionsMethod(const SecurityQuestionsMethod& from);
  SecurityQuestionsMethod(SecurityQuestionsMethod&& from) noexcept
    : SecurityQuestionsMethod() {
    *this = ::std::move(from);
  }

  inline SecurityQuestionsMethod& operator=(const SecurityQuestionsMethod& from) {
    CopyFrom(from);
    return *this;
  }
  inline SecurityQuestionsMethod& operator=(SecurityQuestionsMethod&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SecurityQuestionsMethod& default_instance() {
    return *internal_default_instance();
  }
  static inline const SecurityQuestionsMethod* internal_default_instance() {
    return reinterpret_cast<const SecurityQuestionsMethod*>(
               &_SecurityQuestionsMethod_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(SecurityQuestionsMethod& a, SecurityQuestionsMethod& b) {
    a.Swap(&b);
  }
  inline void Swap(SecurityQuestionsMethod* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SecurityQuestionsMethod* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SecurityQuestionsMethod* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SecurityQuestionsMethod>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SecurityQuestionsMethod& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SecurityQuestionsMethod& from) {
    SecurityQuestionsMethod::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SecurityQuestionsMethod* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ownmfa.api.SecurityQuestionsMethod";
  }
  protected:
  explicit SecurityQuestionsMethod(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAnswerFieldNumber = 1,
  };
  // string answer = 1 [(.validate.rules) = {
  void clear_answer() ;
  const std::string& answer() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_answer(Arg_&& arg, Args_... args);
  std::string* mutable_answer();
  PROTOBUF_NODISCARD std::string* release_answer();
  void set_allocated_answer(std::string* ptr);

  private:
  const std::string& _internal_answer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_answer(
      const std::string& value);
  std::string* _internal_mutable_answer();

  public:
  // @@protoc_insertion_point(class_scope:ownmfa.api.SecurityQuestionsMethod)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 49, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr answer_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fownmfa_5fapp_5fidentity_2eproto;
};// -------------------------------------------------------------------

class Identity final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ownmfa.api.Identity) */ {
 public:
  inline Identity() : Identity(nullptr) {}
  ~Identity() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Identity(::google::protobuf::internal::ConstantInitialized);

  Identity(const Identity& from);
  Identity(Identity&& from) noexcept
    : Identity() {
    *this = ::std::move(from);
  }

  inline Identity& operator=(const Identity& from) {
    CopyFrom(from);
    return *this;
  }
  inline Identity& operator=(Identity&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Identity& default_instance() {
    return *internal_default_instance();
  }
  enum MethodOneofCase {
    kSoftwareHotpMethod = 16,
    kSoftwareTotpMethod = 6,
    kGoogleAuthHotpMethod = 17,
    kGoogleAuthTotpMethod = 7,
    kAppleIosTotpMethod = 22,
    kHardwareHotpMethod = 18,
    kHardwareTotpMethod = 19,
    kSmsMethod = 8,
    kPushoverMethod = 20,
    kEmailMethod = 9,
    kBackupCodesMethod = 10,
    kSecurityQuestionsMethod = 21,
    METHOD_ONEOF_NOT_SET = 0,
  };

  static inline const Identity* internal_default_instance() {
    return reinterpret_cast<const Identity*>(
               &_Identity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(Identity& a, Identity& b) {
    a.Swap(&b);
  }
  inline void Swap(Identity* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Identity* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Identity* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Identity>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Identity& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Identity& from) {
    Identity::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Identity* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ownmfa.api.Identity";
  }
  protected:
  explicit Identity(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kOrgIdFieldNumber = 2,
    kAppIdFieldNumber = 3,
    kCommentFieldNumber = 4,
    kCreatedAtFieldNumber = 14,
    kUpdatedAtFieldNumber = 15,
    kStatusFieldNumber = 5,
    kSoftwareHotpMethodFieldNumber = 16,
    kSoftwareTotpMethodFieldNumber = 6,
    kGoogleAuthHotpMethodFieldNumber = 17,
    kGoogleAuthTotpMethodFieldNumber = 7,
    kAppleIosTotpMethodFieldNumber = 22,
    kHardwareHotpMethodFieldNumber = 18,
    kHardwareTotpMethodFieldNumber = 19,
    kSmsMethodFieldNumber = 8,
    kPushoverMethodFieldNumber = 20,
    kEmailMethodFieldNumber = 9,
    kBackupCodesMethodFieldNumber = 10,
    kSecurityQuestionsMethodFieldNumber = 21,
  };
  // string id = 1 [(.google.api.field_behavior) = OUTPUT_ONLY];
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string org_id = 2 [json_name = "orgID", (.google.api.field_behavior) = OUTPUT_ONLY];
  void clear_org_id() ;
  const std::string& org_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_org_id(Arg_&& arg, Args_... args);
  std::string* mutable_org_id();
  PROTOBUF_NODISCARD std::string* release_org_id();
  void set_allocated_org_id(std::string* ptr);

  private:
  const std::string& _internal_org_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_org_id(
      const std::string& value);
  std::string* _internal_mutable_org_id();

  public:
  // string app_id = 3 [json_name = "appID", (.google.api.field_behavior) = OUTPUT_ONLY];
  void clear_app_id() ;
  const std::string& app_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_app_id(Arg_&& arg, Args_... args);
  std::string* mutable_app_id();
  PROTOBUF_NODISCARD std::string* release_app_id();
  void set_allocated_app_id(std::string* ptr);

  private:
  const std::string& _internal_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_id(
      const std::string& value);
  std::string* _internal_mutable_app_id();

  public:
  // string comment = 4 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  void clear_comment() ;
  const std::string& comment() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_comment(Arg_&& arg, Args_... args);
  std::string* mutable_comment();
  PROTOBUF_NODISCARD std::string* release_comment();
  void set_allocated_comment(std::string* ptr);

  private:
  const std::string& _internal_comment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comment(
      const std::string& value);
  std::string* _internal_mutable_comment();

  public:
  // .google.protobuf.Timestamp created_at = 14 [(.google.api.field_behavior) = OUTPUT_ONLY];
  bool has_created_at() const;
  void clear_created_at() ;
  const ::google::protobuf::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_created_at();
  ::google::protobuf::Timestamp* mutable_created_at();
  void set_allocated_created_at(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_created_at(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_created_at();

  private:
  const ::google::protobuf::Timestamp& _internal_created_at() const;
  ::google::protobuf::Timestamp* _internal_mutable_created_at();

  public:
  // .google.protobuf.Timestamp updated_at = 15 [(.google.api.field_behavior) = OUTPUT_ONLY];
  bool has_updated_at() const;
  void clear_updated_at() ;
  const ::google::protobuf::Timestamp& updated_at() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_updated_at();
  ::google::protobuf::Timestamp* mutable_updated_at();
  void set_allocated_updated_at(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_updated_at(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_updated_at();

  private:
  const ::google::protobuf::Timestamp& _internal_updated_at() const;
  ::google::protobuf::Timestamp* _internal_mutable_updated_at();

  public:
  // .ownmfa.api.IdentityStatus status = 5 [(.google.api.field_behavior) = OUTPUT_ONLY];
  void clear_status() ;
  ::ownmfa::api::IdentityStatus status() const;
  void set_status(::ownmfa::api::IdentityStatus value);

  private:
  ::ownmfa::api::IdentityStatus _internal_status() const;
  void _internal_set_status(::ownmfa::api::IdentityStatus value);

  public:
  // .ownmfa.api.SoftwareHOTPMethod software_hotp_method = 16 [json_name = "softwareHOTPMethod"];
  bool has_software_hotp_method() const;
  private:
  bool _internal_has_software_hotp_method() const;

  public:
  void clear_software_hotp_method() ;
  const ::ownmfa::api::SoftwareHOTPMethod& software_hotp_method() const;
  PROTOBUF_NODISCARD ::ownmfa::api::SoftwareHOTPMethod* release_software_hotp_method();
  ::ownmfa::api::SoftwareHOTPMethod* mutable_software_hotp_method();
  void set_allocated_software_hotp_method(::ownmfa::api::SoftwareHOTPMethod* value);
  void unsafe_arena_set_allocated_software_hotp_method(::ownmfa::api::SoftwareHOTPMethod* value);
  ::ownmfa::api::SoftwareHOTPMethod* unsafe_arena_release_software_hotp_method();

  private:
  const ::ownmfa::api::SoftwareHOTPMethod& _internal_software_hotp_method() const;
  ::ownmfa::api::SoftwareHOTPMethod* _internal_mutable_software_hotp_method();

  public:
  // .ownmfa.api.SoftwareTOTPMethod software_totp_method = 6 [json_name = "softwareTOTPMethod"];
  bool has_software_totp_method() const;
  private:
  bool _internal_has_software_totp_method() const;

  public:
  void clear_software_totp_method() ;
  const ::ownmfa::api::SoftwareTOTPMethod& software_totp_method() const;
  PROTOBUF_NODISCARD ::ownmfa::api::SoftwareTOTPMethod* release_software_totp_method();
  ::ownmfa::api::SoftwareTOTPMethod* mutable_software_totp_method();
  void set_allocated_software_totp_method(::ownmfa::api::SoftwareTOTPMethod* value);
  void unsafe_arena_set_allocated_software_totp_method(::ownmfa::api::SoftwareTOTPMethod* value);
  ::ownmfa::api::SoftwareTOTPMethod* unsafe_arena_release_software_totp_method();

  private:
  const ::ownmfa::api::SoftwareTOTPMethod& _internal_software_totp_method() const;
  ::ownmfa::api::SoftwareTOTPMethod* _internal_mutable_software_totp_method();

  public:
  // .ownmfa.api.GoogleAuthHOTPMethod google_auth_hotp_method = 17 [json_name = "googleAuthHOTPMethod"];
  bool has_google_auth_hotp_method() const;
  private:
  bool _internal_has_google_auth_hotp_method() const;

  public:
  void clear_google_auth_hotp_method() ;
  const ::ownmfa::api::GoogleAuthHOTPMethod& google_auth_hotp_method() const;
  PROTOBUF_NODISCARD ::ownmfa::api::GoogleAuthHOTPMethod* release_google_auth_hotp_method();
  ::ownmfa::api::GoogleAuthHOTPMethod* mutable_google_auth_hotp_method();
  void set_allocated_google_auth_hotp_method(::ownmfa::api::GoogleAuthHOTPMethod* value);
  void unsafe_arena_set_allocated_google_auth_hotp_method(::ownmfa::api::GoogleAuthHOTPMethod* value);
  ::ownmfa::api::GoogleAuthHOTPMethod* unsafe_arena_release_google_auth_hotp_method();

  private:
  const ::ownmfa::api::GoogleAuthHOTPMethod& _internal_google_auth_hotp_method() const;
  ::ownmfa::api::GoogleAuthHOTPMethod* _internal_mutable_google_auth_hotp_method();

  public:
  // .ownmfa.api.GoogleAuthTOTPMethod google_auth_totp_method = 7 [json_name = "googleAuthTOTPMethod"];
  bool has_google_auth_totp_method() const;
  private:
  bool _internal_has_google_auth_totp_method() const;

  public:
  void clear_google_auth_totp_method() ;
  const ::ownmfa::api::GoogleAuthTOTPMethod& google_auth_totp_method() const;
  PROTOBUF_NODISCARD ::ownmfa::api::GoogleAuthTOTPMethod* release_google_auth_totp_method();
  ::ownmfa::api::GoogleAuthTOTPMethod* mutable_google_auth_totp_method();
  void set_allocated_google_auth_totp_method(::ownmfa::api::GoogleAuthTOTPMethod* value);
  void unsafe_arena_set_allocated_google_auth_totp_method(::ownmfa::api::GoogleAuthTOTPMethod* value);
  ::ownmfa::api::GoogleAuthTOTPMethod* unsafe_arena_release_google_auth_totp_method();

  private:
  const ::ownmfa::api::GoogleAuthTOTPMethod& _internal_google_auth_totp_method() const;
  ::ownmfa::api::GoogleAuthTOTPMethod* _internal_mutable_google_auth_totp_method();

  public:
  // .ownmfa.api.AppleiOSTOTPMethod apple_ios_totp_method = 22 [json_name = "appleiOSTOTPMethod"];
  bool has_apple_ios_totp_method() const;
  private:
  bool _internal_has_apple_ios_totp_method() const;

  public:
  void clear_apple_ios_totp_method() ;
  const ::ownmfa::api::AppleiOSTOTPMethod& apple_ios_totp_method() const;
  PROTOBUF_NODISCARD ::ownmfa::api::AppleiOSTOTPMethod* release_apple_ios_totp_method();
  ::ownmfa::api::AppleiOSTOTPMethod* mutable_apple_ios_totp_method();
  void set_allocated_apple_ios_totp_method(::ownmfa::api::AppleiOSTOTPMethod* value);
  void unsafe_arena_set_allocated_apple_ios_totp_method(::ownmfa::api::AppleiOSTOTPMethod* value);
  ::ownmfa::api::AppleiOSTOTPMethod* unsafe_arena_release_apple_ios_totp_method();

  private:
  const ::ownmfa::api::AppleiOSTOTPMethod& _internal_apple_ios_totp_method() const;
  ::ownmfa::api::AppleiOSTOTPMethod* _internal_mutable_apple_ios_totp_method();

  public:
  // .ownmfa.api.HardwareHOTPMethod hardware_hotp_method = 18 [json_name = "hardwareHOTPMethod"];
  bool has_hardware_hotp_method() const;
  private:
  bool _internal_has_hardware_hotp_method() const;

  public:
  void clear_hardware_hotp_method() ;
  const ::ownmfa::api::HardwareHOTPMethod& hardware_hotp_method() const;
  PROTOBUF_NODISCARD ::ownmfa::api::HardwareHOTPMethod* release_hardware_hotp_method();
  ::ownmfa::api::HardwareHOTPMethod* mutable_hardware_hotp_method();
  void set_allocated_hardware_hotp_method(::ownmfa::api::HardwareHOTPMethod* value);
  void unsafe_arena_set_allocated_hardware_hotp_method(::ownmfa::api::HardwareHOTPMethod* value);
  ::ownmfa::api::HardwareHOTPMethod* unsafe_arena_release_hardware_hotp_method();

  private:
  const ::ownmfa::api::HardwareHOTPMethod& _internal_hardware_hotp_method() const;
  ::ownmfa::api::HardwareHOTPMethod* _internal_mutable_hardware_hotp_method();

  public:
  // .ownmfa.api.HardwareTOTPMethod hardware_totp_method = 19 [json_name = "hardwareTOTPMethod"];
  bool has_hardware_totp_method() const;
  private:
  bool _internal_has_hardware_totp_method() const;

  public:
  void clear_hardware_totp_method() ;
  const ::ownmfa::api::HardwareTOTPMethod& hardware_totp_method() const;
  PROTOBUF_NODISCARD ::ownmfa::api::HardwareTOTPMethod* release_hardware_totp_method();
  ::ownmfa::api::HardwareTOTPMethod* mutable_hardware_totp_method();
  void set_allocated_hardware_totp_method(::ownmfa::api::HardwareTOTPMethod* value);
  void unsafe_arena_set_allocated_hardware_totp_method(::ownmfa::api::HardwareTOTPMethod* value);
  ::ownmfa::api::HardwareTOTPMethod* unsafe_arena_release_hardware_totp_method();

  private:
  const ::ownmfa::api::HardwareTOTPMethod& _internal_hardware_totp_method() const;
  ::ownmfa::api::HardwareTOTPMethod* _internal_mutable_hardware_totp_method();

  public:
  // .ownmfa.api.SMSMethod sms_method = 8;
  bool has_sms_method() const;
  private:
  bool _internal_has_sms_method() const;

  public:
  void clear_sms_method() ;
  const ::ownmfa::api::SMSMethod& sms_method() const;
  PROTOBUF_NODISCARD ::ownmfa::api::SMSMethod* release_sms_method();
  ::ownmfa::api::SMSMethod* mutable_sms_method();
  void set_allocated_sms_method(::ownmfa::api::SMSMethod* value);
  void unsafe_arena_set_allocated_sms_method(::ownmfa::api::SMSMethod* value);
  ::ownmfa::api::SMSMethod* unsafe_arena_release_sms_method();

  private:
  const ::ownmfa::api::SMSMethod& _internal_sms_method() const;
  ::ownmfa::api::SMSMethod* _internal_mutable_sms_method();

  public:
  // .ownmfa.api.PushoverMethod pushover_method = 20;
  bool has_pushover_method() const;
  private:
  bool _internal_has_pushover_method() const;

  public:
  void clear_pushover_method() ;
  const ::ownmfa::api::PushoverMethod& pushover_method() const;
  PROTOBUF_NODISCARD ::ownmfa::api::PushoverMethod* release_pushover_method();
  ::ownmfa::api::PushoverMethod* mutable_pushover_method();
  void set_allocated_pushover_method(::ownmfa::api::PushoverMethod* value);
  void unsafe_arena_set_allocated_pushover_method(::ownmfa::api::PushoverMethod* value);
  ::ownmfa::api::PushoverMethod* unsafe_arena_release_pushover_method();

  private:
  const ::ownmfa::api::PushoverMethod& _internal_pushover_method() const;
  ::ownmfa::api::PushoverMethod* _internal_mutable_pushover_method();

  public:
  // .ownmfa.api.EmailMethod email_method = 9;
  bool has_email_method() const;
  private:
  bool _internal_has_email_method() const;

  public:
  void clear_email_method() ;
  const ::ownmfa::api::EmailMethod& email_method() const;
  PROTOBUF_NODISCARD ::ownmfa::api::EmailMethod* release_email_method();
  ::ownmfa::api::EmailMethod* mutable_email_method();
  void set_allocated_email_method(::ownmfa::api::EmailMethod* value);
  void unsafe_arena_set_allocated_email_method(::ownmfa::api::EmailMethod* value);
  ::ownmfa::api::EmailMethod* unsafe_arena_release_email_method();

  private:
  const ::ownmfa::api::EmailMethod& _internal_email_method() const;
  ::ownmfa::api::EmailMethod* _internal_mutable_email_method();

  public:
  // .ownmfa.api.BackupsCodesMethod backup_codes_method = 10;
  bool has_backup_codes_method() const;
  private:
  bool _internal_has_backup_codes_method() const;

  public:
  void clear_backup_codes_method() ;
  const ::ownmfa::api::BackupsCodesMethod& backup_codes_method() const;
  PROTOBUF_NODISCARD ::ownmfa::api::BackupsCodesMethod* release_backup_codes_method();
  ::ownmfa::api::BackupsCodesMethod* mutable_backup_codes_method();
  void set_allocated_backup_codes_method(::ownmfa::api::BackupsCodesMethod* value);
  void unsafe_arena_set_allocated_backup_codes_method(::ownmfa::api::BackupsCodesMethod* value);
  ::ownmfa::api::BackupsCodesMethod* unsafe_arena_release_backup_codes_method();

  private:
  const ::ownmfa::api::BackupsCodesMethod& _internal_backup_codes_method() const;
  ::ownmfa::api::BackupsCodesMethod* _internal_mutable_backup_codes_method();

  public:
  // .ownmfa.api.SecurityQuestionsMethod security_questions_method = 21;
  bool has_security_questions_method() const;
  private:
  bool _internal_has_security_questions_method() const;

  public:
  void clear_security_questions_method() ;
  const ::ownmfa::api::SecurityQuestionsMethod& security_questions_method() const;
  PROTOBUF_NODISCARD ::ownmfa::api::SecurityQuestionsMethod* release_security_questions_method();
  ::ownmfa::api::SecurityQuestionsMethod* mutable_security_questions_method();
  void set_allocated_security_questions_method(::ownmfa::api::SecurityQuestionsMethod* value);
  void unsafe_arena_set_allocated_security_questions_method(::ownmfa::api::SecurityQuestionsMethod* value);
  ::ownmfa::api::SecurityQuestionsMethod* unsafe_arena_release_security_questions_method();

  private:
  const ::ownmfa::api::SecurityQuestionsMethod& _internal_security_questions_method() const;
  ::ownmfa::api::SecurityQuestionsMethod* _internal_mutable_security_questions_method();

  public:
  void clear_method_oneof();
  MethodOneofCase method_oneof_case() const;
  // @@protoc_insertion_point(class_scope:ownmfa.api.Identity)
 private:
  class _Internal;
  void set_has_software_hotp_method();
  void set_has_software_totp_method();
  void set_has_google_auth_hotp_method();
  void set_has_google_auth_totp_method();
  void set_has_apple_ios_totp_method();
  void set_has_hardware_hotp_method();
  void set_has_hardware_totp_method();
  void set_has_sms_method();
  void set_has_pushover_method();
  void set_has_email_method();
  void set_has_backup_codes_method();
  void set_has_security_questions_method();

  inline bool has_method_oneof() const;
  inline void clear_has_method_oneof();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<3, 19, 14, 65, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr org_id_;
    ::google::protobuf::internal::ArenaStringPtr app_id_;
    ::google::protobuf::internal::ArenaStringPtr comment_;
    ::google::protobuf::Timestamp* created_at_;
    ::google::protobuf::Timestamp* updated_at_;
    int status_;
    union MethodOneofUnion {
      constexpr MethodOneofUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::ownmfa::api::SoftwareHOTPMethod* software_hotp_method_;
      ::ownmfa::api::SoftwareTOTPMethod* software_totp_method_;
      ::ownmfa::api::GoogleAuthHOTPMethod* google_auth_hotp_method_;
      ::ownmfa::api::GoogleAuthTOTPMethod* google_auth_totp_method_;
      ::ownmfa::api::AppleiOSTOTPMethod* apple_ios_totp_method_;
      ::ownmfa::api::HardwareHOTPMethod* hardware_hotp_method_;
      ::ownmfa::api::HardwareTOTPMethod* hardware_totp_method_;
      ::ownmfa::api::SMSMethod* sms_method_;
      ::ownmfa::api::PushoverMethod* pushover_method_;
      ::ownmfa::api::EmailMethod* email_method_;
      ::ownmfa::api::BackupsCodesMethod* backup_codes_method_;
      ::ownmfa::api::SecurityQuestionsMethod* security_questions_method_;
    } method_oneof_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fownmfa_5fapp_5fidentity_2eproto;
};// -------------------------------------------------------------------

class CreateIdentityRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ownmfa.api.CreateIdentityRequest) */ {
 public:
  inline CreateIdentityRequest() : CreateIdentityRequest(nullptr) {}
  ~CreateIdentityRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CreateIdentityRequest(::google::protobuf::internal::ConstantInitialized);

  CreateIdentityRequest(const CreateIdentityRequest& from);
  CreateIdentityRequest(CreateIdentityRequest&& from) noexcept
    : CreateIdentityRequest() {
    *this = ::std::move(from);
  }

  inline CreateIdentityRequest& operator=(const CreateIdentityRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateIdentityRequest& operator=(CreateIdentityRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateIdentityRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateIdentityRequest* internal_default_instance() {
    return reinterpret_cast<const CreateIdentityRequest*>(
               &_CreateIdentityRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(CreateIdentityRequest& a, CreateIdentityRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateIdentityRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateIdentityRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateIdentityRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateIdentityRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateIdentityRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CreateIdentityRequest& from) {
    CreateIdentityRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateIdentityRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ownmfa.api.CreateIdentityRequest";
  }
  protected:
  explicit CreateIdentityRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdentityFieldNumber = 1,
  };
  // .ownmfa.api.Identity identity = 1 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  bool has_identity() const;
  void clear_identity() ;
  const ::ownmfa::api::Identity& identity() const;
  PROTOBUF_NODISCARD ::ownmfa::api::Identity* release_identity();
  ::ownmfa::api::Identity* mutable_identity();
  void set_allocated_identity(::ownmfa::api::Identity* value);
  void unsafe_arena_set_allocated_identity(::ownmfa::api::Identity* value);
  ::ownmfa::api::Identity* unsafe_arena_release_identity();

  private:
  const ::ownmfa::api::Identity& _internal_identity() const;
  ::ownmfa::api::Identity* _internal_mutable_identity();

  public:
  // @@protoc_insertion_point(class_scope:ownmfa.api.CreateIdentityRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::ownmfa::api::Identity* identity_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fownmfa_5fapp_5fidentity_2eproto;
};// -------------------------------------------------------------------

class CreateIdentityResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ownmfa.api.CreateIdentityResponse) */ {
 public:
  inline CreateIdentityResponse() : CreateIdentityResponse(nullptr) {}
  ~CreateIdentityResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CreateIdentityResponse(::google::protobuf::internal::ConstantInitialized);

  CreateIdentityResponse(const CreateIdentityResponse& from);
  CreateIdentityResponse(CreateIdentityResponse&& from) noexcept
    : CreateIdentityResponse() {
    *this = ::std::move(from);
  }

  inline CreateIdentityResponse& operator=(const CreateIdentityResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateIdentityResponse& operator=(CreateIdentityResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateIdentityResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateIdentityResponse* internal_default_instance() {
    return reinterpret_cast<const CreateIdentityResponse*>(
               &_CreateIdentityResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(CreateIdentityResponse& a, CreateIdentityResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateIdentityResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateIdentityResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateIdentityResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateIdentityResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateIdentityResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CreateIdentityResponse& from) {
    CreateIdentityResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateIdentityResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ownmfa.api.CreateIdentityResponse";
  }
  protected:
  explicit CreateIdentityResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPasscodesFieldNumber = 4,
    kSecretFieldNumber = 2,
    kQrFieldNumber = 3,
    kIdentityFieldNumber = 1,
  };
  // repeated string passcodes = 4;
  int passcodes_size() const;
  private:
  int _internal_passcodes_size() const;

  public:
  void clear_passcodes() ;
  const std::string& passcodes(int index) const;
  std::string* mutable_passcodes(int index);
  void set_passcodes(int index, const std::string& value);
  void set_passcodes(int index, std::string&& value);
  void set_passcodes(int index, const char* value);
  void set_passcodes(int index, const char* value, std::size_t size);
  void set_passcodes(int index, absl::string_view value);
  std::string* add_passcodes();
  void add_passcodes(const std::string& value);
  void add_passcodes(std::string&& value);
  void add_passcodes(const char* value);
  void add_passcodes(const char* value, std::size_t size);
  void add_passcodes(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& passcodes() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_passcodes();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_passcodes() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_passcodes();

  public:
  // string secret = 2;
  void clear_secret() ;
  const std::string& secret() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_secret(Arg_&& arg, Args_... args);
  std::string* mutable_secret();
  PROTOBUF_NODISCARD std::string* release_secret();
  void set_allocated_secret(std::string* ptr);

  private:
  const std::string& _internal_secret() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_secret(
      const std::string& value);
  std::string* _internal_mutable_secret();

  public:
  // bytes qr = 3;
  void clear_qr() ;
  const std::string& qr() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_qr(Arg_&& arg, Args_... args);
  std::string* mutable_qr();
  PROTOBUF_NODISCARD std::string* release_qr();
  void set_allocated_qr(std::string* ptr);

  private:
  const std::string& _internal_qr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_qr(
      const std::string& value);
  std::string* _internal_mutable_qr();

  public:
  // .ownmfa.api.Identity identity = 1;
  bool has_identity() const;
  void clear_identity() ;
  const ::ownmfa::api::Identity& identity() const;
  PROTOBUF_NODISCARD ::ownmfa::api::Identity* release_identity();
  ::ownmfa::api::Identity* mutable_identity();
  void set_allocated_identity(::ownmfa::api::Identity* value);
  void unsafe_arena_set_allocated_identity(::ownmfa::api::Identity* value);
  ::ownmfa::api::Identity* unsafe_arena_release_identity();

  private:
  const ::ownmfa::api::Identity& _internal_identity() const;
  ::ownmfa::api::Identity* _internal_mutable_identity();

  public:
  // @@protoc_insertion_point(class_scope:ownmfa.api.CreateIdentityResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 4, 1, 57, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> passcodes_;
    ::google::protobuf::internal::ArenaStringPtr secret_;
    ::google::protobuf::internal::ArenaStringPtr qr_;
    ::ownmfa::api::Identity* identity_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fownmfa_5fapp_5fidentity_2eproto;
};// -------------------------------------------------------------------

class ActivateIdentityRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ownmfa.api.ActivateIdentityRequest) */ {
 public:
  inline ActivateIdentityRequest() : ActivateIdentityRequest(nullptr) {}
  ~ActivateIdentityRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ActivateIdentityRequest(::google::protobuf::internal::ConstantInitialized);

  ActivateIdentityRequest(const ActivateIdentityRequest& from);
  ActivateIdentityRequest(ActivateIdentityRequest&& from) noexcept
    : ActivateIdentityRequest() {
    *this = ::std::move(from);
  }

  inline ActivateIdentityRequest& operator=(const ActivateIdentityRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActivateIdentityRequest& operator=(ActivateIdentityRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActivateIdentityRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActivateIdentityRequest* internal_default_instance() {
    return reinterpret_cast<const ActivateIdentityRequest*>(
               &_ActivateIdentityRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(ActivateIdentityRequest& a, ActivateIdentityRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ActivateIdentityRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActivateIdentityRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActivateIdentityRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ActivateIdentityRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ActivateIdentityRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ActivateIdentityRequest& from) {
    ActivateIdentityRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActivateIdentityRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ownmfa.api.ActivateIdentityRequest";
  }
  protected:
  explicit ActivateIdentityRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kAppIdFieldNumber = 2,
    kPasscodeFieldNumber = 3,
  };
  // string id = 1 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string app_id = 2 [json_name = "appID", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  void clear_app_id() ;
  const std::string& app_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_app_id(Arg_&& arg, Args_... args);
  std::string* mutable_app_id();
  PROTOBUF_NODISCARD std::string* release_app_id();
  void set_allocated_app_id(std::string* ptr);

  private:
  const std::string& _internal_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_id(
      const std::string& value);
  std::string* _internal_mutable_app_id();

  public:
  // string passcode = 3 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  void clear_passcode() ;
  const std::string& passcode() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_passcode(Arg_&& arg, Args_... args);
  std::string* mutable_passcode();
  PROTOBUF_NODISCARD std::string* release_passcode();
  void set_allocated_passcode(std::string* ptr);

  private:
  const std::string& _internal_passcode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_passcode(
      const std::string& value);
  std::string* _internal_mutable_passcode();

  public:
  // @@protoc_insertion_point(class_scope:ownmfa.api.ActivateIdentityRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 0, 59, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr app_id_;
    ::google::protobuf::internal::ArenaStringPtr passcode_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fownmfa_5fapp_5fidentity_2eproto;
};// -------------------------------------------------------------------

class ChallengeIdentityRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ownmfa.api.ChallengeIdentityRequest) */ {
 public:
  inline ChallengeIdentityRequest() : ChallengeIdentityRequest(nullptr) {}
  ~ChallengeIdentityRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ChallengeIdentityRequest(::google::protobuf::internal::ConstantInitialized);

  ChallengeIdentityRequest(const ChallengeIdentityRequest& from);
  ChallengeIdentityRequest(ChallengeIdentityRequest&& from) noexcept
    : ChallengeIdentityRequest() {
    *this = ::std::move(from);
  }

  inline ChallengeIdentityRequest& operator=(const ChallengeIdentityRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChallengeIdentityRequest& operator=(ChallengeIdentityRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChallengeIdentityRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChallengeIdentityRequest* internal_default_instance() {
    return reinterpret_cast<const ChallengeIdentityRequest*>(
               &_ChallengeIdentityRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(ChallengeIdentityRequest& a, ChallengeIdentityRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ChallengeIdentityRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChallengeIdentityRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChallengeIdentityRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChallengeIdentityRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChallengeIdentityRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ChallengeIdentityRequest& from) {
    ChallengeIdentityRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChallengeIdentityRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ownmfa.api.ChallengeIdentityRequest";
  }
  protected:
  explicit ChallengeIdentityRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kAppIdFieldNumber = 2,
  };
  // string id = 1 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string app_id = 2 [json_name = "appID", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  void clear_app_id() ;
  const std::string& app_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_app_id(Arg_&& arg, Args_... args);
  std::string* mutable_app_id();
  PROTOBUF_NODISCARD std::string* release_app_id();
  void set_allocated_app_id(std::string* ptr);

  private:
  const std::string& _internal_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_id(
      const std::string& value);
  std::string* _internal_mutable_app_id();

  public:
  // @@protoc_insertion_point(class_scope:ownmfa.api.ChallengeIdentityRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 52, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr app_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fownmfa_5fapp_5fidentity_2eproto;
};// -------------------------------------------------------------------

class VerifyIdentityRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ownmfa.api.VerifyIdentityRequest) */ {
 public:
  inline VerifyIdentityRequest() : VerifyIdentityRequest(nullptr) {}
  ~VerifyIdentityRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR VerifyIdentityRequest(::google::protobuf::internal::ConstantInitialized);

  VerifyIdentityRequest(const VerifyIdentityRequest& from);
  VerifyIdentityRequest(VerifyIdentityRequest&& from) noexcept
    : VerifyIdentityRequest() {
    *this = ::std::move(from);
  }

  inline VerifyIdentityRequest& operator=(const VerifyIdentityRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline VerifyIdentityRequest& operator=(VerifyIdentityRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VerifyIdentityRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const VerifyIdentityRequest* internal_default_instance() {
    return reinterpret_cast<const VerifyIdentityRequest*>(
               &_VerifyIdentityRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(VerifyIdentityRequest& a, VerifyIdentityRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(VerifyIdentityRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VerifyIdentityRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VerifyIdentityRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VerifyIdentityRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VerifyIdentityRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const VerifyIdentityRequest& from) {
    VerifyIdentityRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VerifyIdentityRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ownmfa.api.VerifyIdentityRequest";
  }
  protected:
  explicit VerifyIdentityRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kAppIdFieldNumber = 2,
    kPasscodeFieldNumber = 3,
  };
  // string id = 1 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string app_id = 2 [json_name = "appID", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  void clear_app_id() ;
  const std::string& app_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_app_id(Arg_&& arg, Args_... args);
  std::string* mutable_app_id();
  PROTOBUF_NODISCARD std::string* release_app_id();
  void set_allocated_app_id(std::string* ptr);

  private:
  const std::string& _internal_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_id(
      const std::string& value);
  std::string* _internal_mutable_app_id();

  public:
  // string passcode = 3 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  void clear_passcode() ;
  const std::string& passcode() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_passcode(Arg_&& arg, Args_... args);
  std::string* mutable_passcode();
  PROTOBUF_NODISCARD std::string* release_passcode();
  void set_allocated_passcode(std::string* ptr);

  private:
  const std::string& _internal_passcode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_passcode(
      const std::string& value);
  std::string* _internal_mutable_passcode();

  public:
  // @@protoc_insertion_point(class_scope:ownmfa.api.VerifyIdentityRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 0, 57, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr app_id_;
    ::google::protobuf::internal::ArenaStringPtr passcode_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fownmfa_5fapp_5fidentity_2eproto;
};// -------------------------------------------------------------------

class GetIdentityRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ownmfa.api.GetIdentityRequest) */ {
 public:
  inline GetIdentityRequest() : GetIdentityRequest(nullptr) {}
  ~GetIdentityRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetIdentityRequest(::google::protobuf::internal::ConstantInitialized);

  GetIdentityRequest(const GetIdentityRequest& from);
  GetIdentityRequest(GetIdentityRequest&& from) noexcept
    : GetIdentityRequest() {
    *this = ::std::move(from);
  }

  inline GetIdentityRequest& operator=(const GetIdentityRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetIdentityRequest& operator=(GetIdentityRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetIdentityRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetIdentityRequest* internal_default_instance() {
    return reinterpret_cast<const GetIdentityRequest*>(
               &_GetIdentityRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(GetIdentityRequest& a, GetIdentityRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetIdentityRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetIdentityRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetIdentityRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetIdentityRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetIdentityRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const GetIdentityRequest& from) {
    GetIdentityRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetIdentityRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ownmfa.api.GetIdentityRequest";
  }
  protected:
  explicit GetIdentityRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kAppIdFieldNumber = 2,
  };
  // string id = 1 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string app_id = 2 [json_name = "appID", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  void clear_app_id() ;
  const std::string& app_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_app_id(Arg_&& arg, Args_... args);
  std::string* mutable_app_id();
  PROTOBUF_NODISCARD std::string* release_app_id();
  void set_allocated_app_id(std::string* ptr);

  private:
  const std::string& _internal_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_id(
      const std::string& value);
  std::string* _internal_mutable_app_id();

  public:
  // @@protoc_insertion_point(class_scope:ownmfa.api.GetIdentityRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 46, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr app_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fownmfa_5fapp_5fidentity_2eproto;
};// -------------------------------------------------------------------

class DeleteIdentityRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ownmfa.api.DeleteIdentityRequest) */ {
 public:
  inline DeleteIdentityRequest() : DeleteIdentityRequest(nullptr) {}
  ~DeleteIdentityRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteIdentityRequest(::google::protobuf::internal::ConstantInitialized);

  DeleteIdentityRequest(const DeleteIdentityRequest& from);
  DeleteIdentityRequest(DeleteIdentityRequest&& from) noexcept
    : DeleteIdentityRequest() {
    *this = ::std::move(from);
  }

  inline DeleteIdentityRequest& operator=(const DeleteIdentityRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteIdentityRequest& operator=(DeleteIdentityRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteIdentityRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteIdentityRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteIdentityRequest*>(
               &_DeleteIdentityRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(DeleteIdentityRequest& a, DeleteIdentityRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteIdentityRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteIdentityRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteIdentityRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteIdentityRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeleteIdentityRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DeleteIdentityRequest& from) {
    DeleteIdentityRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteIdentityRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ownmfa.api.DeleteIdentityRequest";
  }
  protected:
  explicit DeleteIdentityRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kAppIdFieldNumber = 2,
  };
  // string id = 1 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* ptr);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string app_id = 2 [json_name = "appID", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  void clear_app_id() ;
  const std::string& app_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_app_id(Arg_&& arg, Args_... args);
  std::string* mutable_app_id();
  PROTOBUF_NODISCARD std::string* release_app_id();
  void set_allocated_app_id(std::string* ptr);

  private:
  const std::string& _internal_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_id(
      const std::string& value);
  std::string* _internal_mutable_app_id();

  public:
  // @@protoc_insertion_point(class_scope:ownmfa.api.DeleteIdentityRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 49, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr app_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fownmfa_5fapp_5fidentity_2eproto;
};// -------------------------------------------------------------------

class ListIdentitiesRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ownmfa.api.ListIdentitiesRequest) */ {
 public:
  inline ListIdentitiesRequest() : ListIdentitiesRequest(nullptr) {}
  ~ListIdentitiesRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ListIdentitiesRequest(::google::protobuf::internal::ConstantInitialized);

  ListIdentitiesRequest(const ListIdentitiesRequest& from);
  ListIdentitiesRequest(ListIdentitiesRequest&& from) noexcept
    : ListIdentitiesRequest() {
    *this = ::std::move(from);
  }

  inline ListIdentitiesRequest& operator=(const ListIdentitiesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListIdentitiesRequest& operator=(ListIdentitiesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListIdentitiesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListIdentitiesRequest* internal_default_instance() {
    return reinterpret_cast<const ListIdentitiesRequest*>(
               &_ListIdentitiesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(ListIdentitiesRequest& a, ListIdentitiesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListIdentitiesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListIdentitiesRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListIdentitiesRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListIdentitiesRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListIdentitiesRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ListIdentitiesRequest& from) {
    ListIdentitiesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListIdentitiesRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ownmfa.api.ListIdentitiesRequest";
  }
  protected:
  explicit ListIdentitiesRequest(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPageTokenFieldNumber = 2,
    kAppIdFieldNumber = 3,
    kPageSizeFieldNumber = 1,
  };
  // string page_token = 2;
  void clear_page_token() ;
  const std::string& page_token() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_page_token(Arg_&& arg, Args_... args);
  std::string* mutable_page_token();
  PROTOBUF_NODISCARD std::string* release_page_token();
  void set_allocated_page_token(std::string* ptr);

  private:
  const std::string& _internal_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(
      const std::string& value);
  std::string* _internal_mutable_page_token();

  public:
  // string app_id = 3 [json_name = "appID", (.validate.rules) = {
  void clear_app_id() ;
  const std::string& app_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_app_id(Arg_&& arg, Args_... args);
  std::string* mutable_app_id();
  PROTOBUF_NODISCARD std::string* release_app_id();
  void set_allocated_app_id(std::string* ptr);

  private:
  const std::string& _internal_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_id(
      const std::string& value);
  std::string* _internal_mutable_app_id();

  public:
  // int32 page_size = 1 [(.validate.rules) = {
  void clear_page_size() ;
  ::int32_t page_size() const;
  void set_page_size(::int32_t value);

  private:
  ::int32_t _internal_page_size() const;
  void _internal_set_page_size(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:ownmfa.api.ListIdentitiesRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 0, 57, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::ArenaStringPtr page_token_;
    ::google::protobuf::internal::ArenaStringPtr app_id_;
    ::int32_t page_size_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fownmfa_5fapp_5fidentity_2eproto;
};// -------------------------------------------------------------------

class ListIdentitiesResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ownmfa.api.ListIdentitiesResponse) */ {
 public:
  inline ListIdentitiesResponse() : ListIdentitiesResponse(nullptr) {}
  ~ListIdentitiesResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ListIdentitiesResponse(::google::protobuf::internal::ConstantInitialized);

  ListIdentitiesResponse(const ListIdentitiesResponse& from);
  ListIdentitiesResponse(ListIdentitiesResponse&& from) noexcept
    : ListIdentitiesResponse() {
    *this = ::std::move(from);
  }

  inline ListIdentitiesResponse& operator=(const ListIdentitiesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListIdentitiesResponse& operator=(ListIdentitiesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListIdentitiesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListIdentitiesResponse* internal_default_instance() {
    return reinterpret_cast<const ListIdentitiesResponse*>(
               &_ListIdentitiesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(ListIdentitiesResponse& a, ListIdentitiesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListIdentitiesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListIdentitiesResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListIdentitiesResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListIdentitiesResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListIdentitiesResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ListIdentitiesResponse& from) {
    ListIdentitiesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListIdentitiesResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ownmfa.api.ListIdentitiesResponse";
  }
  protected:
  explicit ListIdentitiesResponse(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdentitiesFieldNumber = 1,
    kNextPageTokenFieldNumber = 2,
    kTotalSizeFieldNumber = 3,
  };
  // repeated .ownmfa.api.Identity identities = 1;
  int identities_size() const;
  private:
  int _internal_identities_size() const;

  public:
  void clear_identities() ;
  ::ownmfa::api::Identity* mutable_identities(int index);
  ::google::protobuf::RepeatedPtrField< ::ownmfa::api::Identity >*
      mutable_identities();
  private:
  const ::google::protobuf::RepeatedPtrField<::ownmfa::api::Identity>& _internal_identities() const;
  ::google::protobuf::RepeatedPtrField<::ownmfa::api::Identity>* _internal_mutable_identities();
  public:
  const ::ownmfa::api::Identity& identities(int index) const;
  ::ownmfa::api::Identity* add_identities();
  const ::google::protobuf::RepeatedPtrField< ::ownmfa::api::Identity >&
      identities() const;
  // string next_page_token = 2;
  void clear_next_page_token() ;
  const std::string& next_page_token() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_next_page_token(Arg_&& arg, Args_... args);
  std::string* mutable_next_page_token();
  PROTOBUF_NODISCARD std::string* release_next_page_token();
  void set_allocated_next_page_token(std::string* ptr);

  private:
  const std::string& _internal_next_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_page_token(
      const std::string& value);
  std::string* _internal_mutable_next_page_token();

  public:
  // int32 total_size = 3;
  void clear_total_size() ;
  ::int32_t total_size() const;
  void set_total_size(::int32_t value);

  private:
  ::int32_t _internal_total_size() const;
  void _internal_set_total_size(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:ownmfa.api.ListIdentitiesResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 1, 57, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::ownmfa::api::Identity > identities_;
    ::google::protobuf::internal::ArenaStringPtr next_page_token_;
    ::int32_t total_size_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fownmfa_5fapp_5fidentity_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// App

// string id = 1 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline void App::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& App::id() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.App.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void App::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ownmfa.api.App.id)
}
inline std::string* App::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.App.id)
  return _s;
}
inline const std::string& App::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void App::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* App::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* App::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ownmfa.api.App.id)
  return _impl_.id_.Release();
}
inline void App::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.App.id)
}

// string org_id = 2 [json_name = "orgID", (.google.api.field_behavior) = OUTPUT_ONLY];
inline void App::clear_org_id() {
  _impl_.org_id_.ClearToEmpty();
}
inline const std::string& App::org_id() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.App.org_id)
  return _internal_org_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void App::set_org_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.org_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ownmfa.api.App.org_id)
}
inline std::string* App::mutable_org_id() {
  std::string* _s = _internal_mutable_org_id();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.App.org_id)
  return _s;
}
inline const std::string& App::_internal_org_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.org_id_.Get();
}
inline void App::_internal_set_org_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.org_id_.Set(value, GetArenaForAllocation());
}
inline std::string* App::_internal_mutable_org_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.org_id_.Mutable( GetArenaForAllocation());
}
inline std::string* App::release_org_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ownmfa.api.App.org_id)
  return _impl_.org_id_.Release();
}
inline void App::set_allocated_org_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.org_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.org_id_.IsDefault()) {
          _impl_.org_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.App.org_id)
}

// string name = 3 [(.validate.rules) = {
inline void App::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& App::name() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.App.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void App::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ownmfa.api.App.name)
}
inline std::string* App::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.App.name)
  return _s;
}
inline const std::string& App::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void App::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* App::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArenaForAllocation());
}
inline std::string* App::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ownmfa.api.App.name)
  return _impl_.name_.Release();
}
inline void App::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.App.name)
}

// string display_name = 4 [(.validate.rules) = {
inline void App::clear_display_name() {
  _impl_.display_name_.ClearToEmpty();
}
inline const std::string& App::display_name() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.App.display_name)
  return _internal_display_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void App::set_display_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.display_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ownmfa.api.App.display_name)
}
inline std::string* App::mutable_display_name() {
  std::string* _s = _internal_mutable_display_name();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.App.display_name)
  return _s;
}
inline const std::string& App::_internal_display_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.display_name_.Get();
}
inline void App::_internal_set_display_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.display_name_.Set(value, GetArenaForAllocation());
}
inline std::string* App::_internal_mutable_display_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.display_name_.Mutable( GetArenaForAllocation());
}
inline std::string* App::release_display_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ownmfa.api.App.display_name)
  return _impl_.display_name_.Release();
}
inline void App::set_allocated_display_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.display_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.display_name_.IsDefault()) {
          _impl_.display_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.App.display_name)
}

// string email = 5 [(.validate.rules) = {
inline void App::clear_email() {
  _impl_.email_.ClearToEmpty();
}
inline const std::string& App::email() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.App.email)
  return _internal_email();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void App::set_email(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.email_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ownmfa.api.App.email)
}
inline std::string* App::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.App.email)
  return _s;
}
inline const std::string& App::_internal_email() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.email_.Get();
}
inline void App::_internal_set_email(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.email_.Set(value, GetArenaForAllocation());
}
inline std::string* App::_internal_mutable_email() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.email_.Mutable( GetArenaForAllocation());
}
inline std::string* App::release_email() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ownmfa.api.App.email)
  return _impl_.email_.Release();
}
inline void App::set_allocated_email(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.email_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.email_.IsDefault()) {
          _impl_.email_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.App.email)
}

// string pushover_key = 6 [(.validate.rules) = {
inline void App::clear_pushover_key() {
  _impl_.pushover_key_.ClearToEmpty();
}
inline const std::string& App::pushover_key() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.App.pushover_key)
  return _internal_pushover_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void App::set_pushover_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.pushover_key_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ownmfa.api.App.pushover_key)
}
inline std::string* App::mutable_pushover_key() {
  std::string* _s = _internal_mutable_pushover_key();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.App.pushover_key)
  return _s;
}
inline const std::string& App::_internal_pushover_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pushover_key_.Get();
}
inline void App::_internal_set_pushover_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.pushover_key_.Set(value, GetArenaForAllocation());
}
inline std::string* App::_internal_mutable_pushover_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.pushover_key_.Mutable( GetArenaForAllocation());
}
inline std::string* App::release_pushover_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ownmfa.api.App.pushover_key)
  return _impl_.pushover_key_.Release();
}
inline void App::set_allocated_pushover_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pushover_key_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.pushover_key_.IsDefault()) {
          _impl_.pushover_key_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.App.pushover_key)
}

// string subject_template = 7 [(.validate.rules) = {
inline void App::clear_subject_template() {
  _impl_.subject_template_.ClearToEmpty();
}
inline const std::string& App::subject_template() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.App.subject_template)
  return _internal_subject_template();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void App::set_subject_template(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.subject_template_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ownmfa.api.App.subject_template)
}
inline std::string* App::mutable_subject_template() {
  std::string* _s = _internal_mutable_subject_template();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.App.subject_template)
  return _s;
}
inline const std::string& App::_internal_subject_template() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.subject_template_.Get();
}
inline void App::_internal_set_subject_template(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.subject_template_.Set(value, GetArenaForAllocation());
}
inline std::string* App::_internal_mutable_subject_template() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.subject_template_.Mutable( GetArenaForAllocation());
}
inline std::string* App::release_subject_template() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ownmfa.api.App.subject_template)
  return _impl_.subject_template_.Release();
}
inline void App::set_allocated_subject_template(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.subject_template_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.subject_template_.IsDefault()) {
          _impl_.subject_template_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.App.subject_template)
}

// string text_body_template = 8 [(.validate.rules) = {
inline void App::clear_text_body_template() {
  _impl_.text_body_template_.ClearToEmpty();
}
inline const std::string& App::text_body_template() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.App.text_body_template)
  return _internal_text_body_template();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void App::set_text_body_template(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.text_body_template_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ownmfa.api.App.text_body_template)
}
inline std::string* App::mutable_text_body_template() {
  std::string* _s = _internal_mutable_text_body_template();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.App.text_body_template)
  return _s;
}
inline const std::string& App::_internal_text_body_template() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.text_body_template_.Get();
}
inline void App::_internal_set_text_body_template(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.text_body_template_.Set(value, GetArenaForAllocation());
}
inline std::string* App::_internal_mutable_text_body_template() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.text_body_template_.Mutable( GetArenaForAllocation());
}
inline std::string* App::release_text_body_template() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ownmfa.api.App.text_body_template)
  return _impl_.text_body_template_.Release();
}
inline void App::set_allocated_text_body_template(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.text_body_template_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.text_body_template_.IsDefault()) {
          _impl_.text_body_template_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.App.text_body_template)
}

// bytes html_body_template = 9 [(.validate.rules) = {
inline void App::clear_html_body_template() {
  _impl_.html_body_template_.ClearToEmpty();
}
inline const std::string& App::html_body_template() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.App.html_body_template)
  return _internal_html_body_template();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void App::set_html_body_template(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.html_body_template_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ownmfa.api.App.html_body_template)
}
inline std::string* App::mutable_html_body_template() {
  std::string* _s = _internal_mutable_html_body_template();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.App.html_body_template)
  return _s;
}
inline const std::string& App::_internal_html_body_template() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.html_body_template_.Get();
}
inline void App::_internal_set_html_body_template(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.html_body_template_.Set(value, GetArenaForAllocation());
}
inline std::string* App::_internal_mutable_html_body_template() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.html_body_template_.Mutable( GetArenaForAllocation());
}
inline std::string* App::release_html_body_template() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ownmfa.api.App.html_body_template)
  return _impl_.html_body_template_.Release();
}
inline void App::set_allocated_html_body_template(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.html_body_template_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.html_body_template_.IsDefault()) {
          _impl_.html_body_template_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.App.html_body_template)
}

// .google.protobuf.Timestamp created_at = 10 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline bool App::has_created_at() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.created_at_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& App::_internal_created_at() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& App::created_at() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.App.created_at)
  return _internal_created_at();
}
inline void App::unsafe_arena_set_allocated_created_at(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ownmfa.api.App.created_at)
}
inline ::google::protobuf::Timestamp* App::release_created_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* App::unsafe_arena_release_created_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ownmfa.api.App.created_at)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* App::_internal_mutable_created_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaForAllocation());
    _impl_.created_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.created_at_;
}
inline ::google::protobuf::Timestamp* App::mutable_created_at() {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.App.created_at)
  return _msg;
}
inline void App::set_allocated_created_at(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.created_at_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.created_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.App.created_at)
}

// .google.protobuf.Timestamp updated_at = 11 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline bool App::has_updated_at() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.updated_at_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& App::_internal_updated_at() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.updated_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& App::updated_at() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.App.updated_at)
  return _internal_updated_at();
}
inline void App::unsafe_arena_set_allocated_updated_at(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.updated_at_);
  }
  _impl_.updated_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ownmfa.api.App.updated_at)
}
inline ::google::protobuf::Timestamp* App::release_updated_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* released = _impl_.updated_at_;
  _impl_.updated_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* App::unsafe_arena_release_updated_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ownmfa.api.App.updated_at)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* temp = _impl_.updated_at_;
  _impl_.updated_at_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* App::_internal_mutable_updated_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.updated_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaForAllocation());
    _impl_.updated_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.updated_at_;
}
inline ::google::protobuf::Timestamp* App::mutable_updated_at() {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_updated_at();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.App.updated_at)
  return _msg;
}
inline void App::set_allocated_updated_at(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.updated_at_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.updated_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.App.updated_at)
}

// -------------------------------------------------------------------

// CreateAppRequest

// .ownmfa.api.App app = 1 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline bool CreateAppRequest::has_app() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.app_ != nullptr);
  return value;
}
inline void CreateAppRequest::clear_app() {
  if (_impl_.app_ != nullptr) _impl_.app_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::ownmfa::api::App& CreateAppRequest::_internal_app() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::ownmfa::api::App* p = _impl_.app_;
  return p != nullptr ? *p : reinterpret_cast<const ::ownmfa::api::App&>(::ownmfa::api::_App_default_instance_);
}
inline const ::ownmfa::api::App& CreateAppRequest::app() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.CreateAppRequest.app)
  return _internal_app();
}
inline void CreateAppRequest::unsafe_arena_set_allocated_app(::ownmfa::api::App* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.app_);
  }
  _impl_.app_ = reinterpret_cast<::ownmfa::api::App*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ownmfa.api.CreateAppRequest.app)
}
inline ::ownmfa::api::App* CreateAppRequest::release_app() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ownmfa::api::App* released = _impl_.app_;
  _impl_.app_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::ownmfa::api::App* CreateAppRequest::unsafe_arena_release_app() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ownmfa.api.CreateAppRequest.app)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ownmfa::api::App* temp = _impl_.app_;
  _impl_.app_ = nullptr;
  return temp;
}
inline ::ownmfa::api::App* CreateAppRequest::_internal_mutable_app() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.app_ == nullptr) {
    auto* p = CreateMaybeMessage<::ownmfa::api::App>(GetArenaForAllocation());
    _impl_.app_ = reinterpret_cast<::ownmfa::api::App*>(p);
  }
  return _impl_.app_;
}
inline ::ownmfa::api::App* CreateAppRequest::mutable_app() {
  ::ownmfa::api::App* _msg = _internal_mutable_app();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.CreateAppRequest.app)
  return _msg;
}
inline void CreateAppRequest::set_allocated_app(::ownmfa::api::App* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::ownmfa::api::App*>(_impl_.app_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::ownmfa::api::App*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.app_ = reinterpret_cast<::ownmfa::api::App*>(value);
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.CreateAppRequest.app)
}

// -------------------------------------------------------------------

// GetAppRequest

// string id = 1 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline void GetAppRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& GetAppRequest::id() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.GetAppRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetAppRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ownmfa.api.GetAppRequest.id)
}
inline std::string* GetAppRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.GetAppRequest.id)
  return _s;
}
inline const std::string& GetAppRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void GetAppRequest::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetAppRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* GetAppRequest::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ownmfa.api.GetAppRequest.id)
  return _impl_.id_.Release();
}
inline void GetAppRequest::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.GetAppRequest.id)
}

// -------------------------------------------------------------------

// UpdateAppRequest

// .ownmfa.api.App app = 1 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline bool UpdateAppRequest::has_app() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.app_ != nullptr);
  return value;
}
inline void UpdateAppRequest::clear_app() {
  if (_impl_.app_ != nullptr) _impl_.app_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::ownmfa::api::App& UpdateAppRequest::_internal_app() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::ownmfa::api::App* p = _impl_.app_;
  return p != nullptr ? *p : reinterpret_cast<const ::ownmfa::api::App&>(::ownmfa::api::_App_default_instance_);
}
inline const ::ownmfa::api::App& UpdateAppRequest::app() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.UpdateAppRequest.app)
  return _internal_app();
}
inline void UpdateAppRequest::unsafe_arena_set_allocated_app(::ownmfa::api::App* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.app_);
  }
  _impl_.app_ = reinterpret_cast<::ownmfa::api::App*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ownmfa.api.UpdateAppRequest.app)
}
inline ::ownmfa::api::App* UpdateAppRequest::release_app() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ownmfa::api::App* released = _impl_.app_;
  _impl_.app_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::ownmfa::api::App* UpdateAppRequest::unsafe_arena_release_app() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ownmfa.api.UpdateAppRequest.app)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ownmfa::api::App* temp = _impl_.app_;
  _impl_.app_ = nullptr;
  return temp;
}
inline ::ownmfa::api::App* UpdateAppRequest::_internal_mutable_app() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.app_ == nullptr) {
    auto* p = CreateMaybeMessage<::ownmfa::api::App>(GetArenaForAllocation());
    _impl_.app_ = reinterpret_cast<::ownmfa::api::App*>(p);
  }
  return _impl_.app_;
}
inline ::ownmfa::api::App* UpdateAppRequest::mutable_app() {
  ::ownmfa::api::App* _msg = _internal_mutable_app();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.UpdateAppRequest.app)
  return _msg;
}
inline void UpdateAppRequest::set_allocated_app(::ownmfa::api::App* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::ownmfa::api::App*>(_impl_.app_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::ownmfa::api::App*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.app_ = reinterpret_cast<::ownmfa::api::App*>(value);
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.UpdateAppRequest.app)
}

// .google.protobuf.FieldMask update_mask = 2;
inline bool UpdateAppRequest::has_update_mask() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.update_mask_ != nullptr);
  return value;
}
inline const ::google::protobuf::FieldMask& UpdateAppRequest::_internal_update_mask() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::FieldMask* p = _impl_.update_mask_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::FieldMask&>(::google::protobuf::_FieldMask_default_instance_);
}
inline const ::google::protobuf::FieldMask& UpdateAppRequest::update_mask() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.UpdateAppRequest.update_mask)
  return _internal_update_mask();
}
inline void UpdateAppRequest::unsafe_arena_set_allocated_update_mask(::google::protobuf::FieldMask* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.update_mask_);
  }
  _impl_.update_mask_ = reinterpret_cast<::google::protobuf::FieldMask*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ownmfa.api.UpdateAppRequest.update_mask)
}
inline ::google::protobuf::FieldMask* UpdateAppRequest::release_update_mask() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::FieldMask* released = _impl_.update_mask_;
  _impl_.update_mask_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::FieldMask* UpdateAppRequest::unsafe_arena_release_update_mask() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ownmfa.api.UpdateAppRequest.update_mask)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::FieldMask* temp = _impl_.update_mask_;
  _impl_.update_mask_ = nullptr;
  return temp;
}
inline ::google::protobuf::FieldMask* UpdateAppRequest::_internal_mutable_update_mask() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.update_mask_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::FieldMask>(GetArenaForAllocation());
    _impl_.update_mask_ = reinterpret_cast<::google::protobuf::FieldMask*>(p);
  }
  return _impl_.update_mask_;
}
inline ::google::protobuf::FieldMask* UpdateAppRequest::mutable_update_mask() {
  ::google::protobuf::FieldMask* _msg = _internal_mutable_update_mask();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.UpdateAppRequest.update_mask)
  return _msg;
}
inline void UpdateAppRequest::set_allocated_update_mask(::google::protobuf::FieldMask* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.update_mask_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.update_mask_ = reinterpret_cast<::google::protobuf::FieldMask*>(value);
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.UpdateAppRequest.update_mask)
}

// -------------------------------------------------------------------

// DeleteAppRequest

// string id = 1 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline void DeleteAppRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& DeleteAppRequest::id() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.DeleteAppRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DeleteAppRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ownmfa.api.DeleteAppRequest.id)
}
inline std::string* DeleteAppRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.DeleteAppRequest.id)
  return _s;
}
inline const std::string& DeleteAppRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void DeleteAppRequest::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteAppRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* DeleteAppRequest::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ownmfa.api.DeleteAppRequest.id)
  return _impl_.id_.Release();
}
inline void DeleteAppRequest::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.DeleteAppRequest.id)
}

// -------------------------------------------------------------------

// ListAppsRequest

// int32 page_size = 1 [(.validate.rules) = {
inline void ListAppsRequest::clear_page_size() {
  _impl_.page_size_ = 0;
}
inline ::int32_t ListAppsRequest::page_size() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.ListAppsRequest.page_size)
  return _internal_page_size();
}
inline void ListAppsRequest::set_page_size(::int32_t value) {
  _internal_set_page_size(value);
  // @@protoc_insertion_point(field_set:ownmfa.api.ListAppsRequest.page_size)
}
inline ::int32_t ListAppsRequest::_internal_page_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.page_size_;
}
inline void ListAppsRequest::_internal_set_page_size(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.page_size_ = value;
}

// string page_token = 2;
inline void ListAppsRequest::clear_page_token() {
  _impl_.page_token_.ClearToEmpty();
}
inline const std::string& ListAppsRequest::page_token() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.ListAppsRequest.page_token)
  return _internal_page_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ListAppsRequest::set_page_token(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.page_token_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ownmfa.api.ListAppsRequest.page_token)
}
inline std::string* ListAppsRequest::mutable_page_token() {
  std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.ListAppsRequest.page_token)
  return _s;
}
inline const std::string& ListAppsRequest::_internal_page_token() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.page_token_.Get();
}
inline void ListAppsRequest::_internal_set_page_token(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListAppsRequest::_internal_mutable_page_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.page_token_.Mutable( GetArenaForAllocation());
}
inline std::string* ListAppsRequest::release_page_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ownmfa.api.ListAppsRequest.page_token)
  return _impl_.page_token_.Release();
}
inline void ListAppsRequest::set_allocated_page_token(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.page_token_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.page_token_.IsDefault()) {
          _impl_.page_token_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.ListAppsRequest.page_token)
}

// -------------------------------------------------------------------

// ListAppsResponse

// repeated .ownmfa.api.App apps = 1;
inline int ListAppsResponse::_internal_apps_size() const {
  return _internal_apps().size();
}
inline int ListAppsResponse::apps_size() const {
  return _internal_apps_size();
}
inline void ListAppsResponse::clear_apps() {
  _internal_mutable_apps()->Clear();
}
inline ::ownmfa::api::App* ListAppsResponse::mutable_apps(int index) {
  // @@protoc_insertion_point(field_mutable:ownmfa.api.ListAppsResponse.apps)
  return _internal_mutable_apps()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ownmfa::api::App >*
ListAppsResponse::mutable_apps() {
  // @@protoc_insertion_point(field_mutable_list:ownmfa.api.ListAppsResponse.apps)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_apps();
}
inline const ::ownmfa::api::App& ListAppsResponse::apps(int index) const {
  // @@protoc_insertion_point(field_get:ownmfa.api.ListAppsResponse.apps)
    return _internal_apps().Get(index);
}
inline ::ownmfa::api::App* ListAppsResponse::add_apps() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::ownmfa::api::App* _add = _internal_mutable_apps()->Add();
  // @@protoc_insertion_point(field_add:ownmfa.api.ListAppsResponse.apps)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::ownmfa::api::App >&
ListAppsResponse::apps() const {
  // @@protoc_insertion_point(field_list:ownmfa.api.ListAppsResponse.apps)
  return _internal_apps();
}
inline const ::google::protobuf::RepeatedPtrField<::ownmfa::api::App>&
ListAppsResponse::_internal_apps() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.apps_;
}
inline ::google::protobuf::RepeatedPtrField<::ownmfa::api::App>*
ListAppsResponse::_internal_mutable_apps() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.apps_;
}

// string next_page_token = 2;
inline void ListAppsResponse::clear_next_page_token() {
  _impl_.next_page_token_.ClearToEmpty();
}
inline const std::string& ListAppsResponse::next_page_token() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.ListAppsResponse.next_page_token)
  return _internal_next_page_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ListAppsResponse::set_next_page_token(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.next_page_token_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ownmfa.api.ListAppsResponse.next_page_token)
}
inline std::string* ListAppsResponse::mutable_next_page_token() {
  std::string* _s = _internal_mutable_next_page_token();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.ListAppsResponse.next_page_token)
  return _s;
}
inline const std::string& ListAppsResponse::_internal_next_page_token() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.next_page_token_.Get();
}
inline void ListAppsResponse::_internal_set_next_page_token(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.next_page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListAppsResponse::_internal_mutable_next_page_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.next_page_token_.Mutable( GetArenaForAllocation());
}
inline std::string* ListAppsResponse::release_next_page_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ownmfa.api.ListAppsResponse.next_page_token)
  return _impl_.next_page_token_.Release();
}
inline void ListAppsResponse::set_allocated_next_page_token(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.next_page_token_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.next_page_token_.IsDefault()) {
          _impl_.next_page_token_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.ListAppsResponse.next_page_token)
}

// int32 total_size = 3;
inline void ListAppsResponse::clear_total_size() {
  _impl_.total_size_ = 0;
}
inline ::int32_t ListAppsResponse::total_size() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.ListAppsResponse.total_size)
  return _internal_total_size();
}
inline void ListAppsResponse::set_total_size(::int32_t value) {
  _internal_set_total_size(value);
  // @@protoc_insertion_point(field_set:ownmfa.api.ListAppsResponse.total_size)
}
inline ::int32_t ListAppsResponse::_internal_total_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.total_size_;
}
inline void ListAppsResponse::_internal_set_total_size(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.total_size_ = value;
}

// -------------------------------------------------------------------

// SoftwareHOTPMethod

// .ownmfa.api.Hash hash = 1;
inline void SoftwareHOTPMethod::clear_hash() {
  _impl_.hash_ = 0;
}
inline ::ownmfa::api::Hash SoftwareHOTPMethod::hash() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.SoftwareHOTPMethod.hash)
  return _internal_hash();
}
inline void SoftwareHOTPMethod::set_hash(::ownmfa::api::Hash value) {
  _internal_set_hash(value);
  // @@protoc_insertion_point(field_set:ownmfa.api.SoftwareHOTPMethod.hash)
}
inline ::ownmfa::api::Hash SoftwareHOTPMethod::_internal_hash() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::ownmfa::api::Hash>(_impl_.hash_);
}
inline void SoftwareHOTPMethod::_internal_set_hash(::ownmfa::api::Hash value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.hash_ = value;
}

// int32 digits = 2 [(.validate.rules) = {
inline void SoftwareHOTPMethod::clear_digits() {
  _impl_.digits_ = 0;
}
inline ::int32_t SoftwareHOTPMethod::digits() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.SoftwareHOTPMethod.digits)
  return _internal_digits();
}
inline void SoftwareHOTPMethod::set_digits(::int32_t value) {
  _internal_set_digits(value);
  // @@protoc_insertion_point(field_set:ownmfa.api.SoftwareHOTPMethod.digits)
}
inline ::int32_t SoftwareHOTPMethod::_internal_digits() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.digits_;
}
inline void SoftwareHOTPMethod::_internal_set_digits(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.digits_ = value;
}

// int32 counter = 3;
inline void SoftwareHOTPMethod::clear_counter() {
  _impl_.counter_ = 0;
}
inline ::int32_t SoftwareHOTPMethod::counter() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.SoftwareHOTPMethod.counter)
  return _internal_counter();
}
inline void SoftwareHOTPMethod::set_counter(::int32_t value) {
  _internal_set_counter(value);
  // @@protoc_insertion_point(field_set:ownmfa.api.SoftwareHOTPMethod.counter)
}
inline ::int32_t SoftwareHOTPMethod::_internal_counter() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.counter_;
}
inline void SoftwareHOTPMethod::_internal_set_counter(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.counter_ = value;
}

// string account_name = 4 [(.validate.rules) = {
inline void SoftwareHOTPMethod::clear_account_name() {
  _impl_.account_name_.ClearToEmpty();
}
inline const std::string& SoftwareHOTPMethod::account_name() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.SoftwareHOTPMethod.account_name)
  return _internal_account_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SoftwareHOTPMethod::set_account_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.account_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ownmfa.api.SoftwareHOTPMethod.account_name)
}
inline std::string* SoftwareHOTPMethod::mutable_account_name() {
  std::string* _s = _internal_mutable_account_name();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.SoftwareHOTPMethod.account_name)
  return _s;
}
inline const std::string& SoftwareHOTPMethod::_internal_account_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.account_name_.Get();
}
inline void SoftwareHOTPMethod::_internal_set_account_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.account_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SoftwareHOTPMethod::_internal_mutable_account_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.account_name_.Mutable( GetArenaForAllocation());
}
inline std::string* SoftwareHOTPMethod::release_account_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ownmfa.api.SoftwareHOTPMethod.account_name)
  return _impl_.account_name_.Release();
}
inline void SoftwareHOTPMethod::set_allocated_account_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.account_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.account_name_.IsDefault()) {
          _impl_.account_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.SoftwareHOTPMethod.account_name)
}

// -------------------------------------------------------------------

// SoftwareTOTPMethod

// .ownmfa.api.Hash hash = 1;
inline void SoftwareTOTPMethod::clear_hash() {
  _impl_.hash_ = 0;
}
inline ::ownmfa::api::Hash SoftwareTOTPMethod::hash() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.SoftwareTOTPMethod.hash)
  return _internal_hash();
}
inline void SoftwareTOTPMethod::set_hash(::ownmfa::api::Hash value) {
  _internal_set_hash(value);
  // @@protoc_insertion_point(field_set:ownmfa.api.SoftwareTOTPMethod.hash)
}
inline ::ownmfa::api::Hash SoftwareTOTPMethod::_internal_hash() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::ownmfa::api::Hash>(_impl_.hash_);
}
inline void SoftwareTOTPMethod::_internal_set_hash(::ownmfa::api::Hash value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.hash_ = value;
}

// int32 digits = 2 [(.validate.rules) = {
inline void SoftwareTOTPMethod::clear_digits() {
  _impl_.digits_ = 0;
}
inline ::int32_t SoftwareTOTPMethod::digits() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.SoftwareTOTPMethod.digits)
  return _internal_digits();
}
inline void SoftwareTOTPMethod::set_digits(::int32_t value) {
  _internal_set_digits(value);
  // @@protoc_insertion_point(field_set:ownmfa.api.SoftwareTOTPMethod.digits)
}
inline ::int32_t SoftwareTOTPMethod::_internal_digits() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.digits_;
}
inline void SoftwareTOTPMethod::_internal_set_digits(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.digits_ = value;
}

// string account_name = 3 [(.validate.rules) = {
inline void SoftwareTOTPMethod::clear_account_name() {
  _impl_.account_name_.ClearToEmpty();
}
inline const std::string& SoftwareTOTPMethod::account_name() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.SoftwareTOTPMethod.account_name)
  return _internal_account_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SoftwareTOTPMethod::set_account_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.account_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ownmfa.api.SoftwareTOTPMethod.account_name)
}
inline std::string* SoftwareTOTPMethod::mutable_account_name() {
  std::string* _s = _internal_mutable_account_name();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.SoftwareTOTPMethod.account_name)
  return _s;
}
inline const std::string& SoftwareTOTPMethod::_internal_account_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.account_name_.Get();
}
inline void SoftwareTOTPMethod::_internal_set_account_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.account_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SoftwareTOTPMethod::_internal_mutable_account_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.account_name_.Mutable( GetArenaForAllocation());
}
inline std::string* SoftwareTOTPMethod::release_account_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ownmfa.api.SoftwareTOTPMethod.account_name)
  return _impl_.account_name_.Release();
}
inline void SoftwareTOTPMethod::set_allocated_account_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.account_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.account_name_.IsDefault()) {
          _impl_.account_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.SoftwareTOTPMethod.account_name)
}

// -------------------------------------------------------------------

// GoogleAuthHOTPMethod

// string account_name = 1 [(.validate.rules) = {
inline void GoogleAuthHOTPMethod::clear_account_name() {
  _impl_.account_name_.ClearToEmpty();
}
inline const std::string& GoogleAuthHOTPMethod::account_name() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.GoogleAuthHOTPMethod.account_name)
  return _internal_account_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GoogleAuthHOTPMethod::set_account_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.account_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ownmfa.api.GoogleAuthHOTPMethod.account_name)
}
inline std::string* GoogleAuthHOTPMethod::mutable_account_name() {
  std::string* _s = _internal_mutable_account_name();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.GoogleAuthHOTPMethod.account_name)
  return _s;
}
inline const std::string& GoogleAuthHOTPMethod::_internal_account_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.account_name_.Get();
}
inline void GoogleAuthHOTPMethod::_internal_set_account_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.account_name_.Set(value, GetArenaForAllocation());
}
inline std::string* GoogleAuthHOTPMethod::_internal_mutable_account_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.account_name_.Mutable( GetArenaForAllocation());
}
inline std::string* GoogleAuthHOTPMethod::release_account_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ownmfa.api.GoogleAuthHOTPMethod.account_name)
  return _impl_.account_name_.Release();
}
inline void GoogleAuthHOTPMethod::set_allocated_account_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.account_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.account_name_.IsDefault()) {
          _impl_.account_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.GoogleAuthHOTPMethod.account_name)
}

// -------------------------------------------------------------------

// GoogleAuthTOTPMethod

// string account_name = 1 [(.validate.rules) = {
inline void GoogleAuthTOTPMethod::clear_account_name() {
  _impl_.account_name_.ClearToEmpty();
}
inline const std::string& GoogleAuthTOTPMethod::account_name() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.GoogleAuthTOTPMethod.account_name)
  return _internal_account_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GoogleAuthTOTPMethod::set_account_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.account_name_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ownmfa.api.GoogleAuthTOTPMethod.account_name)
}
inline std::string* GoogleAuthTOTPMethod::mutable_account_name() {
  std::string* _s = _internal_mutable_account_name();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.GoogleAuthTOTPMethod.account_name)
  return _s;
}
inline const std::string& GoogleAuthTOTPMethod::_internal_account_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.account_name_.Get();
}
inline void GoogleAuthTOTPMethod::_internal_set_account_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.account_name_.Set(value, GetArenaForAllocation());
}
inline std::string* GoogleAuthTOTPMethod::_internal_mutable_account_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.account_name_.Mutable( GetArenaForAllocation());
}
inline std::string* GoogleAuthTOTPMethod::release_account_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ownmfa.api.GoogleAuthTOTPMethod.account_name)
  return _impl_.account_name_.Release();
}
inline void GoogleAuthTOTPMethod::set_allocated_account_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.account_name_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.account_name_.IsDefault()) {
          _impl_.account_name_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.GoogleAuthTOTPMethod.account_name)
}

// -------------------------------------------------------------------

// AppleiOSTOTPMethod

// -------------------------------------------------------------------

// HardwareHOTPMethod

// .ownmfa.api.Hash hash = 1;
inline void HardwareHOTPMethod::clear_hash() {
  _impl_.hash_ = 0;
}
inline ::ownmfa::api::Hash HardwareHOTPMethod::hash() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.HardwareHOTPMethod.hash)
  return _internal_hash();
}
inline void HardwareHOTPMethod::set_hash(::ownmfa::api::Hash value) {
  _internal_set_hash(value);
  // @@protoc_insertion_point(field_set:ownmfa.api.HardwareHOTPMethod.hash)
}
inline ::ownmfa::api::Hash HardwareHOTPMethod::_internal_hash() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::ownmfa::api::Hash>(_impl_.hash_);
}
inline void HardwareHOTPMethod::_internal_set_hash(::ownmfa::api::Hash value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.hash_ = value;
}

// int32 digits = 2 [(.validate.rules) = {
inline void HardwareHOTPMethod::clear_digits() {
  _impl_.digits_ = 0;
}
inline ::int32_t HardwareHOTPMethod::digits() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.HardwareHOTPMethod.digits)
  return _internal_digits();
}
inline void HardwareHOTPMethod::set_digits(::int32_t value) {
  _internal_set_digits(value);
  // @@protoc_insertion_point(field_set:ownmfa.api.HardwareHOTPMethod.digits)
}
inline ::int32_t HardwareHOTPMethod::_internal_digits() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.digits_;
}
inline void HardwareHOTPMethod::_internal_set_digits(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.digits_ = value;
}

// int32 counter = 3;
inline void HardwareHOTPMethod::clear_counter() {
  _impl_.counter_ = 0;
}
inline ::int32_t HardwareHOTPMethod::counter() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.HardwareHOTPMethod.counter)
  return _internal_counter();
}
inline void HardwareHOTPMethod::set_counter(::int32_t value) {
  _internal_set_counter(value);
  // @@protoc_insertion_point(field_set:ownmfa.api.HardwareHOTPMethod.counter)
}
inline ::int32_t HardwareHOTPMethod::_internal_counter() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.counter_;
}
inline void HardwareHOTPMethod::_internal_set_counter(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.counter_ = value;
}

// bytes secret = 4 [(.validate.rules) = {
inline void HardwareHOTPMethod::clear_secret() {
  _impl_.secret_.ClearToEmpty();
}
inline const std::string& HardwareHOTPMethod::secret() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.HardwareHOTPMethod.secret)
  return _internal_secret();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HardwareHOTPMethod::set_secret(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.secret_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ownmfa.api.HardwareHOTPMethod.secret)
}
inline std::string* HardwareHOTPMethod::mutable_secret() {
  std::string* _s = _internal_mutable_secret();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.HardwareHOTPMethod.secret)
  return _s;
}
inline const std::string& HardwareHOTPMethod::_internal_secret() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.secret_.Get();
}
inline void HardwareHOTPMethod::_internal_set_secret(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.secret_.Set(value, GetArenaForAllocation());
}
inline std::string* HardwareHOTPMethod::_internal_mutable_secret() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.secret_.Mutable( GetArenaForAllocation());
}
inline std::string* HardwareHOTPMethod::release_secret() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ownmfa.api.HardwareHOTPMethod.secret)
  return _impl_.secret_.Release();
}
inline void HardwareHOTPMethod::set_allocated_secret(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.secret_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.secret_.IsDefault()) {
          _impl_.secret_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.HardwareHOTPMethod.secret)
}

// -------------------------------------------------------------------

// HardwareTOTPMethod

// .ownmfa.api.Hash hash = 1;
inline void HardwareTOTPMethod::clear_hash() {
  _impl_.hash_ = 0;
}
inline ::ownmfa::api::Hash HardwareTOTPMethod::hash() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.HardwareTOTPMethod.hash)
  return _internal_hash();
}
inline void HardwareTOTPMethod::set_hash(::ownmfa::api::Hash value) {
  _internal_set_hash(value);
  // @@protoc_insertion_point(field_set:ownmfa.api.HardwareTOTPMethod.hash)
}
inline ::ownmfa::api::Hash HardwareTOTPMethod::_internal_hash() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::ownmfa::api::Hash>(_impl_.hash_);
}
inline void HardwareTOTPMethod::_internal_set_hash(::ownmfa::api::Hash value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.hash_ = value;
}

// int32 digits = 2 [(.validate.rules) = {
inline void HardwareTOTPMethod::clear_digits() {
  _impl_.digits_ = 0;
}
inline ::int32_t HardwareTOTPMethod::digits() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.HardwareTOTPMethod.digits)
  return _internal_digits();
}
inline void HardwareTOTPMethod::set_digits(::int32_t value) {
  _internal_set_digits(value);
  // @@protoc_insertion_point(field_set:ownmfa.api.HardwareTOTPMethod.digits)
}
inline ::int32_t HardwareTOTPMethod::_internal_digits() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.digits_;
}
inline void HardwareTOTPMethod::_internal_set_digits(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.digits_ = value;
}

// bytes secret = 3 [(.validate.rules) = {
inline void HardwareTOTPMethod::clear_secret() {
  _impl_.secret_.ClearToEmpty();
}
inline const std::string& HardwareTOTPMethod::secret() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.HardwareTOTPMethod.secret)
  return _internal_secret();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HardwareTOTPMethod::set_secret(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.secret_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ownmfa.api.HardwareTOTPMethod.secret)
}
inline std::string* HardwareTOTPMethod::mutable_secret() {
  std::string* _s = _internal_mutable_secret();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.HardwareTOTPMethod.secret)
  return _s;
}
inline const std::string& HardwareTOTPMethod::_internal_secret() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.secret_.Get();
}
inline void HardwareTOTPMethod::_internal_set_secret(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.secret_.Set(value, GetArenaForAllocation());
}
inline std::string* HardwareTOTPMethod::_internal_mutable_secret() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.secret_.Mutable( GetArenaForAllocation());
}
inline std::string* HardwareTOTPMethod::release_secret() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ownmfa.api.HardwareTOTPMethod.secret)
  return _impl_.secret_.Release();
}
inline void HardwareTOTPMethod::set_allocated_secret(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.secret_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.secret_.IsDefault()) {
          _impl_.secret_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.HardwareTOTPMethod.secret)
}

// -------------------------------------------------------------------

// SMSMethod

// string phone = 1 [(.validate.rules) = {
inline void SMSMethod::clear_phone() {
  _impl_.phone_.ClearToEmpty();
}
inline const std::string& SMSMethod::phone() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.SMSMethod.phone)
  return _internal_phone();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SMSMethod::set_phone(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.phone_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ownmfa.api.SMSMethod.phone)
}
inline std::string* SMSMethod::mutable_phone() {
  std::string* _s = _internal_mutable_phone();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.SMSMethod.phone)
  return _s;
}
inline const std::string& SMSMethod::_internal_phone() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.phone_.Get();
}
inline void SMSMethod::_internal_set_phone(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.phone_.Set(value, GetArenaForAllocation());
}
inline std::string* SMSMethod::_internal_mutable_phone() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.phone_.Mutable( GetArenaForAllocation());
}
inline std::string* SMSMethod::release_phone() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ownmfa.api.SMSMethod.phone)
  return _impl_.phone_.Release();
}
inline void SMSMethod::set_allocated_phone(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.phone_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.phone_.IsDefault()) {
          _impl_.phone_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.SMSMethod.phone)
}

// -------------------------------------------------------------------

// PushoverMethod

// string pushover_key = 1 [(.validate.rules) = {
inline void PushoverMethod::clear_pushover_key() {
  _impl_.pushover_key_.ClearToEmpty();
}
inline const std::string& PushoverMethod::pushover_key() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.PushoverMethod.pushover_key)
  return _internal_pushover_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PushoverMethod::set_pushover_key(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.pushover_key_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ownmfa.api.PushoverMethod.pushover_key)
}
inline std::string* PushoverMethod::mutable_pushover_key() {
  std::string* _s = _internal_mutable_pushover_key();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.PushoverMethod.pushover_key)
  return _s;
}
inline const std::string& PushoverMethod::_internal_pushover_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pushover_key_.Get();
}
inline void PushoverMethod::_internal_set_pushover_key(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.pushover_key_.Set(value, GetArenaForAllocation());
}
inline std::string* PushoverMethod::_internal_mutable_pushover_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.pushover_key_.Mutable( GetArenaForAllocation());
}
inline std::string* PushoverMethod::release_pushover_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ownmfa.api.PushoverMethod.pushover_key)
  return _impl_.pushover_key_.Release();
}
inline void PushoverMethod::set_allocated_pushover_key(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pushover_key_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.pushover_key_.IsDefault()) {
          _impl_.pushover_key_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.PushoverMethod.pushover_key)
}

// -------------------------------------------------------------------

// EmailMethod

// string email = 1 [(.validate.rules) = {
inline void EmailMethod::clear_email() {
  _impl_.email_.ClearToEmpty();
}
inline const std::string& EmailMethod::email() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.EmailMethod.email)
  return _internal_email();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EmailMethod::set_email(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.email_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ownmfa.api.EmailMethod.email)
}
inline std::string* EmailMethod::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.EmailMethod.email)
  return _s;
}
inline const std::string& EmailMethod::_internal_email() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.email_.Get();
}
inline void EmailMethod::_internal_set_email(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.email_.Set(value, GetArenaForAllocation());
}
inline std::string* EmailMethod::_internal_mutable_email() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.email_.Mutable( GetArenaForAllocation());
}
inline std::string* EmailMethod::release_email() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ownmfa.api.EmailMethod.email)
  return _impl_.email_.Release();
}
inline void EmailMethod::set_allocated_email(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.email_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.email_.IsDefault()) {
          _impl_.email_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.EmailMethod.email)
}

// -------------------------------------------------------------------

// BackupsCodesMethod

// int32 passcodes = 1 [(.validate.rules) = {
inline void BackupsCodesMethod::clear_passcodes() {
  _impl_.passcodes_ = 0;
}
inline ::int32_t BackupsCodesMethod::passcodes() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.BackupsCodesMethod.passcodes)
  return _internal_passcodes();
}
inline void BackupsCodesMethod::set_passcodes(::int32_t value) {
  _internal_set_passcodes(value);
  // @@protoc_insertion_point(field_set:ownmfa.api.BackupsCodesMethod.passcodes)
}
inline ::int32_t BackupsCodesMethod::_internal_passcodes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.passcodes_;
}
inline void BackupsCodesMethod::_internal_set_passcodes(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.passcodes_ = value;
}

// -------------------------------------------------------------------

// SecurityQuestionsMethod

// string answer = 1 [(.validate.rules) = {
inline void SecurityQuestionsMethod::clear_answer() {
  _impl_.answer_.ClearToEmpty();
}
inline const std::string& SecurityQuestionsMethod::answer() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.SecurityQuestionsMethod.answer)
  return _internal_answer();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SecurityQuestionsMethod::set_answer(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.answer_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ownmfa.api.SecurityQuestionsMethod.answer)
}
inline std::string* SecurityQuestionsMethod::mutable_answer() {
  std::string* _s = _internal_mutable_answer();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.SecurityQuestionsMethod.answer)
  return _s;
}
inline const std::string& SecurityQuestionsMethod::_internal_answer() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.answer_.Get();
}
inline void SecurityQuestionsMethod::_internal_set_answer(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.answer_.Set(value, GetArenaForAllocation());
}
inline std::string* SecurityQuestionsMethod::_internal_mutable_answer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.answer_.Mutable( GetArenaForAllocation());
}
inline std::string* SecurityQuestionsMethod::release_answer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ownmfa.api.SecurityQuestionsMethod.answer)
  return _impl_.answer_.Release();
}
inline void SecurityQuestionsMethod::set_allocated_answer(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.answer_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.answer_.IsDefault()) {
          _impl_.answer_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.SecurityQuestionsMethod.answer)
}

// -------------------------------------------------------------------

// Identity

// string id = 1 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline void Identity::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Identity::id() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.Identity.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Identity::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ownmfa.api.Identity.id)
}
inline std::string* Identity::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.Identity.id)
  return _s;
}
inline const std::string& Identity::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void Identity::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* Identity::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* Identity::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ownmfa.api.Identity.id)
  return _impl_.id_.Release();
}
inline void Identity::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.Identity.id)
}

// string org_id = 2 [json_name = "orgID", (.google.api.field_behavior) = OUTPUT_ONLY];
inline void Identity::clear_org_id() {
  _impl_.org_id_.ClearToEmpty();
}
inline const std::string& Identity::org_id() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.Identity.org_id)
  return _internal_org_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Identity::set_org_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.org_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ownmfa.api.Identity.org_id)
}
inline std::string* Identity::mutable_org_id() {
  std::string* _s = _internal_mutable_org_id();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.Identity.org_id)
  return _s;
}
inline const std::string& Identity::_internal_org_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.org_id_.Get();
}
inline void Identity::_internal_set_org_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.org_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Identity::_internal_mutable_org_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.org_id_.Mutable( GetArenaForAllocation());
}
inline std::string* Identity::release_org_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ownmfa.api.Identity.org_id)
  return _impl_.org_id_.Release();
}
inline void Identity::set_allocated_org_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.org_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.org_id_.IsDefault()) {
          _impl_.org_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.Identity.org_id)
}

// string app_id = 3 [json_name = "appID", (.google.api.field_behavior) = OUTPUT_ONLY];
inline void Identity::clear_app_id() {
  _impl_.app_id_.ClearToEmpty();
}
inline const std::string& Identity::app_id() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.Identity.app_id)
  return _internal_app_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Identity::set_app_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.app_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ownmfa.api.Identity.app_id)
}
inline std::string* Identity::mutable_app_id() {
  std::string* _s = _internal_mutable_app_id();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.Identity.app_id)
  return _s;
}
inline const std::string& Identity::_internal_app_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.app_id_.Get();
}
inline void Identity::_internal_set_app_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.app_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Identity::_internal_mutable_app_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.app_id_.Mutable( GetArenaForAllocation());
}
inline std::string* Identity::release_app_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ownmfa.api.Identity.app_id)
  return _impl_.app_id_.Release();
}
inline void Identity::set_allocated_app_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.app_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.app_id_.IsDefault()) {
          _impl_.app_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.Identity.app_id)
}

// string comment = 4 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline void Identity::clear_comment() {
  _impl_.comment_.ClearToEmpty();
}
inline const std::string& Identity::comment() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.Identity.comment)
  return _internal_comment();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Identity::set_comment(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.comment_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ownmfa.api.Identity.comment)
}
inline std::string* Identity::mutable_comment() {
  std::string* _s = _internal_mutable_comment();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.Identity.comment)
  return _s;
}
inline const std::string& Identity::_internal_comment() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.comment_.Get();
}
inline void Identity::_internal_set_comment(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.comment_.Set(value, GetArenaForAllocation());
}
inline std::string* Identity::_internal_mutable_comment() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.comment_.Mutable( GetArenaForAllocation());
}
inline std::string* Identity::release_comment() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ownmfa.api.Identity.comment)
  return _impl_.comment_.Release();
}
inline void Identity::set_allocated_comment(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.comment_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.comment_.IsDefault()) {
          _impl_.comment_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.Identity.comment)
}

// .ownmfa.api.IdentityStatus status = 5 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline void Identity::clear_status() {
  _impl_.status_ = 0;
}
inline ::ownmfa::api::IdentityStatus Identity::status() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.Identity.status)
  return _internal_status();
}
inline void Identity::set_status(::ownmfa::api::IdentityStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:ownmfa.api.Identity.status)
}
inline ::ownmfa::api::IdentityStatus Identity::_internal_status() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::ownmfa::api::IdentityStatus>(_impl_.status_);
}
inline void Identity::_internal_set_status(::ownmfa::api::IdentityStatus value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.status_ = value;
}

// .ownmfa.api.SoftwareHOTPMethod software_hotp_method = 16 [json_name = "softwareHOTPMethod"];
inline bool Identity::has_software_hotp_method() const {
  return method_oneof_case() == kSoftwareHotpMethod;
}
inline bool Identity::_internal_has_software_hotp_method() const {
  return method_oneof_case() == kSoftwareHotpMethod;
}
inline void Identity::set_has_software_hotp_method() {
  _impl_._oneof_case_[0] = kSoftwareHotpMethod;
}
inline void Identity::clear_software_hotp_method() {
  if (method_oneof_case() == kSoftwareHotpMethod) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.method_oneof_.software_hotp_method_;
    }
    clear_has_method_oneof();
  }
}
inline ::ownmfa::api::SoftwareHOTPMethod* Identity::release_software_hotp_method() {
  // @@protoc_insertion_point(field_release:ownmfa.api.Identity.software_hotp_method)
  if (method_oneof_case() == kSoftwareHotpMethod) {
    clear_has_method_oneof();
    ::ownmfa::api::SoftwareHOTPMethod* temp = _impl_.method_oneof_.software_hotp_method_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.method_oneof_.software_hotp_method_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ownmfa::api::SoftwareHOTPMethod& Identity::_internal_software_hotp_method() const {
  return method_oneof_case() == kSoftwareHotpMethod
      ? *_impl_.method_oneof_.software_hotp_method_
      : reinterpret_cast<::ownmfa::api::SoftwareHOTPMethod&>(::ownmfa::api::_SoftwareHOTPMethod_default_instance_);
}
inline const ::ownmfa::api::SoftwareHOTPMethod& Identity::software_hotp_method() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.Identity.software_hotp_method)
  return _internal_software_hotp_method();
}
inline ::ownmfa::api::SoftwareHOTPMethod* Identity::unsafe_arena_release_software_hotp_method() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ownmfa.api.Identity.software_hotp_method)
  if (method_oneof_case() == kSoftwareHotpMethod) {
    clear_has_method_oneof();
    ::ownmfa::api::SoftwareHOTPMethod* temp = _impl_.method_oneof_.software_hotp_method_;
    _impl_.method_oneof_.software_hotp_method_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Identity::unsafe_arena_set_allocated_software_hotp_method(::ownmfa::api::SoftwareHOTPMethod* software_hotp_method) {
  clear_method_oneof();
  if (software_hotp_method) {
    set_has_software_hotp_method();
    _impl_.method_oneof_.software_hotp_method_ = software_hotp_method;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ownmfa.api.Identity.software_hotp_method)
}
inline ::ownmfa::api::SoftwareHOTPMethod* Identity::_internal_mutable_software_hotp_method() {
  if (method_oneof_case() != kSoftwareHotpMethod) {
    clear_method_oneof();
    set_has_software_hotp_method();
    _impl_.method_oneof_.software_hotp_method_ = CreateMaybeMessage< ::ownmfa::api::SoftwareHOTPMethod >(GetArenaForAllocation());
  }
  return _impl_.method_oneof_.software_hotp_method_;
}
inline ::ownmfa::api::SoftwareHOTPMethod* Identity::mutable_software_hotp_method() {
  ::ownmfa::api::SoftwareHOTPMethod* _msg = _internal_mutable_software_hotp_method();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.Identity.software_hotp_method)
  return _msg;
}

// .ownmfa.api.SoftwareTOTPMethod software_totp_method = 6 [json_name = "softwareTOTPMethod"];
inline bool Identity::has_software_totp_method() const {
  return method_oneof_case() == kSoftwareTotpMethod;
}
inline bool Identity::_internal_has_software_totp_method() const {
  return method_oneof_case() == kSoftwareTotpMethod;
}
inline void Identity::set_has_software_totp_method() {
  _impl_._oneof_case_[0] = kSoftwareTotpMethod;
}
inline void Identity::clear_software_totp_method() {
  if (method_oneof_case() == kSoftwareTotpMethod) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.method_oneof_.software_totp_method_;
    }
    clear_has_method_oneof();
  }
}
inline ::ownmfa::api::SoftwareTOTPMethod* Identity::release_software_totp_method() {
  // @@protoc_insertion_point(field_release:ownmfa.api.Identity.software_totp_method)
  if (method_oneof_case() == kSoftwareTotpMethod) {
    clear_has_method_oneof();
    ::ownmfa::api::SoftwareTOTPMethod* temp = _impl_.method_oneof_.software_totp_method_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.method_oneof_.software_totp_method_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ownmfa::api::SoftwareTOTPMethod& Identity::_internal_software_totp_method() const {
  return method_oneof_case() == kSoftwareTotpMethod
      ? *_impl_.method_oneof_.software_totp_method_
      : reinterpret_cast<::ownmfa::api::SoftwareTOTPMethod&>(::ownmfa::api::_SoftwareTOTPMethod_default_instance_);
}
inline const ::ownmfa::api::SoftwareTOTPMethod& Identity::software_totp_method() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.Identity.software_totp_method)
  return _internal_software_totp_method();
}
inline ::ownmfa::api::SoftwareTOTPMethod* Identity::unsafe_arena_release_software_totp_method() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ownmfa.api.Identity.software_totp_method)
  if (method_oneof_case() == kSoftwareTotpMethod) {
    clear_has_method_oneof();
    ::ownmfa::api::SoftwareTOTPMethod* temp = _impl_.method_oneof_.software_totp_method_;
    _impl_.method_oneof_.software_totp_method_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Identity::unsafe_arena_set_allocated_software_totp_method(::ownmfa::api::SoftwareTOTPMethod* software_totp_method) {
  clear_method_oneof();
  if (software_totp_method) {
    set_has_software_totp_method();
    _impl_.method_oneof_.software_totp_method_ = software_totp_method;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ownmfa.api.Identity.software_totp_method)
}
inline ::ownmfa::api::SoftwareTOTPMethod* Identity::_internal_mutable_software_totp_method() {
  if (method_oneof_case() != kSoftwareTotpMethod) {
    clear_method_oneof();
    set_has_software_totp_method();
    _impl_.method_oneof_.software_totp_method_ = CreateMaybeMessage< ::ownmfa::api::SoftwareTOTPMethod >(GetArenaForAllocation());
  }
  return _impl_.method_oneof_.software_totp_method_;
}
inline ::ownmfa::api::SoftwareTOTPMethod* Identity::mutable_software_totp_method() {
  ::ownmfa::api::SoftwareTOTPMethod* _msg = _internal_mutable_software_totp_method();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.Identity.software_totp_method)
  return _msg;
}

// .ownmfa.api.GoogleAuthHOTPMethod google_auth_hotp_method = 17 [json_name = "googleAuthHOTPMethod"];
inline bool Identity::has_google_auth_hotp_method() const {
  return method_oneof_case() == kGoogleAuthHotpMethod;
}
inline bool Identity::_internal_has_google_auth_hotp_method() const {
  return method_oneof_case() == kGoogleAuthHotpMethod;
}
inline void Identity::set_has_google_auth_hotp_method() {
  _impl_._oneof_case_[0] = kGoogleAuthHotpMethod;
}
inline void Identity::clear_google_auth_hotp_method() {
  if (method_oneof_case() == kGoogleAuthHotpMethod) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.method_oneof_.google_auth_hotp_method_;
    }
    clear_has_method_oneof();
  }
}
inline ::ownmfa::api::GoogleAuthHOTPMethod* Identity::release_google_auth_hotp_method() {
  // @@protoc_insertion_point(field_release:ownmfa.api.Identity.google_auth_hotp_method)
  if (method_oneof_case() == kGoogleAuthHotpMethod) {
    clear_has_method_oneof();
    ::ownmfa::api::GoogleAuthHOTPMethod* temp = _impl_.method_oneof_.google_auth_hotp_method_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.method_oneof_.google_auth_hotp_method_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ownmfa::api::GoogleAuthHOTPMethod& Identity::_internal_google_auth_hotp_method() const {
  return method_oneof_case() == kGoogleAuthHotpMethod
      ? *_impl_.method_oneof_.google_auth_hotp_method_
      : reinterpret_cast<::ownmfa::api::GoogleAuthHOTPMethod&>(::ownmfa::api::_GoogleAuthHOTPMethod_default_instance_);
}
inline const ::ownmfa::api::GoogleAuthHOTPMethod& Identity::google_auth_hotp_method() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.Identity.google_auth_hotp_method)
  return _internal_google_auth_hotp_method();
}
inline ::ownmfa::api::GoogleAuthHOTPMethod* Identity::unsafe_arena_release_google_auth_hotp_method() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ownmfa.api.Identity.google_auth_hotp_method)
  if (method_oneof_case() == kGoogleAuthHotpMethod) {
    clear_has_method_oneof();
    ::ownmfa::api::GoogleAuthHOTPMethod* temp = _impl_.method_oneof_.google_auth_hotp_method_;
    _impl_.method_oneof_.google_auth_hotp_method_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Identity::unsafe_arena_set_allocated_google_auth_hotp_method(::ownmfa::api::GoogleAuthHOTPMethod* google_auth_hotp_method) {
  clear_method_oneof();
  if (google_auth_hotp_method) {
    set_has_google_auth_hotp_method();
    _impl_.method_oneof_.google_auth_hotp_method_ = google_auth_hotp_method;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ownmfa.api.Identity.google_auth_hotp_method)
}
inline ::ownmfa::api::GoogleAuthHOTPMethod* Identity::_internal_mutable_google_auth_hotp_method() {
  if (method_oneof_case() != kGoogleAuthHotpMethod) {
    clear_method_oneof();
    set_has_google_auth_hotp_method();
    _impl_.method_oneof_.google_auth_hotp_method_ = CreateMaybeMessage< ::ownmfa::api::GoogleAuthHOTPMethod >(GetArenaForAllocation());
  }
  return _impl_.method_oneof_.google_auth_hotp_method_;
}
inline ::ownmfa::api::GoogleAuthHOTPMethod* Identity::mutable_google_auth_hotp_method() {
  ::ownmfa::api::GoogleAuthHOTPMethod* _msg = _internal_mutable_google_auth_hotp_method();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.Identity.google_auth_hotp_method)
  return _msg;
}

// .ownmfa.api.GoogleAuthTOTPMethod google_auth_totp_method = 7 [json_name = "googleAuthTOTPMethod"];
inline bool Identity::has_google_auth_totp_method() const {
  return method_oneof_case() == kGoogleAuthTotpMethod;
}
inline bool Identity::_internal_has_google_auth_totp_method() const {
  return method_oneof_case() == kGoogleAuthTotpMethod;
}
inline void Identity::set_has_google_auth_totp_method() {
  _impl_._oneof_case_[0] = kGoogleAuthTotpMethod;
}
inline void Identity::clear_google_auth_totp_method() {
  if (method_oneof_case() == kGoogleAuthTotpMethod) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.method_oneof_.google_auth_totp_method_;
    }
    clear_has_method_oneof();
  }
}
inline ::ownmfa::api::GoogleAuthTOTPMethod* Identity::release_google_auth_totp_method() {
  // @@protoc_insertion_point(field_release:ownmfa.api.Identity.google_auth_totp_method)
  if (method_oneof_case() == kGoogleAuthTotpMethod) {
    clear_has_method_oneof();
    ::ownmfa::api::GoogleAuthTOTPMethod* temp = _impl_.method_oneof_.google_auth_totp_method_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.method_oneof_.google_auth_totp_method_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ownmfa::api::GoogleAuthTOTPMethod& Identity::_internal_google_auth_totp_method() const {
  return method_oneof_case() == kGoogleAuthTotpMethod
      ? *_impl_.method_oneof_.google_auth_totp_method_
      : reinterpret_cast<::ownmfa::api::GoogleAuthTOTPMethod&>(::ownmfa::api::_GoogleAuthTOTPMethod_default_instance_);
}
inline const ::ownmfa::api::GoogleAuthTOTPMethod& Identity::google_auth_totp_method() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.Identity.google_auth_totp_method)
  return _internal_google_auth_totp_method();
}
inline ::ownmfa::api::GoogleAuthTOTPMethod* Identity::unsafe_arena_release_google_auth_totp_method() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ownmfa.api.Identity.google_auth_totp_method)
  if (method_oneof_case() == kGoogleAuthTotpMethod) {
    clear_has_method_oneof();
    ::ownmfa::api::GoogleAuthTOTPMethod* temp = _impl_.method_oneof_.google_auth_totp_method_;
    _impl_.method_oneof_.google_auth_totp_method_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Identity::unsafe_arena_set_allocated_google_auth_totp_method(::ownmfa::api::GoogleAuthTOTPMethod* google_auth_totp_method) {
  clear_method_oneof();
  if (google_auth_totp_method) {
    set_has_google_auth_totp_method();
    _impl_.method_oneof_.google_auth_totp_method_ = google_auth_totp_method;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ownmfa.api.Identity.google_auth_totp_method)
}
inline ::ownmfa::api::GoogleAuthTOTPMethod* Identity::_internal_mutable_google_auth_totp_method() {
  if (method_oneof_case() != kGoogleAuthTotpMethod) {
    clear_method_oneof();
    set_has_google_auth_totp_method();
    _impl_.method_oneof_.google_auth_totp_method_ = CreateMaybeMessage< ::ownmfa::api::GoogleAuthTOTPMethod >(GetArenaForAllocation());
  }
  return _impl_.method_oneof_.google_auth_totp_method_;
}
inline ::ownmfa::api::GoogleAuthTOTPMethod* Identity::mutable_google_auth_totp_method() {
  ::ownmfa::api::GoogleAuthTOTPMethod* _msg = _internal_mutable_google_auth_totp_method();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.Identity.google_auth_totp_method)
  return _msg;
}

// .ownmfa.api.AppleiOSTOTPMethod apple_ios_totp_method = 22 [json_name = "appleiOSTOTPMethod"];
inline bool Identity::has_apple_ios_totp_method() const {
  return method_oneof_case() == kAppleIosTotpMethod;
}
inline bool Identity::_internal_has_apple_ios_totp_method() const {
  return method_oneof_case() == kAppleIosTotpMethod;
}
inline void Identity::set_has_apple_ios_totp_method() {
  _impl_._oneof_case_[0] = kAppleIosTotpMethod;
}
inline void Identity::clear_apple_ios_totp_method() {
  if (method_oneof_case() == kAppleIosTotpMethod) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.method_oneof_.apple_ios_totp_method_;
    }
    clear_has_method_oneof();
  }
}
inline ::ownmfa::api::AppleiOSTOTPMethod* Identity::release_apple_ios_totp_method() {
  // @@protoc_insertion_point(field_release:ownmfa.api.Identity.apple_ios_totp_method)
  if (method_oneof_case() == kAppleIosTotpMethod) {
    clear_has_method_oneof();
    ::ownmfa::api::AppleiOSTOTPMethod* temp = _impl_.method_oneof_.apple_ios_totp_method_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.method_oneof_.apple_ios_totp_method_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ownmfa::api::AppleiOSTOTPMethod& Identity::_internal_apple_ios_totp_method() const {
  return method_oneof_case() == kAppleIosTotpMethod
      ? *_impl_.method_oneof_.apple_ios_totp_method_
      : reinterpret_cast<::ownmfa::api::AppleiOSTOTPMethod&>(::ownmfa::api::_AppleiOSTOTPMethod_default_instance_);
}
inline const ::ownmfa::api::AppleiOSTOTPMethod& Identity::apple_ios_totp_method() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.Identity.apple_ios_totp_method)
  return _internal_apple_ios_totp_method();
}
inline ::ownmfa::api::AppleiOSTOTPMethod* Identity::unsafe_arena_release_apple_ios_totp_method() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ownmfa.api.Identity.apple_ios_totp_method)
  if (method_oneof_case() == kAppleIosTotpMethod) {
    clear_has_method_oneof();
    ::ownmfa::api::AppleiOSTOTPMethod* temp = _impl_.method_oneof_.apple_ios_totp_method_;
    _impl_.method_oneof_.apple_ios_totp_method_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Identity::unsafe_arena_set_allocated_apple_ios_totp_method(::ownmfa::api::AppleiOSTOTPMethod* apple_ios_totp_method) {
  clear_method_oneof();
  if (apple_ios_totp_method) {
    set_has_apple_ios_totp_method();
    _impl_.method_oneof_.apple_ios_totp_method_ = apple_ios_totp_method;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ownmfa.api.Identity.apple_ios_totp_method)
}
inline ::ownmfa::api::AppleiOSTOTPMethod* Identity::_internal_mutable_apple_ios_totp_method() {
  if (method_oneof_case() != kAppleIosTotpMethod) {
    clear_method_oneof();
    set_has_apple_ios_totp_method();
    _impl_.method_oneof_.apple_ios_totp_method_ = CreateMaybeMessage< ::ownmfa::api::AppleiOSTOTPMethod >(GetArenaForAllocation());
  }
  return _impl_.method_oneof_.apple_ios_totp_method_;
}
inline ::ownmfa::api::AppleiOSTOTPMethod* Identity::mutable_apple_ios_totp_method() {
  ::ownmfa::api::AppleiOSTOTPMethod* _msg = _internal_mutable_apple_ios_totp_method();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.Identity.apple_ios_totp_method)
  return _msg;
}

// .ownmfa.api.HardwareHOTPMethod hardware_hotp_method = 18 [json_name = "hardwareHOTPMethod"];
inline bool Identity::has_hardware_hotp_method() const {
  return method_oneof_case() == kHardwareHotpMethod;
}
inline bool Identity::_internal_has_hardware_hotp_method() const {
  return method_oneof_case() == kHardwareHotpMethod;
}
inline void Identity::set_has_hardware_hotp_method() {
  _impl_._oneof_case_[0] = kHardwareHotpMethod;
}
inline void Identity::clear_hardware_hotp_method() {
  if (method_oneof_case() == kHardwareHotpMethod) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.method_oneof_.hardware_hotp_method_;
    }
    clear_has_method_oneof();
  }
}
inline ::ownmfa::api::HardwareHOTPMethod* Identity::release_hardware_hotp_method() {
  // @@protoc_insertion_point(field_release:ownmfa.api.Identity.hardware_hotp_method)
  if (method_oneof_case() == kHardwareHotpMethod) {
    clear_has_method_oneof();
    ::ownmfa::api::HardwareHOTPMethod* temp = _impl_.method_oneof_.hardware_hotp_method_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.method_oneof_.hardware_hotp_method_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ownmfa::api::HardwareHOTPMethod& Identity::_internal_hardware_hotp_method() const {
  return method_oneof_case() == kHardwareHotpMethod
      ? *_impl_.method_oneof_.hardware_hotp_method_
      : reinterpret_cast<::ownmfa::api::HardwareHOTPMethod&>(::ownmfa::api::_HardwareHOTPMethod_default_instance_);
}
inline const ::ownmfa::api::HardwareHOTPMethod& Identity::hardware_hotp_method() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.Identity.hardware_hotp_method)
  return _internal_hardware_hotp_method();
}
inline ::ownmfa::api::HardwareHOTPMethod* Identity::unsafe_arena_release_hardware_hotp_method() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ownmfa.api.Identity.hardware_hotp_method)
  if (method_oneof_case() == kHardwareHotpMethod) {
    clear_has_method_oneof();
    ::ownmfa::api::HardwareHOTPMethod* temp = _impl_.method_oneof_.hardware_hotp_method_;
    _impl_.method_oneof_.hardware_hotp_method_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Identity::unsafe_arena_set_allocated_hardware_hotp_method(::ownmfa::api::HardwareHOTPMethod* hardware_hotp_method) {
  clear_method_oneof();
  if (hardware_hotp_method) {
    set_has_hardware_hotp_method();
    _impl_.method_oneof_.hardware_hotp_method_ = hardware_hotp_method;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ownmfa.api.Identity.hardware_hotp_method)
}
inline ::ownmfa::api::HardwareHOTPMethod* Identity::_internal_mutable_hardware_hotp_method() {
  if (method_oneof_case() != kHardwareHotpMethod) {
    clear_method_oneof();
    set_has_hardware_hotp_method();
    _impl_.method_oneof_.hardware_hotp_method_ = CreateMaybeMessage< ::ownmfa::api::HardwareHOTPMethod >(GetArenaForAllocation());
  }
  return _impl_.method_oneof_.hardware_hotp_method_;
}
inline ::ownmfa::api::HardwareHOTPMethod* Identity::mutable_hardware_hotp_method() {
  ::ownmfa::api::HardwareHOTPMethod* _msg = _internal_mutable_hardware_hotp_method();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.Identity.hardware_hotp_method)
  return _msg;
}

// .ownmfa.api.HardwareTOTPMethod hardware_totp_method = 19 [json_name = "hardwareTOTPMethod"];
inline bool Identity::has_hardware_totp_method() const {
  return method_oneof_case() == kHardwareTotpMethod;
}
inline bool Identity::_internal_has_hardware_totp_method() const {
  return method_oneof_case() == kHardwareTotpMethod;
}
inline void Identity::set_has_hardware_totp_method() {
  _impl_._oneof_case_[0] = kHardwareTotpMethod;
}
inline void Identity::clear_hardware_totp_method() {
  if (method_oneof_case() == kHardwareTotpMethod) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.method_oneof_.hardware_totp_method_;
    }
    clear_has_method_oneof();
  }
}
inline ::ownmfa::api::HardwareTOTPMethod* Identity::release_hardware_totp_method() {
  // @@protoc_insertion_point(field_release:ownmfa.api.Identity.hardware_totp_method)
  if (method_oneof_case() == kHardwareTotpMethod) {
    clear_has_method_oneof();
    ::ownmfa::api::HardwareTOTPMethod* temp = _impl_.method_oneof_.hardware_totp_method_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.method_oneof_.hardware_totp_method_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ownmfa::api::HardwareTOTPMethod& Identity::_internal_hardware_totp_method() const {
  return method_oneof_case() == kHardwareTotpMethod
      ? *_impl_.method_oneof_.hardware_totp_method_
      : reinterpret_cast<::ownmfa::api::HardwareTOTPMethod&>(::ownmfa::api::_HardwareTOTPMethod_default_instance_);
}
inline const ::ownmfa::api::HardwareTOTPMethod& Identity::hardware_totp_method() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.Identity.hardware_totp_method)
  return _internal_hardware_totp_method();
}
inline ::ownmfa::api::HardwareTOTPMethod* Identity::unsafe_arena_release_hardware_totp_method() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ownmfa.api.Identity.hardware_totp_method)
  if (method_oneof_case() == kHardwareTotpMethod) {
    clear_has_method_oneof();
    ::ownmfa::api::HardwareTOTPMethod* temp = _impl_.method_oneof_.hardware_totp_method_;
    _impl_.method_oneof_.hardware_totp_method_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Identity::unsafe_arena_set_allocated_hardware_totp_method(::ownmfa::api::HardwareTOTPMethod* hardware_totp_method) {
  clear_method_oneof();
  if (hardware_totp_method) {
    set_has_hardware_totp_method();
    _impl_.method_oneof_.hardware_totp_method_ = hardware_totp_method;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ownmfa.api.Identity.hardware_totp_method)
}
inline ::ownmfa::api::HardwareTOTPMethod* Identity::_internal_mutable_hardware_totp_method() {
  if (method_oneof_case() != kHardwareTotpMethod) {
    clear_method_oneof();
    set_has_hardware_totp_method();
    _impl_.method_oneof_.hardware_totp_method_ = CreateMaybeMessage< ::ownmfa::api::HardwareTOTPMethod >(GetArenaForAllocation());
  }
  return _impl_.method_oneof_.hardware_totp_method_;
}
inline ::ownmfa::api::HardwareTOTPMethod* Identity::mutable_hardware_totp_method() {
  ::ownmfa::api::HardwareTOTPMethod* _msg = _internal_mutable_hardware_totp_method();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.Identity.hardware_totp_method)
  return _msg;
}

// .ownmfa.api.SMSMethod sms_method = 8;
inline bool Identity::has_sms_method() const {
  return method_oneof_case() == kSmsMethod;
}
inline bool Identity::_internal_has_sms_method() const {
  return method_oneof_case() == kSmsMethod;
}
inline void Identity::set_has_sms_method() {
  _impl_._oneof_case_[0] = kSmsMethod;
}
inline void Identity::clear_sms_method() {
  if (method_oneof_case() == kSmsMethod) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.method_oneof_.sms_method_;
    }
    clear_has_method_oneof();
  }
}
inline ::ownmfa::api::SMSMethod* Identity::release_sms_method() {
  // @@protoc_insertion_point(field_release:ownmfa.api.Identity.sms_method)
  if (method_oneof_case() == kSmsMethod) {
    clear_has_method_oneof();
    ::ownmfa::api::SMSMethod* temp = _impl_.method_oneof_.sms_method_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.method_oneof_.sms_method_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ownmfa::api::SMSMethod& Identity::_internal_sms_method() const {
  return method_oneof_case() == kSmsMethod
      ? *_impl_.method_oneof_.sms_method_
      : reinterpret_cast<::ownmfa::api::SMSMethod&>(::ownmfa::api::_SMSMethod_default_instance_);
}
inline const ::ownmfa::api::SMSMethod& Identity::sms_method() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.Identity.sms_method)
  return _internal_sms_method();
}
inline ::ownmfa::api::SMSMethod* Identity::unsafe_arena_release_sms_method() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ownmfa.api.Identity.sms_method)
  if (method_oneof_case() == kSmsMethod) {
    clear_has_method_oneof();
    ::ownmfa::api::SMSMethod* temp = _impl_.method_oneof_.sms_method_;
    _impl_.method_oneof_.sms_method_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Identity::unsafe_arena_set_allocated_sms_method(::ownmfa::api::SMSMethod* sms_method) {
  clear_method_oneof();
  if (sms_method) {
    set_has_sms_method();
    _impl_.method_oneof_.sms_method_ = sms_method;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ownmfa.api.Identity.sms_method)
}
inline ::ownmfa::api::SMSMethod* Identity::_internal_mutable_sms_method() {
  if (method_oneof_case() != kSmsMethod) {
    clear_method_oneof();
    set_has_sms_method();
    _impl_.method_oneof_.sms_method_ = CreateMaybeMessage< ::ownmfa::api::SMSMethod >(GetArenaForAllocation());
  }
  return _impl_.method_oneof_.sms_method_;
}
inline ::ownmfa::api::SMSMethod* Identity::mutable_sms_method() {
  ::ownmfa::api::SMSMethod* _msg = _internal_mutable_sms_method();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.Identity.sms_method)
  return _msg;
}

// .ownmfa.api.PushoverMethod pushover_method = 20;
inline bool Identity::has_pushover_method() const {
  return method_oneof_case() == kPushoverMethod;
}
inline bool Identity::_internal_has_pushover_method() const {
  return method_oneof_case() == kPushoverMethod;
}
inline void Identity::set_has_pushover_method() {
  _impl_._oneof_case_[0] = kPushoverMethod;
}
inline void Identity::clear_pushover_method() {
  if (method_oneof_case() == kPushoverMethod) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.method_oneof_.pushover_method_;
    }
    clear_has_method_oneof();
  }
}
inline ::ownmfa::api::PushoverMethod* Identity::release_pushover_method() {
  // @@protoc_insertion_point(field_release:ownmfa.api.Identity.pushover_method)
  if (method_oneof_case() == kPushoverMethod) {
    clear_has_method_oneof();
    ::ownmfa::api::PushoverMethod* temp = _impl_.method_oneof_.pushover_method_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.method_oneof_.pushover_method_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ownmfa::api::PushoverMethod& Identity::_internal_pushover_method() const {
  return method_oneof_case() == kPushoverMethod
      ? *_impl_.method_oneof_.pushover_method_
      : reinterpret_cast<::ownmfa::api::PushoverMethod&>(::ownmfa::api::_PushoverMethod_default_instance_);
}
inline const ::ownmfa::api::PushoverMethod& Identity::pushover_method() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.Identity.pushover_method)
  return _internal_pushover_method();
}
inline ::ownmfa::api::PushoverMethod* Identity::unsafe_arena_release_pushover_method() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ownmfa.api.Identity.pushover_method)
  if (method_oneof_case() == kPushoverMethod) {
    clear_has_method_oneof();
    ::ownmfa::api::PushoverMethod* temp = _impl_.method_oneof_.pushover_method_;
    _impl_.method_oneof_.pushover_method_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Identity::unsafe_arena_set_allocated_pushover_method(::ownmfa::api::PushoverMethod* pushover_method) {
  clear_method_oneof();
  if (pushover_method) {
    set_has_pushover_method();
    _impl_.method_oneof_.pushover_method_ = pushover_method;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ownmfa.api.Identity.pushover_method)
}
inline ::ownmfa::api::PushoverMethod* Identity::_internal_mutable_pushover_method() {
  if (method_oneof_case() != kPushoverMethod) {
    clear_method_oneof();
    set_has_pushover_method();
    _impl_.method_oneof_.pushover_method_ = CreateMaybeMessage< ::ownmfa::api::PushoverMethod >(GetArenaForAllocation());
  }
  return _impl_.method_oneof_.pushover_method_;
}
inline ::ownmfa::api::PushoverMethod* Identity::mutable_pushover_method() {
  ::ownmfa::api::PushoverMethod* _msg = _internal_mutable_pushover_method();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.Identity.pushover_method)
  return _msg;
}

// .ownmfa.api.EmailMethod email_method = 9;
inline bool Identity::has_email_method() const {
  return method_oneof_case() == kEmailMethod;
}
inline bool Identity::_internal_has_email_method() const {
  return method_oneof_case() == kEmailMethod;
}
inline void Identity::set_has_email_method() {
  _impl_._oneof_case_[0] = kEmailMethod;
}
inline void Identity::clear_email_method() {
  if (method_oneof_case() == kEmailMethod) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.method_oneof_.email_method_;
    }
    clear_has_method_oneof();
  }
}
inline ::ownmfa::api::EmailMethod* Identity::release_email_method() {
  // @@protoc_insertion_point(field_release:ownmfa.api.Identity.email_method)
  if (method_oneof_case() == kEmailMethod) {
    clear_has_method_oneof();
    ::ownmfa::api::EmailMethod* temp = _impl_.method_oneof_.email_method_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.method_oneof_.email_method_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ownmfa::api::EmailMethod& Identity::_internal_email_method() const {
  return method_oneof_case() == kEmailMethod
      ? *_impl_.method_oneof_.email_method_
      : reinterpret_cast<::ownmfa::api::EmailMethod&>(::ownmfa::api::_EmailMethod_default_instance_);
}
inline const ::ownmfa::api::EmailMethod& Identity::email_method() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.Identity.email_method)
  return _internal_email_method();
}
inline ::ownmfa::api::EmailMethod* Identity::unsafe_arena_release_email_method() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ownmfa.api.Identity.email_method)
  if (method_oneof_case() == kEmailMethod) {
    clear_has_method_oneof();
    ::ownmfa::api::EmailMethod* temp = _impl_.method_oneof_.email_method_;
    _impl_.method_oneof_.email_method_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Identity::unsafe_arena_set_allocated_email_method(::ownmfa::api::EmailMethod* email_method) {
  clear_method_oneof();
  if (email_method) {
    set_has_email_method();
    _impl_.method_oneof_.email_method_ = email_method;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ownmfa.api.Identity.email_method)
}
inline ::ownmfa::api::EmailMethod* Identity::_internal_mutable_email_method() {
  if (method_oneof_case() != kEmailMethod) {
    clear_method_oneof();
    set_has_email_method();
    _impl_.method_oneof_.email_method_ = CreateMaybeMessage< ::ownmfa::api::EmailMethod >(GetArenaForAllocation());
  }
  return _impl_.method_oneof_.email_method_;
}
inline ::ownmfa::api::EmailMethod* Identity::mutable_email_method() {
  ::ownmfa::api::EmailMethod* _msg = _internal_mutable_email_method();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.Identity.email_method)
  return _msg;
}

// .ownmfa.api.BackupsCodesMethod backup_codes_method = 10;
inline bool Identity::has_backup_codes_method() const {
  return method_oneof_case() == kBackupCodesMethod;
}
inline bool Identity::_internal_has_backup_codes_method() const {
  return method_oneof_case() == kBackupCodesMethod;
}
inline void Identity::set_has_backup_codes_method() {
  _impl_._oneof_case_[0] = kBackupCodesMethod;
}
inline void Identity::clear_backup_codes_method() {
  if (method_oneof_case() == kBackupCodesMethod) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.method_oneof_.backup_codes_method_;
    }
    clear_has_method_oneof();
  }
}
inline ::ownmfa::api::BackupsCodesMethod* Identity::release_backup_codes_method() {
  // @@protoc_insertion_point(field_release:ownmfa.api.Identity.backup_codes_method)
  if (method_oneof_case() == kBackupCodesMethod) {
    clear_has_method_oneof();
    ::ownmfa::api::BackupsCodesMethod* temp = _impl_.method_oneof_.backup_codes_method_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.method_oneof_.backup_codes_method_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ownmfa::api::BackupsCodesMethod& Identity::_internal_backup_codes_method() const {
  return method_oneof_case() == kBackupCodesMethod
      ? *_impl_.method_oneof_.backup_codes_method_
      : reinterpret_cast<::ownmfa::api::BackupsCodesMethod&>(::ownmfa::api::_BackupsCodesMethod_default_instance_);
}
inline const ::ownmfa::api::BackupsCodesMethod& Identity::backup_codes_method() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.Identity.backup_codes_method)
  return _internal_backup_codes_method();
}
inline ::ownmfa::api::BackupsCodesMethod* Identity::unsafe_arena_release_backup_codes_method() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ownmfa.api.Identity.backup_codes_method)
  if (method_oneof_case() == kBackupCodesMethod) {
    clear_has_method_oneof();
    ::ownmfa::api::BackupsCodesMethod* temp = _impl_.method_oneof_.backup_codes_method_;
    _impl_.method_oneof_.backup_codes_method_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Identity::unsafe_arena_set_allocated_backup_codes_method(::ownmfa::api::BackupsCodesMethod* backup_codes_method) {
  clear_method_oneof();
  if (backup_codes_method) {
    set_has_backup_codes_method();
    _impl_.method_oneof_.backup_codes_method_ = backup_codes_method;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ownmfa.api.Identity.backup_codes_method)
}
inline ::ownmfa::api::BackupsCodesMethod* Identity::_internal_mutable_backup_codes_method() {
  if (method_oneof_case() != kBackupCodesMethod) {
    clear_method_oneof();
    set_has_backup_codes_method();
    _impl_.method_oneof_.backup_codes_method_ = CreateMaybeMessage< ::ownmfa::api::BackupsCodesMethod >(GetArenaForAllocation());
  }
  return _impl_.method_oneof_.backup_codes_method_;
}
inline ::ownmfa::api::BackupsCodesMethod* Identity::mutable_backup_codes_method() {
  ::ownmfa::api::BackupsCodesMethod* _msg = _internal_mutable_backup_codes_method();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.Identity.backup_codes_method)
  return _msg;
}

// .ownmfa.api.SecurityQuestionsMethod security_questions_method = 21;
inline bool Identity::has_security_questions_method() const {
  return method_oneof_case() == kSecurityQuestionsMethod;
}
inline bool Identity::_internal_has_security_questions_method() const {
  return method_oneof_case() == kSecurityQuestionsMethod;
}
inline void Identity::set_has_security_questions_method() {
  _impl_._oneof_case_[0] = kSecurityQuestionsMethod;
}
inline void Identity::clear_security_questions_method() {
  if (method_oneof_case() == kSecurityQuestionsMethod) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.method_oneof_.security_questions_method_;
    }
    clear_has_method_oneof();
  }
}
inline ::ownmfa::api::SecurityQuestionsMethod* Identity::release_security_questions_method() {
  // @@protoc_insertion_point(field_release:ownmfa.api.Identity.security_questions_method)
  if (method_oneof_case() == kSecurityQuestionsMethod) {
    clear_has_method_oneof();
    ::ownmfa::api::SecurityQuestionsMethod* temp = _impl_.method_oneof_.security_questions_method_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.method_oneof_.security_questions_method_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ownmfa::api::SecurityQuestionsMethod& Identity::_internal_security_questions_method() const {
  return method_oneof_case() == kSecurityQuestionsMethod
      ? *_impl_.method_oneof_.security_questions_method_
      : reinterpret_cast<::ownmfa::api::SecurityQuestionsMethod&>(::ownmfa::api::_SecurityQuestionsMethod_default_instance_);
}
inline const ::ownmfa::api::SecurityQuestionsMethod& Identity::security_questions_method() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.Identity.security_questions_method)
  return _internal_security_questions_method();
}
inline ::ownmfa::api::SecurityQuestionsMethod* Identity::unsafe_arena_release_security_questions_method() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ownmfa.api.Identity.security_questions_method)
  if (method_oneof_case() == kSecurityQuestionsMethod) {
    clear_has_method_oneof();
    ::ownmfa::api::SecurityQuestionsMethod* temp = _impl_.method_oneof_.security_questions_method_;
    _impl_.method_oneof_.security_questions_method_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Identity::unsafe_arena_set_allocated_security_questions_method(::ownmfa::api::SecurityQuestionsMethod* security_questions_method) {
  clear_method_oneof();
  if (security_questions_method) {
    set_has_security_questions_method();
    _impl_.method_oneof_.security_questions_method_ = security_questions_method;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ownmfa.api.Identity.security_questions_method)
}
inline ::ownmfa::api::SecurityQuestionsMethod* Identity::_internal_mutable_security_questions_method() {
  if (method_oneof_case() != kSecurityQuestionsMethod) {
    clear_method_oneof();
    set_has_security_questions_method();
    _impl_.method_oneof_.security_questions_method_ = CreateMaybeMessage< ::ownmfa::api::SecurityQuestionsMethod >(GetArenaForAllocation());
  }
  return _impl_.method_oneof_.security_questions_method_;
}
inline ::ownmfa::api::SecurityQuestionsMethod* Identity::mutable_security_questions_method() {
  ::ownmfa::api::SecurityQuestionsMethod* _msg = _internal_mutable_security_questions_method();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.Identity.security_questions_method)
  return _msg;
}

// .google.protobuf.Timestamp created_at = 14 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline bool Identity::has_created_at() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.created_at_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& Identity::_internal_created_at() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& Identity::created_at() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.Identity.created_at)
  return _internal_created_at();
}
inline void Identity::unsafe_arena_set_allocated_created_at(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ownmfa.api.Identity.created_at)
}
inline ::google::protobuf::Timestamp* Identity::release_created_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* Identity::unsafe_arena_release_created_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ownmfa.api.Identity.created_at)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* Identity::_internal_mutable_created_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.created_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaForAllocation());
    _impl_.created_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.created_at_;
}
inline ::google::protobuf::Timestamp* Identity::mutable_created_at() {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.Identity.created_at)
  return _msg;
}
inline void Identity::set_allocated_created_at(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.created_at_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.created_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.Identity.created_at)
}

// .google.protobuf.Timestamp updated_at = 15 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline bool Identity::has_updated_at() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.updated_at_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& Identity::_internal_updated_at() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Timestamp* p = _impl_.updated_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& Identity::updated_at() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.Identity.updated_at)
  return _internal_updated_at();
}
inline void Identity::unsafe_arena_set_allocated_updated_at(::google::protobuf::Timestamp* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.updated_at_);
  }
  _impl_.updated_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ownmfa.api.Identity.updated_at)
}
inline ::google::protobuf::Timestamp* Identity::release_updated_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* released = _impl_.updated_at_;
  _impl_.updated_at_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Timestamp* Identity::unsafe_arena_release_updated_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ownmfa.api.Identity.updated_at)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* temp = _impl_.updated_at_;
  _impl_.updated_at_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* Identity::_internal_mutable_updated_at() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.updated_at_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Timestamp>(GetArenaForAllocation());
    _impl_.updated_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.updated_at_;
}
inline ::google::protobuf::Timestamp* Identity::mutable_updated_at() {
  ::google::protobuf::Timestamp* _msg = _internal_mutable_updated_at();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.Identity.updated_at)
  return _msg;
}
inline void Identity::set_allocated_updated_at(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.updated_at_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::google::protobuf::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.updated_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.Identity.updated_at)
}

inline bool Identity::has_method_oneof() const {
  return method_oneof_case() != METHOD_ONEOF_NOT_SET;
}
inline void Identity::clear_has_method_oneof() {
  _impl_._oneof_case_[0] = METHOD_ONEOF_NOT_SET;
}
inline Identity::MethodOneofCase Identity::method_oneof_case() const {
  return Identity::MethodOneofCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// CreateIdentityRequest

// .ownmfa.api.Identity identity = 1 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline bool CreateIdentityRequest::has_identity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.identity_ != nullptr);
  return value;
}
inline void CreateIdentityRequest::clear_identity() {
  if (_impl_.identity_ != nullptr) _impl_.identity_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::ownmfa::api::Identity& CreateIdentityRequest::_internal_identity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::ownmfa::api::Identity* p = _impl_.identity_;
  return p != nullptr ? *p : reinterpret_cast<const ::ownmfa::api::Identity&>(::ownmfa::api::_Identity_default_instance_);
}
inline const ::ownmfa::api::Identity& CreateIdentityRequest::identity() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.CreateIdentityRequest.identity)
  return _internal_identity();
}
inline void CreateIdentityRequest::unsafe_arena_set_allocated_identity(::ownmfa::api::Identity* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.identity_);
  }
  _impl_.identity_ = reinterpret_cast<::ownmfa::api::Identity*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ownmfa.api.CreateIdentityRequest.identity)
}
inline ::ownmfa::api::Identity* CreateIdentityRequest::release_identity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ownmfa::api::Identity* released = _impl_.identity_;
  _impl_.identity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::ownmfa::api::Identity* CreateIdentityRequest::unsafe_arena_release_identity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ownmfa.api.CreateIdentityRequest.identity)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ownmfa::api::Identity* temp = _impl_.identity_;
  _impl_.identity_ = nullptr;
  return temp;
}
inline ::ownmfa::api::Identity* CreateIdentityRequest::_internal_mutable_identity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.identity_ == nullptr) {
    auto* p = CreateMaybeMessage<::ownmfa::api::Identity>(GetArenaForAllocation());
    _impl_.identity_ = reinterpret_cast<::ownmfa::api::Identity*>(p);
  }
  return _impl_.identity_;
}
inline ::ownmfa::api::Identity* CreateIdentityRequest::mutable_identity() {
  ::ownmfa::api::Identity* _msg = _internal_mutable_identity();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.CreateIdentityRequest.identity)
  return _msg;
}
inline void CreateIdentityRequest::set_allocated_identity(::ownmfa::api::Identity* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::ownmfa::api::Identity*>(_impl_.identity_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::ownmfa::api::Identity*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.identity_ = reinterpret_cast<::ownmfa::api::Identity*>(value);
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.CreateIdentityRequest.identity)
}

// -------------------------------------------------------------------

// CreateIdentityResponse

// .ownmfa.api.Identity identity = 1;
inline bool CreateIdentityResponse::has_identity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.identity_ != nullptr);
  return value;
}
inline void CreateIdentityResponse::clear_identity() {
  if (_impl_.identity_ != nullptr) _impl_.identity_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::ownmfa::api::Identity& CreateIdentityResponse::_internal_identity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::ownmfa::api::Identity* p = _impl_.identity_;
  return p != nullptr ? *p : reinterpret_cast<const ::ownmfa::api::Identity&>(::ownmfa::api::_Identity_default_instance_);
}
inline const ::ownmfa::api::Identity& CreateIdentityResponse::identity() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.CreateIdentityResponse.identity)
  return _internal_identity();
}
inline void CreateIdentityResponse::unsafe_arena_set_allocated_identity(::ownmfa::api::Identity* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.identity_);
  }
  _impl_.identity_ = reinterpret_cast<::ownmfa::api::Identity*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ownmfa.api.CreateIdentityResponse.identity)
}
inline ::ownmfa::api::Identity* CreateIdentityResponse::release_identity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ownmfa::api::Identity* released = _impl_.identity_;
  _impl_.identity_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::ownmfa::api::Identity* CreateIdentityResponse::unsafe_arena_release_identity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ownmfa.api.CreateIdentityResponse.identity)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ownmfa::api::Identity* temp = _impl_.identity_;
  _impl_.identity_ = nullptr;
  return temp;
}
inline ::ownmfa::api::Identity* CreateIdentityResponse::_internal_mutable_identity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.identity_ == nullptr) {
    auto* p = CreateMaybeMessage<::ownmfa::api::Identity>(GetArenaForAllocation());
    _impl_.identity_ = reinterpret_cast<::ownmfa::api::Identity*>(p);
  }
  return _impl_.identity_;
}
inline ::ownmfa::api::Identity* CreateIdentityResponse::mutable_identity() {
  ::ownmfa::api::Identity* _msg = _internal_mutable_identity();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.CreateIdentityResponse.identity)
  return _msg;
}
inline void CreateIdentityResponse::set_allocated_identity(::ownmfa::api::Identity* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::ownmfa::api::Identity*>(_impl_.identity_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::ownmfa::api::Identity*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.identity_ = reinterpret_cast<::ownmfa::api::Identity*>(value);
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.CreateIdentityResponse.identity)
}

// string secret = 2;
inline void CreateIdentityResponse::clear_secret() {
  _impl_.secret_.ClearToEmpty();
}
inline const std::string& CreateIdentityResponse::secret() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.CreateIdentityResponse.secret)
  return _internal_secret();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreateIdentityResponse::set_secret(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.secret_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ownmfa.api.CreateIdentityResponse.secret)
}
inline std::string* CreateIdentityResponse::mutable_secret() {
  std::string* _s = _internal_mutable_secret();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.CreateIdentityResponse.secret)
  return _s;
}
inline const std::string& CreateIdentityResponse::_internal_secret() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.secret_.Get();
}
inline void CreateIdentityResponse::_internal_set_secret(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.secret_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateIdentityResponse::_internal_mutable_secret() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.secret_.Mutable( GetArenaForAllocation());
}
inline std::string* CreateIdentityResponse::release_secret() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ownmfa.api.CreateIdentityResponse.secret)
  return _impl_.secret_.Release();
}
inline void CreateIdentityResponse::set_allocated_secret(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.secret_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.secret_.IsDefault()) {
          _impl_.secret_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.CreateIdentityResponse.secret)
}

// bytes qr = 3;
inline void CreateIdentityResponse::clear_qr() {
  _impl_.qr_.ClearToEmpty();
}
inline const std::string& CreateIdentityResponse::qr() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.CreateIdentityResponse.qr)
  return _internal_qr();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreateIdentityResponse::set_qr(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.qr_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ownmfa.api.CreateIdentityResponse.qr)
}
inline std::string* CreateIdentityResponse::mutable_qr() {
  std::string* _s = _internal_mutable_qr();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.CreateIdentityResponse.qr)
  return _s;
}
inline const std::string& CreateIdentityResponse::_internal_qr() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.qr_.Get();
}
inline void CreateIdentityResponse::_internal_set_qr(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.qr_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateIdentityResponse::_internal_mutable_qr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.qr_.Mutable( GetArenaForAllocation());
}
inline std::string* CreateIdentityResponse::release_qr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ownmfa.api.CreateIdentityResponse.qr)
  return _impl_.qr_.Release();
}
inline void CreateIdentityResponse::set_allocated_qr(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.qr_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.qr_.IsDefault()) {
          _impl_.qr_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.CreateIdentityResponse.qr)
}

// repeated string passcodes = 4;
inline int CreateIdentityResponse::_internal_passcodes_size() const {
  return _internal_passcodes().size();
}
inline int CreateIdentityResponse::passcodes_size() const {
  return _internal_passcodes_size();
}
inline void CreateIdentityResponse::clear_passcodes() {
  _internal_mutable_passcodes()->Clear();
}
inline std::string* CreateIdentityResponse::add_passcodes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_passcodes()->Add();
  // @@protoc_insertion_point(field_add_mutable:ownmfa.api.CreateIdentityResponse.passcodes)
  return _s;
}
inline const std::string& CreateIdentityResponse::passcodes(int index) const {
  // @@protoc_insertion_point(field_get:ownmfa.api.CreateIdentityResponse.passcodes)
  return _internal_passcodes().Get(index);
}
inline std::string* CreateIdentityResponse::mutable_passcodes(int index) {
  // @@protoc_insertion_point(field_mutable:ownmfa.api.CreateIdentityResponse.passcodes)
  return _internal_mutable_passcodes()->Mutable(index);
}
inline void CreateIdentityResponse::set_passcodes(int index, const std::string& value) {
  _internal_mutable_passcodes()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ownmfa.api.CreateIdentityResponse.passcodes)
}
inline void CreateIdentityResponse::set_passcodes(int index, std::string&& value) {
  _internal_mutable_passcodes()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ownmfa.api.CreateIdentityResponse.passcodes)
}
inline void CreateIdentityResponse::set_passcodes(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_passcodes()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ownmfa.api.CreateIdentityResponse.passcodes)
}
inline void CreateIdentityResponse::set_passcodes(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_passcodes()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ownmfa.api.CreateIdentityResponse.passcodes)
}
inline void CreateIdentityResponse::set_passcodes(int index, absl::string_view value) {
  _internal_mutable_passcodes()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:ownmfa.api.CreateIdentityResponse.passcodes)
}
inline void CreateIdentityResponse::add_passcodes(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_passcodes()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:ownmfa.api.CreateIdentityResponse.passcodes)
}
inline void CreateIdentityResponse::add_passcodes(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_passcodes()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:ownmfa.api.CreateIdentityResponse.passcodes)
}
inline void CreateIdentityResponse::add_passcodes(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_passcodes()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ownmfa.api.CreateIdentityResponse.passcodes)
}
inline void CreateIdentityResponse::add_passcodes(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_passcodes()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ownmfa.api.CreateIdentityResponse.passcodes)
}
inline void CreateIdentityResponse::add_passcodes(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_passcodes()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:ownmfa.api.CreateIdentityResponse.passcodes)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
CreateIdentityResponse::passcodes() const {
  // @@protoc_insertion_point(field_list:ownmfa.api.CreateIdentityResponse.passcodes)
  return _internal_passcodes();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* CreateIdentityResponse::mutable_passcodes() {
  // @@protoc_insertion_point(field_mutable_list:ownmfa.api.CreateIdentityResponse.passcodes)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_passcodes();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
CreateIdentityResponse::_internal_passcodes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.passcodes_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
CreateIdentityResponse::_internal_mutable_passcodes() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.passcodes_;
}

// -------------------------------------------------------------------

// ActivateIdentityRequest

// string id = 1 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline void ActivateIdentityRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& ActivateIdentityRequest::id() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.ActivateIdentityRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ActivateIdentityRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ownmfa.api.ActivateIdentityRequest.id)
}
inline std::string* ActivateIdentityRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.ActivateIdentityRequest.id)
  return _s;
}
inline const std::string& ActivateIdentityRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void ActivateIdentityRequest::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* ActivateIdentityRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* ActivateIdentityRequest::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ownmfa.api.ActivateIdentityRequest.id)
  return _impl_.id_.Release();
}
inline void ActivateIdentityRequest::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.ActivateIdentityRequest.id)
}

// string app_id = 2 [json_name = "appID", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline void ActivateIdentityRequest::clear_app_id() {
  _impl_.app_id_.ClearToEmpty();
}
inline const std::string& ActivateIdentityRequest::app_id() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.ActivateIdentityRequest.app_id)
  return _internal_app_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ActivateIdentityRequest::set_app_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.app_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ownmfa.api.ActivateIdentityRequest.app_id)
}
inline std::string* ActivateIdentityRequest::mutable_app_id() {
  std::string* _s = _internal_mutable_app_id();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.ActivateIdentityRequest.app_id)
  return _s;
}
inline const std::string& ActivateIdentityRequest::_internal_app_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.app_id_.Get();
}
inline void ActivateIdentityRequest::_internal_set_app_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.app_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ActivateIdentityRequest::_internal_mutable_app_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.app_id_.Mutable( GetArenaForAllocation());
}
inline std::string* ActivateIdentityRequest::release_app_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ownmfa.api.ActivateIdentityRequest.app_id)
  return _impl_.app_id_.Release();
}
inline void ActivateIdentityRequest::set_allocated_app_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.app_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.app_id_.IsDefault()) {
          _impl_.app_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.ActivateIdentityRequest.app_id)
}

// string passcode = 3 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline void ActivateIdentityRequest::clear_passcode() {
  _impl_.passcode_.ClearToEmpty();
}
inline const std::string& ActivateIdentityRequest::passcode() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.ActivateIdentityRequest.passcode)
  return _internal_passcode();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ActivateIdentityRequest::set_passcode(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.passcode_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ownmfa.api.ActivateIdentityRequest.passcode)
}
inline std::string* ActivateIdentityRequest::mutable_passcode() {
  std::string* _s = _internal_mutable_passcode();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.ActivateIdentityRequest.passcode)
  return _s;
}
inline const std::string& ActivateIdentityRequest::_internal_passcode() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.passcode_.Get();
}
inline void ActivateIdentityRequest::_internal_set_passcode(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.passcode_.Set(value, GetArenaForAllocation());
}
inline std::string* ActivateIdentityRequest::_internal_mutable_passcode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.passcode_.Mutable( GetArenaForAllocation());
}
inline std::string* ActivateIdentityRequest::release_passcode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ownmfa.api.ActivateIdentityRequest.passcode)
  return _impl_.passcode_.Release();
}
inline void ActivateIdentityRequest::set_allocated_passcode(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.passcode_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.passcode_.IsDefault()) {
          _impl_.passcode_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.ActivateIdentityRequest.passcode)
}

// -------------------------------------------------------------------

// ChallengeIdentityRequest

// string id = 1 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline void ChallengeIdentityRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& ChallengeIdentityRequest::id() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.ChallengeIdentityRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChallengeIdentityRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ownmfa.api.ChallengeIdentityRequest.id)
}
inline std::string* ChallengeIdentityRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.ChallengeIdentityRequest.id)
  return _s;
}
inline const std::string& ChallengeIdentityRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void ChallengeIdentityRequest::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* ChallengeIdentityRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* ChallengeIdentityRequest::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ownmfa.api.ChallengeIdentityRequest.id)
  return _impl_.id_.Release();
}
inline void ChallengeIdentityRequest::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.ChallengeIdentityRequest.id)
}

// string app_id = 2 [json_name = "appID", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline void ChallengeIdentityRequest::clear_app_id() {
  _impl_.app_id_.ClearToEmpty();
}
inline const std::string& ChallengeIdentityRequest::app_id() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.ChallengeIdentityRequest.app_id)
  return _internal_app_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChallengeIdentityRequest::set_app_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.app_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ownmfa.api.ChallengeIdentityRequest.app_id)
}
inline std::string* ChallengeIdentityRequest::mutable_app_id() {
  std::string* _s = _internal_mutable_app_id();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.ChallengeIdentityRequest.app_id)
  return _s;
}
inline const std::string& ChallengeIdentityRequest::_internal_app_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.app_id_.Get();
}
inline void ChallengeIdentityRequest::_internal_set_app_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.app_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ChallengeIdentityRequest::_internal_mutable_app_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.app_id_.Mutable( GetArenaForAllocation());
}
inline std::string* ChallengeIdentityRequest::release_app_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ownmfa.api.ChallengeIdentityRequest.app_id)
  return _impl_.app_id_.Release();
}
inline void ChallengeIdentityRequest::set_allocated_app_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.app_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.app_id_.IsDefault()) {
          _impl_.app_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.ChallengeIdentityRequest.app_id)
}

// -------------------------------------------------------------------

// VerifyIdentityRequest

// string id = 1 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline void VerifyIdentityRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& VerifyIdentityRequest::id() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.VerifyIdentityRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VerifyIdentityRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ownmfa.api.VerifyIdentityRequest.id)
}
inline std::string* VerifyIdentityRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.VerifyIdentityRequest.id)
  return _s;
}
inline const std::string& VerifyIdentityRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void VerifyIdentityRequest::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* VerifyIdentityRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* VerifyIdentityRequest::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ownmfa.api.VerifyIdentityRequest.id)
  return _impl_.id_.Release();
}
inline void VerifyIdentityRequest::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.VerifyIdentityRequest.id)
}

// string app_id = 2 [json_name = "appID", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline void VerifyIdentityRequest::clear_app_id() {
  _impl_.app_id_.ClearToEmpty();
}
inline const std::string& VerifyIdentityRequest::app_id() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.VerifyIdentityRequest.app_id)
  return _internal_app_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VerifyIdentityRequest::set_app_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.app_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ownmfa.api.VerifyIdentityRequest.app_id)
}
inline std::string* VerifyIdentityRequest::mutable_app_id() {
  std::string* _s = _internal_mutable_app_id();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.VerifyIdentityRequest.app_id)
  return _s;
}
inline const std::string& VerifyIdentityRequest::_internal_app_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.app_id_.Get();
}
inline void VerifyIdentityRequest::_internal_set_app_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.app_id_.Set(value, GetArenaForAllocation());
}
inline std::string* VerifyIdentityRequest::_internal_mutable_app_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.app_id_.Mutable( GetArenaForAllocation());
}
inline std::string* VerifyIdentityRequest::release_app_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ownmfa.api.VerifyIdentityRequest.app_id)
  return _impl_.app_id_.Release();
}
inline void VerifyIdentityRequest::set_allocated_app_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.app_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.app_id_.IsDefault()) {
          _impl_.app_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.VerifyIdentityRequest.app_id)
}

// string passcode = 3 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline void VerifyIdentityRequest::clear_passcode() {
  _impl_.passcode_.ClearToEmpty();
}
inline const std::string& VerifyIdentityRequest::passcode() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.VerifyIdentityRequest.passcode)
  return _internal_passcode();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VerifyIdentityRequest::set_passcode(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.passcode_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ownmfa.api.VerifyIdentityRequest.passcode)
}
inline std::string* VerifyIdentityRequest::mutable_passcode() {
  std::string* _s = _internal_mutable_passcode();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.VerifyIdentityRequest.passcode)
  return _s;
}
inline const std::string& VerifyIdentityRequest::_internal_passcode() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.passcode_.Get();
}
inline void VerifyIdentityRequest::_internal_set_passcode(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.passcode_.Set(value, GetArenaForAllocation());
}
inline std::string* VerifyIdentityRequest::_internal_mutable_passcode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.passcode_.Mutable( GetArenaForAllocation());
}
inline std::string* VerifyIdentityRequest::release_passcode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ownmfa.api.VerifyIdentityRequest.passcode)
  return _impl_.passcode_.Release();
}
inline void VerifyIdentityRequest::set_allocated_passcode(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.passcode_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.passcode_.IsDefault()) {
          _impl_.passcode_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.VerifyIdentityRequest.passcode)
}

// -------------------------------------------------------------------

// GetIdentityRequest

// string id = 1 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline void GetIdentityRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& GetIdentityRequest::id() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.GetIdentityRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetIdentityRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ownmfa.api.GetIdentityRequest.id)
}
inline std::string* GetIdentityRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.GetIdentityRequest.id)
  return _s;
}
inline const std::string& GetIdentityRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void GetIdentityRequest::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetIdentityRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* GetIdentityRequest::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ownmfa.api.GetIdentityRequest.id)
  return _impl_.id_.Release();
}
inline void GetIdentityRequest::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.GetIdentityRequest.id)
}

// string app_id = 2 [json_name = "appID", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline void GetIdentityRequest::clear_app_id() {
  _impl_.app_id_.ClearToEmpty();
}
inline const std::string& GetIdentityRequest::app_id() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.GetIdentityRequest.app_id)
  return _internal_app_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetIdentityRequest::set_app_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.app_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ownmfa.api.GetIdentityRequest.app_id)
}
inline std::string* GetIdentityRequest::mutable_app_id() {
  std::string* _s = _internal_mutable_app_id();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.GetIdentityRequest.app_id)
  return _s;
}
inline const std::string& GetIdentityRequest::_internal_app_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.app_id_.Get();
}
inline void GetIdentityRequest::_internal_set_app_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.app_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetIdentityRequest::_internal_mutable_app_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.app_id_.Mutable( GetArenaForAllocation());
}
inline std::string* GetIdentityRequest::release_app_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ownmfa.api.GetIdentityRequest.app_id)
  return _impl_.app_id_.Release();
}
inline void GetIdentityRequest::set_allocated_app_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.app_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.app_id_.IsDefault()) {
          _impl_.app_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.GetIdentityRequest.app_id)
}

// -------------------------------------------------------------------

// DeleteIdentityRequest

// string id = 1 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline void DeleteIdentityRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& DeleteIdentityRequest::id() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.DeleteIdentityRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DeleteIdentityRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ownmfa.api.DeleteIdentityRequest.id)
}
inline std::string* DeleteIdentityRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.DeleteIdentityRequest.id)
  return _s;
}
inline const std::string& DeleteIdentityRequest::_internal_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.id_.Get();
}
inline void DeleteIdentityRequest::_internal_set_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteIdentityRequest::_internal_mutable_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.id_.Mutable( GetArenaForAllocation());
}
inline std::string* DeleteIdentityRequest::release_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ownmfa.api.DeleteIdentityRequest.id)
  return _impl_.id_.Release();
}
inline void DeleteIdentityRequest::set_allocated_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.id_.IsDefault()) {
          _impl_.id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.DeleteIdentityRequest.id)
}

// string app_id = 2 [json_name = "appID", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline void DeleteIdentityRequest::clear_app_id() {
  _impl_.app_id_.ClearToEmpty();
}
inline const std::string& DeleteIdentityRequest::app_id() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.DeleteIdentityRequest.app_id)
  return _internal_app_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DeleteIdentityRequest::set_app_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.app_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ownmfa.api.DeleteIdentityRequest.app_id)
}
inline std::string* DeleteIdentityRequest::mutable_app_id() {
  std::string* _s = _internal_mutable_app_id();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.DeleteIdentityRequest.app_id)
  return _s;
}
inline const std::string& DeleteIdentityRequest::_internal_app_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.app_id_.Get();
}
inline void DeleteIdentityRequest::_internal_set_app_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.app_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteIdentityRequest::_internal_mutable_app_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.app_id_.Mutable( GetArenaForAllocation());
}
inline std::string* DeleteIdentityRequest::release_app_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ownmfa.api.DeleteIdentityRequest.app_id)
  return _impl_.app_id_.Release();
}
inline void DeleteIdentityRequest::set_allocated_app_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.app_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.app_id_.IsDefault()) {
          _impl_.app_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.DeleteIdentityRequest.app_id)
}

// -------------------------------------------------------------------

// ListIdentitiesRequest

// int32 page_size = 1 [(.validate.rules) = {
inline void ListIdentitiesRequest::clear_page_size() {
  _impl_.page_size_ = 0;
}
inline ::int32_t ListIdentitiesRequest::page_size() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.ListIdentitiesRequest.page_size)
  return _internal_page_size();
}
inline void ListIdentitiesRequest::set_page_size(::int32_t value) {
  _internal_set_page_size(value);
  // @@protoc_insertion_point(field_set:ownmfa.api.ListIdentitiesRequest.page_size)
}
inline ::int32_t ListIdentitiesRequest::_internal_page_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.page_size_;
}
inline void ListIdentitiesRequest::_internal_set_page_size(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.page_size_ = value;
}

// string page_token = 2;
inline void ListIdentitiesRequest::clear_page_token() {
  _impl_.page_token_.ClearToEmpty();
}
inline const std::string& ListIdentitiesRequest::page_token() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.ListIdentitiesRequest.page_token)
  return _internal_page_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ListIdentitiesRequest::set_page_token(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.page_token_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ownmfa.api.ListIdentitiesRequest.page_token)
}
inline std::string* ListIdentitiesRequest::mutable_page_token() {
  std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.ListIdentitiesRequest.page_token)
  return _s;
}
inline const std::string& ListIdentitiesRequest::_internal_page_token() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.page_token_.Get();
}
inline void ListIdentitiesRequest::_internal_set_page_token(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListIdentitiesRequest::_internal_mutable_page_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.page_token_.Mutable( GetArenaForAllocation());
}
inline std::string* ListIdentitiesRequest::release_page_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ownmfa.api.ListIdentitiesRequest.page_token)
  return _impl_.page_token_.Release();
}
inline void ListIdentitiesRequest::set_allocated_page_token(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.page_token_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.page_token_.IsDefault()) {
          _impl_.page_token_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.ListIdentitiesRequest.page_token)
}

// string app_id = 3 [json_name = "appID", (.validate.rules) = {
inline void ListIdentitiesRequest::clear_app_id() {
  _impl_.app_id_.ClearToEmpty();
}
inline const std::string& ListIdentitiesRequest::app_id() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.ListIdentitiesRequest.app_id)
  return _internal_app_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ListIdentitiesRequest::set_app_id(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.app_id_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ownmfa.api.ListIdentitiesRequest.app_id)
}
inline std::string* ListIdentitiesRequest::mutable_app_id() {
  std::string* _s = _internal_mutable_app_id();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.ListIdentitiesRequest.app_id)
  return _s;
}
inline const std::string& ListIdentitiesRequest::_internal_app_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.app_id_.Get();
}
inline void ListIdentitiesRequest::_internal_set_app_id(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.app_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ListIdentitiesRequest::_internal_mutable_app_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.app_id_.Mutable( GetArenaForAllocation());
}
inline std::string* ListIdentitiesRequest::release_app_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ownmfa.api.ListIdentitiesRequest.app_id)
  return _impl_.app_id_.Release();
}
inline void ListIdentitiesRequest::set_allocated_app_id(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.app_id_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.app_id_.IsDefault()) {
          _impl_.app_id_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.ListIdentitiesRequest.app_id)
}

// -------------------------------------------------------------------

// ListIdentitiesResponse

// repeated .ownmfa.api.Identity identities = 1;
inline int ListIdentitiesResponse::_internal_identities_size() const {
  return _internal_identities().size();
}
inline int ListIdentitiesResponse::identities_size() const {
  return _internal_identities_size();
}
inline void ListIdentitiesResponse::clear_identities() {
  _internal_mutable_identities()->Clear();
}
inline ::ownmfa::api::Identity* ListIdentitiesResponse::mutable_identities(int index) {
  // @@protoc_insertion_point(field_mutable:ownmfa.api.ListIdentitiesResponse.identities)
  return _internal_mutable_identities()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ownmfa::api::Identity >*
ListIdentitiesResponse::mutable_identities() {
  // @@protoc_insertion_point(field_mutable_list:ownmfa.api.ListIdentitiesResponse.identities)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_identities();
}
inline const ::ownmfa::api::Identity& ListIdentitiesResponse::identities(int index) const {
  // @@protoc_insertion_point(field_get:ownmfa.api.ListIdentitiesResponse.identities)
    return _internal_identities().Get(index);
}
inline ::ownmfa::api::Identity* ListIdentitiesResponse::add_identities() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::ownmfa::api::Identity* _add = _internal_mutable_identities()->Add();
  // @@protoc_insertion_point(field_add:ownmfa.api.ListIdentitiesResponse.identities)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::ownmfa::api::Identity >&
ListIdentitiesResponse::identities() const {
  // @@protoc_insertion_point(field_list:ownmfa.api.ListIdentitiesResponse.identities)
  return _internal_identities();
}
inline const ::google::protobuf::RepeatedPtrField<::ownmfa::api::Identity>&
ListIdentitiesResponse::_internal_identities() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.identities_;
}
inline ::google::protobuf::RepeatedPtrField<::ownmfa::api::Identity>*
ListIdentitiesResponse::_internal_mutable_identities() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.identities_;
}

// string next_page_token = 2;
inline void ListIdentitiesResponse::clear_next_page_token() {
  _impl_.next_page_token_.ClearToEmpty();
}
inline const std::string& ListIdentitiesResponse::next_page_token() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.ListIdentitiesResponse.next_page_token)
  return _internal_next_page_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ListIdentitiesResponse::set_next_page_token(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.next_page_token_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ownmfa.api.ListIdentitiesResponse.next_page_token)
}
inline std::string* ListIdentitiesResponse::mutable_next_page_token() {
  std::string* _s = _internal_mutable_next_page_token();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.ListIdentitiesResponse.next_page_token)
  return _s;
}
inline const std::string& ListIdentitiesResponse::_internal_next_page_token() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.next_page_token_.Get();
}
inline void ListIdentitiesResponse::_internal_set_next_page_token(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.next_page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* ListIdentitiesResponse::_internal_mutable_next_page_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.next_page_token_.Mutable( GetArenaForAllocation());
}
inline std::string* ListIdentitiesResponse::release_next_page_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:ownmfa.api.ListIdentitiesResponse.next_page_token)
  return _impl_.next_page_token_.Release();
}
inline void ListIdentitiesResponse::set_allocated_next_page_token(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.next_page_token_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.next_page_token_.IsDefault()) {
          _impl_.next_page_token_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.ListIdentitiesResponse.next_page_token)
}

// int32 total_size = 3;
inline void ListIdentitiesResponse::clear_total_size() {
  _impl_.total_size_ = 0;
}
inline ::int32_t ListIdentitiesResponse::total_size() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.ListIdentitiesResponse.total_size)
  return _internal_total_size();
}
inline void ListIdentitiesResponse::set_total_size(::int32_t value) {
  _internal_set_total_size(value);
  // @@protoc_insertion_point(field_set:ownmfa.api.ListIdentitiesResponse.total_size)
}
inline ::int32_t ListIdentitiesResponse::_internal_total_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.total_size_;
}
inline void ListIdentitiesResponse::_internal_set_total_size(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.total_size_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace api
}  // namespace ownmfa


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::ownmfa::api::IdentityStatus> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::ownmfa::api::IdentityStatus>() {
  return ::ownmfa::api::IdentityStatus_descriptor();
}
template <>
struct is_proto_enum<::ownmfa::api::Hash> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::ownmfa::api::Hash>() {
  return ::ownmfa::api::Hash_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_api_2fownmfa_5fapp_5fidentity_2eproto_2epb_2eh
