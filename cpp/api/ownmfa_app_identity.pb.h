// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: api/ownmfa_app_identity.proto
// Protobuf C++ Version: 5.29.4

#ifndef api_2fownmfa_5fapp_5fidentity_2eproto_2epb_2eh
#define api_2fownmfa_5fapp_5fidentity_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029004
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/empty.pb.h"
#include "google/protobuf/timestamp.pb.h"
#include "google/protobuf/field_mask.pb.h"
#include "google/api/annotations.pb.h"
#include "google/api/field_behavior.pb.h"
#include "protoc-gen-openapiv2/options/annotations.pb.h"
#include "validate/validate.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_api_2fownmfa_5fapp_5fidentity_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_api_2fownmfa_5fapp_5fidentity_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_api_2fownmfa_5fapp_5fidentity_2eproto;
namespace ownmfa {
namespace api {
class ActivateIdentityRequest;
struct ActivateIdentityRequestDefaultTypeInternal;
extern ActivateIdentityRequestDefaultTypeInternal _ActivateIdentityRequest_default_instance_;
class App;
struct AppDefaultTypeInternal;
extern AppDefaultTypeInternal _App_default_instance_;
class AppleiOSTOTPMethod;
struct AppleiOSTOTPMethodDefaultTypeInternal;
extern AppleiOSTOTPMethodDefaultTypeInternal _AppleiOSTOTPMethod_default_instance_;
class BackupsCodesMethod;
struct BackupsCodesMethodDefaultTypeInternal;
extern BackupsCodesMethodDefaultTypeInternal _BackupsCodesMethod_default_instance_;
class ChallengeIdentityRequest;
struct ChallengeIdentityRequestDefaultTypeInternal;
extern ChallengeIdentityRequestDefaultTypeInternal _ChallengeIdentityRequest_default_instance_;
class CreateAppRequest;
struct CreateAppRequestDefaultTypeInternal;
extern CreateAppRequestDefaultTypeInternal _CreateAppRequest_default_instance_;
class CreateIdentityRequest;
struct CreateIdentityRequestDefaultTypeInternal;
extern CreateIdentityRequestDefaultTypeInternal _CreateIdentityRequest_default_instance_;
class CreateIdentityResponse;
struct CreateIdentityResponseDefaultTypeInternal;
extern CreateIdentityResponseDefaultTypeInternal _CreateIdentityResponse_default_instance_;
class DeleteAppRequest;
struct DeleteAppRequestDefaultTypeInternal;
extern DeleteAppRequestDefaultTypeInternal _DeleteAppRequest_default_instance_;
class DeleteIdentityRequest;
struct DeleteIdentityRequestDefaultTypeInternal;
extern DeleteIdentityRequestDefaultTypeInternal _DeleteIdentityRequest_default_instance_;
class EmailMethod;
struct EmailMethodDefaultTypeInternal;
extern EmailMethodDefaultTypeInternal _EmailMethod_default_instance_;
class GetAppRequest;
struct GetAppRequestDefaultTypeInternal;
extern GetAppRequestDefaultTypeInternal _GetAppRequest_default_instance_;
class GetIdentityRequest;
struct GetIdentityRequestDefaultTypeInternal;
extern GetIdentityRequestDefaultTypeInternal _GetIdentityRequest_default_instance_;
class GoogleAuthHOTPMethod;
struct GoogleAuthHOTPMethodDefaultTypeInternal;
extern GoogleAuthHOTPMethodDefaultTypeInternal _GoogleAuthHOTPMethod_default_instance_;
class GoogleAuthTOTPMethod;
struct GoogleAuthTOTPMethodDefaultTypeInternal;
extern GoogleAuthTOTPMethodDefaultTypeInternal _GoogleAuthTOTPMethod_default_instance_;
class HardwareHOTPMethod;
struct HardwareHOTPMethodDefaultTypeInternal;
extern HardwareHOTPMethodDefaultTypeInternal _HardwareHOTPMethod_default_instance_;
class HardwareTOTPMethod;
struct HardwareTOTPMethodDefaultTypeInternal;
extern HardwareTOTPMethodDefaultTypeInternal _HardwareTOTPMethod_default_instance_;
class Identity;
struct IdentityDefaultTypeInternal;
extern IdentityDefaultTypeInternal _Identity_default_instance_;
class ListAppsRequest;
struct ListAppsRequestDefaultTypeInternal;
extern ListAppsRequestDefaultTypeInternal _ListAppsRequest_default_instance_;
class ListAppsResponse;
struct ListAppsResponseDefaultTypeInternal;
extern ListAppsResponseDefaultTypeInternal _ListAppsResponse_default_instance_;
class ListIdentitiesRequest;
struct ListIdentitiesRequestDefaultTypeInternal;
extern ListIdentitiesRequestDefaultTypeInternal _ListIdentitiesRequest_default_instance_;
class ListIdentitiesResponse;
struct ListIdentitiesResponseDefaultTypeInternal;
extern ListIdentitiesResponseDefaultTypeInternal _ListIdentitiesResponse_default_instance_;
class PushoverMethod;
struct PushoverMethodDefaultTypeInternal;
extern PushoverMethodDefaultTypeInternal _PushoverMethod_default_instance_;
class SMSMethod;
struct SMSMethodDefaultTypeInternal;
extern SMSMethodDefaultTypeInternal _SMSMethod_default_instance_;
class SecurityQuestionsMethod;
struct SecurityQuestionsMethodDefaultTypeInternal;
extern SecurityQuestionsMethodDefaultTypeInternal _SecurityQuestionsMethod_default_instance_;
class SoftwareHOTPMethod;
struct SoftwareHOTPMethodDefaultTypeInternal;
extern SoftwareHOTPMethodDefaultTypeInternal _SoftwareHOTPMethod_default_instance_;
class SoftwareTOTPMethod;
struct SoftwareTOTPMethodDefaultTypeInternal;
extern SoftwareTOTPMethodDefaultTypeInternal _SoftwareTOTPMethod_default_instance_;
class UpdateAppRequest;
struct UpdateAppRequestDefaultTypeInternal;
extern UpdateAppRequestDefaultTypeInternal _UpdateAppRequest_default_instance_;
class VerifyIdentityRequest;
struct VerifyIdentityRequestDefaultTypeInternal;
extern VerifyIdentityRequestDefaultTypeInternal _VerifyIdentityRequest_default_instance_;
}  // namespace api
}  // namespace ownmfa
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace ownmfa {
namespace api {
enum IdentityStatus : int {
  UNVERIFIED = 0,
  ACTIVATED = 3,
  IdentityStatus_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  IdentityStatus_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool IdentityStatus_IsValid(int value);
extern const uint32_t IdentityStatus_internal_data_[];
constexpr IdentityStatus IdentityStatus_MIN = static_cast<IdentityStatus>(0);
constexpr IdentityStatus IdentityStatus_MAX = static_cast<IdentityStatus>(3);
constexpr int IdentityStatus_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
IdentityStatus_descriptor();
template <typename T>
const std::string& IdentityStatus_Name(T value) {
  static_assert(std::is_same<T, IdentityStatus>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to IdentityStatus_Name().");
  return IdentityStatus_Name(static_cast<IdentityStatus>(value));
}
template <>
inline const std::string& IdentityStatus_Name(IdentityStatus value) {
  return ::google::protobuf::internal::NameOfDenseEnum<IdentityStatus_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool IdentityStatus_Parse(absl::string_view name, IdentityStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<IdentityStatus>(
      IdentityStatus_descriptor(), name, value);
}
enum Hash : int {
  SHA512 = 0,
  SHA256 = 1,
  SHA1 = 2,
  Hash_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Hash_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Hash_IsValid(int value);
extern const uint32_t Hash_internal_data_[];
constexpr Hash Hash_MIN = static_cast<Hash>(0);
constexpr Hash Hash_MAX = static_cast<Hash>(2);
constexpr int Hash_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
Hash_descriptor();
template <typename T>
const std::string& Hash_Name(T value) {
  static_assert(std::is_same<T, Hash>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Hash_Name().");
  return Hash_Name(static_cast<Hash>(value));
}
template <>
inline const std::string& Hash_Name(Hash value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Hash_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool Hash_Parse(absl::string_view name, Hash* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Hash>(
      Hash_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class VerifyIdentityRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ownmfa.api.VerifyIdentityRequest) */ {
 public:
  inline VerifyIdentityRequest() : VerifyIdentityRequest(nullptr) {}
  ~VerifyIdentityRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(VerifyIdentityRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(VerifyIdentityRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR VerifyIdentityRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline VerifyIdentityRequest(const VerifyIdentityRequest& from) : VerifyIdentityRequest(nullptr, from) {}
  inline VerifyIdentityRequest(VerifyIdentityRequest&& from) noexcept
      : VerifyIdentityRequest(nullptr, std::move(from)) {}
  inline VerifyIdentityRequest& operator=(const VerifyIdentityRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline VerifyIdentityRequest& operator=(VerifyIdentityRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VerifyIdentityRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const VerifyIdentityRequest* internal_default_instance() {
    return reinterpret_cast<const VerifyIdentityRequest*>(
        &_VerifyIdentityRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 24;
  friend void swap(VerifyIdentityRequest& a, VerifyIdentityRequest& b) { a.Swap(&b); }
  inline void Swap(VerifyIdentityRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VerifyIdentityRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VerifyIdentityRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<VerifyIdentityRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VerifyIdentityRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const VerifyIdentityRequest& from) { VerifyIdentityRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(VerifyIdentityRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ownmfa.api.VerifyIdentityRequest"; }

 protected:
  explicit VerifyIdentityRequest(::google::protobuf::Arena* arena);
  VerifyIdentityRequest(::google::protobuf::Arena* arena, const VerifyIdentityRequest& from);
  VerifyIdentityRequest(::google::protobuf::Arena* arena, VerifyIdentityRequest&& from) noexcept
      : VerifyIdentityRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kAppIdFieldNumber = 2,
    kPasscodeFieldNumber = 3,
  };
  // string id = 1 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string app_id = 2 [json_name = "appID", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  void clear_app_id() ;
  const std::string& app_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_app_id(Arg_&& arg, Args_... args);
  std::string* mutable_app_id();
  PROTOBUF_NODISCARD std::string* release_app_id();
  void set_allocated_app_id(std::string* value);

  private:
  const std::string& _internal_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_id(
      const std::string& value);
  std::string* _internal_mutable_app_id();

  public:
  // string passcode = 3 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  void clear_passcode() ;
  const std::string& passcode() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_passcode(Arg_&& arg, Args_... args);
  std::string* mutable_passcode();
  PROTOBUF_NODISCARD std::string* release_passcode();
  void set_allocated_passcode(std::string* value);

  private:
  const std::string& _internal_passcode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_passcode(
      const std::string& value);
  std::string* _internal_mutable_passcode();

  public:
  // @@protoc_insertion_point(class_scope:ownmfa.api.VerifyIdentityRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      57, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const VerifyIdentityRequest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr app_id_;
    ::google::protobuf::internal::ArenaStringPtr passcode_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fownmfa_5fapp_5fidentity_2eproto;
};
// -------------------------------------------------------------------

class SoftwareTOTPMethod final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ownmfa.api.SoftwareTOTPMethod) */ {
 public:
  inline SoftwareTOTPMethod() : SoftwareTOTPMethod(nullptr) {}
  ~SoftwareTOTPMethod() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SoftwareTOTPMethod* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SoftwareTOTPMethod));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SoftwareTOTPMethod(
      ::google::protobuf::internal::ConstantInitialized);

  inline SoftwareTOTPMethod(const SoftwareTOTPMethod& from) : SoftwareTOTPMethod(nullptr, from) {}
  inline SoftwareTOTPMethod(SoftwareTOTPMethod&& from) noexcept
      : SoftwareTOTPMethod(nullptr, std::move(from)) {}
  inline SoftwareTOTPMethod& operator=(const SoftwareTOTPMethod& from) {
    CopyFrom(from);
    return *this;
  }
  inline SoftwareTOTPMethod& operator=(SoftwareTOTPMethod&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SoftwareTOTPMethod& default_instance() {
    return *internal_default_instance();
  }
  static inline const SoftwareTOTPMethod* internal_default_instance() {
    return reinterpret_cast<const SoftwareTOTPMethod*>(
        &_SoftwareTOTPMethod_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(SoftwareTOTPMethod& a, SoftwareTOTPMethod& b) { a.Swap(&b); }
  inline void Swap(SoftwareTOTPMethod* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SoftwareTOTPMethod* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SoftwareTOTPMethod* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SoftwareTOTPMethod>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SoftwareTOTPMethod& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SoftwareTOTPMethod& from) { SoftwareTOTPMethod::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SoftwareTOTPMethod* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ownmfa.api.SoftwareTOTPMethod"; }

 protected:
  explicit SoftwareTOTPMethod(::google::protobuf::Arena* arena);
  SoftwareTOTPMethod(::google::protobuf::Arena* arena, const SoftwareTOTPMethod& from);
  SoftwareTOTPMethod(::google::protobuf::Arena* arena, SoftwareTOTPMethod&& from) noexcept
      : SoftwareTOTPMethod(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAccountNameFieldNumber = 3,
    kHashFieldNumber = 1,
    kDigitsFieldNumber = 2,
  };
  // string account_name = 3 [(.validate.rules) = {
  void clear_account_name() ;
  const std::string& account_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_account_name(Arg_&& arg, Args_... args);
  std::string* mutable_account_name();
  PROTOBUF_NODISCARD std::string* release_account_name();
  void set_allocated_account_name(std::string* value);

  private:
  const std::string& _internal_account_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account_name(
      const std::string& value);
  std::string* _internal_mutable_account_name();

  public:
  // .ownmfa.api.Hash hash = 1;
  void clear_hash() ;
  ::ownmfa::api::Hash hash() const;
  void set_hash(::ownmfa::api::Hash value);

  private:
  ::ownmfa::api::Hash _internal_hash() const;
  void _internal_set_hash(::ownmfa::api::Hash value);

  public:
  // int32 digits = 2 [(.validate.rules) = {
  void clear_digits() ;
  ::int32_t digits() const;
  void set_digits(::int32_t value);

  private:
  ::int32_t _internal_digits() const;
  void _internal_set_digits(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:ownmfa.api.SoftwareTOTPMethod)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      50, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SoftwareTOTPMethod& from_msg);
    ::google::protobuf::internal::ArenaStringPtr account_name_;
    int hash_;
    ::int32_t digits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fownmfa_5fapp_5fidentity_2eproto;
};
// -------------------------------------------------------------------

class SoftwareHOTPMethod final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ownmfa.api.SoftwareHOTPMethod) */ {
 public:
  inline SoftwareHOTPMethod() : SoftwareHOTPMethod(nullptr) {}
  ~SoftwareHOTPMethod() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SoftwareHOTPMethod* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SoftwareHOTPMethod));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SoftwareHOTPMethod(
      ::google::protobuf::internal::ConstantInitialized);

  inline SoftwareHOTPMethod(const SoftwareHOTPMethod& from) : SoftwareHOTPMethod(nullptr, from) {}
  inline SoftwareHOTPMethod(SoftwareHOTPMethod&& from) noexcept
      : SoftwareHOTPMethod(nullptr, std::move(from)) {}
  inline SoftwareHOTPMethod& operator=(const SoftwareHOTPMethod& from) {
    CopyFrom(from);
    return *this;
  }
  inline SoftwareHOTPMethod& operator=(SoftwareHOTPMethod&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SoftwareHOTPMethod& default_instance() {
    return *internal_default_instance();
  }
  static inline const SoftwareHOTPMethod* internal_default_instance() {
    return reinterpret_cast<const SoftwareHOTPMethod*>(
        &_SoftwareHOTPMethod_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(SoftwareHOTPMethod& a, SoftwareHOTPMethod& b) { a.Swap(&b); }
  inline void Swap(SoftwareHOTPMethod* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SoftwareHOTPMethod* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SoftwareHOTPMethod* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SoftwareHOTPMethod>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SoftwareHOTPMethod& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SoftwareHOTPMethod& from) { SoftwareHOTPMethod::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SoftwareHOTPMethod* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ownmfa.api.SoftwareHOTPMethod"; }

 protected:
  explicit SoftwareHOTPMethod(::google::protobuf::Arena* arena);
  SoftwareHOTPMethod(::google::protobuf::Arena* arena, const SoftwareHOTPMethod& from);
  SoftwareHOTPMethod(::google::protobuf::Arena* arena, SoftwareHOTPMethod&& from) noexcept
      : SoftwareHOTPMethod(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAccountNameFieldNumber = 4,
    kHashFieldNumber = 1,
    kDigitsFieldNumber = 2,
    kCounterFieldNumber = 3,
  };
  // string account_name = 4 [(.validate.rules) = {
  void clear_account_name() ;
  const std::string& account_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_account_name(Arg_&& arg, Args_... args);
  std::string* mutable_account_name();
  PROTOBUF_NODISCARD std::string* release_account_name();
  void set_allocated_account_name(std::string* value);

  private:
  const std::string& _internal_account_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account_name(
      const std::string& value);
  std::string* _internal_mutable_account_name();

  public:
  // .ownmfa.api.Hash hash = 1;
  void clear_hash() ;
  ::ownmfa::api::Hash hash() const;
  void set_hash(::ownmfa::api::Hash value);

  private:
  ::ownmfa::api::Hash _internal_hash() const;
  void _internal_set_hash(::ownmfa::api::Hash value);

  public:
  // int32 digits = 2 [(.validate.rules) = {
  void clear_digits() ;
  ::int32_t digits() const;
  void set_digits(::int32_t value);

  private:
  ::int32_t _internal_digits() const;
  void _internal_set_digits(::int32_t value);

  public:
  // int32 counter = 3;
  void clear_counter() ;
  ::int32_t counter() const;
  void set_counter(::int32_t value);

  private:
  ::int32_t _internal_counter() const;
  void _internal_set_counter(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:ownmfa.api.SoftwareHOTPMethod)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      50, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SoftwareHOTPMethod& from_msg);
    ::google::protobuf::internal::ArenaStringPtr account_name_;
    int hash_;
    ::int32_t digits_;
    ::int32_t counter_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fownmfa_5fapp_5fidentity_2eproto;
};
// -------------------------------------------------------------------

class SecurityQuestionsMethod final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ownmfa.api.SecurityQuestionsMethod) */ {
 public:
  inline SecurityQuestionsMethod() : SecurityQuestionsMethod(nullptr) {}
  ~SecurityQuestionsMethod() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SecurityQuestionsMethod* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SecurityQuestionsMethod));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SecurityQuestionsMethod(
      ::google::protobuf::internal::ConstantInitialized);

  inline SecurityQuestionsMethod(const SecurityQuestionsMethod& from) : SecurityQuestionsMethod(nullptr, from) {}
  inline SecurityQuestionsMethod(SecurityQuestionsMethod&& from) noexcept
      : SecurityQuestionsMethod(nullptr, std::move(from)) {}
  inline SecurityQuestionsMethod& operator=(const SecurityQuestionsMethod& from) {
    CopyFrom(from);
    return *this;
  }
  inline SecurityQuestionsMethod& operator=(SecurityQuestionsMethod&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SecurityQuestionsMethod& default_instance() {
    return *internal_default_instance();
  }
  static inline const SecurityQuestionsMethod* internal_default_instance() {
    return reinterpret_cast<const SecurityQuestionsMethod*>(
        &_SecurityQuestionsMethod_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(SecurityQuestionsMethod& a, SecurityQuestionsMethod& b) { a.Swap(&b); }
  inline void Swap(SecurityQuestionsMethod* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SecurityQuestionsMethod* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SecurityQuestionsMethod* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SecurityQuestionsMethod>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SecurityQuestionsMethod& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SecurityQuestionsMethod& from) { SecurityQuestionsMethod::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SecurityQuestionsMethod* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ownmfa.api.SecurityQuestionsMethod"; }

 protected:
  explicit SecurityQuestionsMethod(::google::protobuf::Arena* arena);
  SecurityQuestionsMethod(::google::protobuf::Arena* arena, const SecurityQuestionsMethod& from);
  SecurityQuestionsMethod(::google::protobuf::Arena* arena, SecurityQuestionsMethod&& from) noexcept
      : SecurityQuestionsMethod(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAnswerFieldNumber = 1,
  };
  // string answer = 1 [(.validate.rules) = {
  void clear_answer() ;
  const std::string& answer() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_answer(Arg_&& arg, Args_... args);
  std::string* mutable_answer();
  PROTOBUF_NODISCARD std::string* release_answer();
  void set_allocated_answer(std::string* value);

  private:
  const std::string& _internal_answer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_answer(
      const std::string& value);
  std::string* _internal_mutable_answer();

  public:
  // @@protoc_insertion_point(class_scope:ownmfa.api.SecurityQuestionsMethod)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      49, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SecurityQuestionsMethod& from_msg);
    ::google::protobuf::internal::ArenaStringPtr answer_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fownmfa_5fapp_5fidentity_2eproto;
};
// -------------------------------------------------------------------

class SMSMethod final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ownmfa.api.SMSMethod) */ {
 public:
  inline SMSMethod() : SMSMethod(nullptr) {}
  ~SMSMethod() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SMSMethod* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SMSMethod));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SMSMethod(
      ::google::protobuf::internal::ConstantInitialized);

  inline SMSMethod(const SMSMethod& from) : SMSMethod(nullptr, from) {}
  inline SMSMethod(SMSMethod&& from) noexcept
      : SMSMethod(nullptr, std::move(from)) {}
  inline SMSMethod& operator=(const SMSMethod& from) {
    CopyFrom(from);
    return *this;
  }
  inline SMSMethod& operator=(SMSMethod&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SMSMethod& default_instance() {
    return *internal_default_instance();
  }
  static inline const SMSMethod* internal_default_instance() {
    return reinterpret_cast<const SMSMethod*>(
        &_SMSMethod_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(SMSMethod& a, SMSMethod& b) { a.Swap(&b); }
  inline void Swap(SMSMethod* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SMSMethod* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SMSMethod* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SMSMethod>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SMSMethod& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SMSMethod& from) { SMSMethod::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SMSMethod* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ownmfa.api.SMSMethod"; }

 protected:
  explicit SMSMethod(::google::protobuf::Arena* arena);
  SMSMethod(::google::protobuf::Arena* arena, const SMSMethod& from);
  SMSMethod(::google::protobuf::Arena* arena, SMSMethod&& from) noexcept
      : SMSMethod(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPhoneFieldNumber = 1,
  };
  // string phone = 1 [(.validate.rules) = {
  void clear_phone() ;
  const std::string& phone() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_phone(Arg_&& arg, Args_... args);
  std::string* mutable_phone();
  PROTOBUF_NODISCARD std::string* release_phone();
  void set_allocated_phone(std::string* value);

  private:
  const std::string& _internal_phone() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_phone(
      const std::string& value);
  std::string* _internal_mutable_phone();

  public:
  // @@protoc_insertion_point(class_scope:ownmfa.api.SMSMethod)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      34, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SMSMethod& from_msg);
    ::google::protobuf::internal::ArenaStringPtr phone_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fownmfa_5fapp_5fidentity_2eproto;
};
// -------------------------------------------------------------------

class PushoverMethod final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ownmfa.api.PushoverMethod) */ {
 public:
  inline PushoverMethod() : PushoverMethod(nullptr) {}
  ~PushoverMethod() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PushoverMethod* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PushoverMethod));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PushoverMethod(
      ::google::protobuf::internal::ConstantInitialized);

  inline PushoverMethod(const PushoverMethod& from) : PushoverMethod(nullptr, from) {}
  inline PushoverMethod(PushoverMethod&& from) noexcept
      : PushoverMethod(nullptr, std::move(from)) {}
  inline PushoverMethod& operator=(const PushoverMethod& from) {
    CopyFrom(from);
    return *this;
  }
  inline PushoverMethod& operator=(PushoverMethod&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PushoverMethod& default_instance() {
    return *internal_default_instance();
  }
  static inline const PushoverMethod* internal_default_instance() {
    return reinterpret_cast<const PushoverMethod*>(
        &_PushoverMethod_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(PushoverMethod& a, PushoverMethod& b) { a.Swap(&b); }
  inline void Swap(PushoverMethod* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PushoverMethod* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PushoverMethod* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PushoverMethod>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PushoverMethod& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PushoverMethod& from) { PushoverMethod::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PushoverMethod* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ownmfa.api.PushoverMethod"; }

 protected:
  explicit PushoverMethod(::google::protobuf::Arena* arena);
  PushoverMethod(::google::protobuf::Arena* arena, const PushoverMethod& from);
  PushoverMethod(::google::protobuf::Arena* arena, PushoverMethod&& from) noexcept
      : PushoverMethod(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPushoverKeyFieldNumber = 1,
  };
  // string pushover_key = 1 [(.validate.rules) = {
  void clear_pushover_key() ;
  const std::string& pushover_key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_pushover_key(Arg_&& arg, Args_... args);
  std::string* mutable_pushover_key();
  PROTOBUF_NODISCARD std::string* release_pushover_key();
  void set_allocated_pushover_key(std::string* value);

  private:
  const std::string& _internal_pushover_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pushover_key(
      const std::string& value);
  std::string* _internal_mutable_pushover_key();

  public:
  // @@protoc_insertion_point(class_scope:ownmfa.api.PushoverMethod)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      46, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PushoverMethod& from_msg);
    ::google::protobuf::internal::ArenaStringPtr pushover_key_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fownmfa_5fapp_5fidentity_2eproto;
};
// -------------------------------------------------------------------

class ListIdentitiesRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ownmfa.api.ListIdentitiesRequest) */ {
 public:
  inline ListIdentitiesRequest() : ListIdentitiesRequest(nullptr) {}
  ~ListIdentitiesRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ListIdentitiesRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ListIdentitiesRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ListIdentitiesRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline ListIdentitiesRequest(const ListIdentitiesRequest& from) : ListIdentitiesRequest(nullptr, from) {}
  inline ListIdentitiesRequest(ListIdentitiesRequest&& from) noexcept
      : ListIdentitiesRequest(nullptr, std::move(from)) {}
  inline ListIdentitiesRequest& operator=(const ListIdentitiesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListIdentitiesRequest& operator=(ListIdentitiesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListIdentitiesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListIdentitiesRequest* internal_default_instance() {
    return reinterpret_cast<const ListIdentitiesRequest*>(
        &_ListIdentitiesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 27;
  friend void swap(ListIdentitiesRequest& a, ListIdentitiesRequest& b) { a.Swap(&b); }
  inline void Swap(ListIdentitiesRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListIdentitiesRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListIdentitiesRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ListIdentitiesRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListIdentitiesRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ListIdentitiesRequest& from) { ListIdentitiesRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ListIdentitiesRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ownmfa.api.ListIdentitiesRequest"; }

 protected:
  explicit ListIdentitiesRequest(::google::protobuf::Arena* arena);
  ListIdentitiesRequest(::google::protobuf::Arena* arena, const ListIdentitiesRequest& from);
  ListIdentitiesRequest(::google::protobuf::Arena* arena, ListIdentitiesRequest&& from) noexcept
      : ListIdentitiesRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPageTokenFieldNumber = 2,
    kAppIdFieldNumber = 3,
    kPageSizeFieldNumber = 1,
  };
  // string page_token = 2;
  void clear_page_token() ;
  const std::string& page_token() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_page_token(Arg_&& arg, Args_... args);
  std::string* mutable_page_token();
  PROTOBUF_NODISCARD std::string* release_page_token();
  void set_allocated_page_token(std::string* value);

  private:
  const std::string& _internal_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(
      const std::string& value);
  std::string* _internal_mutable_page_token();

  public:
  // string app_id = 3 [json_name = "appID", (.validate.rules) = {
  void clear_app_id() ;
  const std::string& app_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_app_id(Arg_&& arg, Args_... args);
  std::string* mutable_app_id();
  PROTOBUF_NODISCARD std::string* release_app_id();
  void set_allocated_app_id(std::string* value);

  private:
  const std::string& _internal_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_id(
      const std::string& value);
  std::string* _internal_mutable_app_id();

  public:
  // int32 page_size = 1 [(.validate.rules) = {
  void clear_page_size() ;
  ::int32_t page_size() const;
  void set_page_size(::int32_t value);

  private:
  ::int32_t _internal_page_size() const;
  void _internal_set_page_size(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:ownmfa.api.ListIdentitiesRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      57, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ListIdentitiesRequest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr page_token_;
    ::google::protobuf::internal::ArenaStringPtr app_id_;
    ::int32_t page_size_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fownmfa_5fapp_5fidentity_2eproto;
};
// -------------------------------------------------------------------

class ListAppsRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ownmfa.api.ListAppsRequest) */ {
 public:
  inline ListAppsRequest() : ListAppsRequest(nullptr) {}
  ~ListAppsRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ListAppsRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ListAppsRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ListAppsRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline ListAppsRequest(const ListAppsRequest& from) : ListAppsRequest(nullptr, from) {}
  inline ListAppsRequest(ListAppsRequest&& from) noexcept
      : ListAppsRequest(nullptr, std::move(from)) {}
  inline ListAppsRequest& operator=(const ListAppsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListAppsRequest& operator=(ListAppsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListAppsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListAppsRequest* internal_default_instance() {
    return reinterpret_cast<const ListAppsRequest*>(
        &_ListAppsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(ListAppsRequest& a, ListAppsRequest& b) { a.Swap(&b); }
  inline void Swap(ListAppsRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListAppsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListAppsRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ListAppsRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListAppsRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ListAppsRequest& from) { ListAppsRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ListAppsRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ownmfa.api.ListAppsRequest"; }

 protected:
  explicit ListAppsRequest(::google::protobuf::Arena* arena);
  ListAppsRequest(::google::protobuf::Arena* arena, const ListAppsRequest& from);
  ListAppsRequest(::google::protobuf::Arena* arena, ListAppsRequest&& from) noexcept
      : ListAppsRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPageTokenFieldNumber = 2,
    kPageSizeFieldNumber = 1,
  };
  // string page_token = 2;
  void clear_page_token() ;
  const std::string& page_token() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_page_token(Arg_&& arg, Args_... args);
  std::string* mutable_page_token();
  PROTOBUF_NODISCARD std::string* release_page_token();
  void set_allocated_page_token(std::string* value);

  private:
  const std::string& _internal_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_token(
      const std::string& value);
  std::string* _internal_mutable_page_token();

  public:
  // int32 page_size = 1 [(.validate.rules) = {
  void clear_page_size() ;
  ::int32_t page_size() const;
  void set_page_size(::int32_t value);

  private:
  ::int32_t _internal_page_size() const;
  void _internal_set_page_size(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:ownmfa.api.ListAppsRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      45, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ListAppsRequest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr page_token_;
    ::int32_t page_size_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fownmfa_5fapp_5fidentity_2eproto;
};
// -------------------------------------------------------------------

class HardwareTOTPMethod final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ownmfa.api.HardwareTOTPMethod) */ {
 public:
  inline HardwareTOTPMethod() : HardwareTOTPMethod(nullptr) {}
  ~HardwareTOTPMethod() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(HardwareTOTPMethod* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(HardwareTOTPMethod));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HardwareTOTPMethod(
      ::google::protobuf::internal::ConstantInitialized);

  inline HardwareTOTPMethod(const HardwareTOTPMethod& from) : HardwareTOTPMethod(nullptr, from) {}
  inline HardwareTOTPMethod(HardwareTOTPMethod&& from) noexcept
      : HardwareTOTPMethod(nullptr, std::move(from)) {}
  inline HardwareTOTPMethod& operator=(const HardwareTOTPMethod& from) {
    CopyFrom(from);
    return *this;
  }
  inline HardwareTOTPMethod& operator=(HardwareTOTPMethod&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HardwareTOTPMethod& default_instance() {
    return *internal_default_instance();
  }
  static inline const HardwareTOTPMethod* internal_default_instance() {
    return reinterpret_cast<const HardwareTOTPMethod*>(
        &_HardwareTOTPMethod_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(HardwareTOTPMethod& a, HardwareTOTPMethod& b) { a.Swap(&b); }
  inline void Swap(HardwareTOTPMethod* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HardwareTOTPMethod* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HardwareTOTPMethod* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<HardwareTOTPMethod>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HardwareTOTPMethod& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HardwareTOTPMethod& from) { HardwareTOTPMethod::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(HardwareTOTPMethod* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ownmfa.api.HardwareTOTPMethod"; }

 protected:
  explicit HardwareTOTPMethod(::google::protobuf::Arena* arena);
  HardwareTOTPMethod(::google::protobuf::Arena* arena, const HardwareTOTPMethod& from);
  HardwareTOTPMethod(::google::protobuf::Arena* arena, HardwareTOTPMethod&& from) noexcept
      : HardwareTOTPMethod(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSecretFieldNumber = 3,
    kHashFieldNumber = 1,
    kDigitsFieldNumber = 2,
  };
  // bytes secret = 3 [(.validate.rules) = {
  void clear_secret() ;
  const std::string& secret() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_secret(Arg_&& arg, Args_... args);
  std::string* mutable_secret();
  PROTOBUF_NODISCARD std::string* release_secret();
  void set_allocated_secret(std::string* value);

  private:
  const std::string& _internal_secret() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_secret(
      const std::string& value);
  std::string* _internal_mutable_secret();

  public:
  // .ownmfa.api.Hash hash = 1;
  void clear_hash() ;
  ::ownmfa::api::Hash hash() const;
  void set_hash(::ownmfa::api::Hash value);

  private:
  ::ownmfa::api::Hash _internal_hash() const;
  void _internal_set_hash(::ownmfa::api::Hash value);

  public:
  // int32 digits = 2 [(.validate.rules) = {
  void clear_digits() ;
  ::int32_t digits() const;
  void set_digits(::int32_t value);

  private:
  ::int32_t _internal_digits() const;
  void _internal_set_digits(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:ownmfa.api.HardwareTOTPMethod)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const HardwareTOTPMethod& from_msg);
    ::google::protobuf::internal::ArenaStringPtr secret_;
    int hash_;
    ::int32_t digits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fownmfa_5fapp_5fidentity_2eproto;
};
// -------------------------------------------------------------------

class HardwareHOTPMethod final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ownmfa.api.HardwareHOTPMethod) */ {
 public:
  inline HardwareHOTPMethod() : HardwareHOTPMethod(nullptr) {}
  ~HardwareHOTPMethod() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(HardwareHOTPMethod* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(HardwareHOTPMethod));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HardwareHOTPMethod(
      ::google::protobuf::internal::ConstantInitialized);

  inline HardwareHOTPMethod(const HardwareHOTPMethod& from) : HardwareHOTPMethod(nullptr, from) {}
  inline HardwareHOTPMethod(HardwareHOTPMethod&& from) noexcept
      : HardwareHOTPMethod(nullptr, std::move(from)) {}
  inline HardwareHOTPMethod& operator=(const HardwareHOTPMethod& from) {
    CopyFrom(from);
    return *this;
  }
  inline HardwareHOTPMethod& operator=(HardwareHOTPMethod&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HardwareHOTPMethod& default_instance() {
    return *internal_default_instance();
  }
  static inline const HardwareHOTPMethod* internal_default_instance() {
    return reinterpret_cast<const HardwareHOTPMethod*>(
        &_HardwareHOTPMethod_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(HardwareHOTPMethod& a, HardwareHOTPMethod& b) { a.Swap(&b); }
  inline void Swap(HardwareHOTPMethod* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HardwareHOTPMethod* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HardwareHOTPMethod* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<HardwareHOTPMethod>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HardwareHOTPMethod& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HardwareHOTPMethod& from) { HardwareHOTPMethod::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(HardwareHOTPMethod* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ownmfa.api.HardwareHOTPMethod"; }

 protected:
  explicit HardwareHOTPMethod(::google::protobuf::Arena* arena);
  HardwareHOTPMethod(::google::protobuf::Arena* arena, const HardwareHOTPMethod& from);
  HardwareHOTPMethod(::google::protobuf::Arena* arena, HardwareHOTPMethod&& from) noexcept
      : HardwareHOTPMethod(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSecretFieldNumber = 4,
    kHashFieldNumber = 1,
    kDigitsFieldNumber = 2,
    kCounterFieldNumber = 3,
  };
  // bytes secret = 4 [(.validate.rules) = {
  void clear_secret() ;
  const std::string& secret() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_secret(Arg_&& arg, Args_... args);
  std::string* mutable_secret();
  PROTOBUF_NODISCARD std::string* release_secret();
  void set_allocated_secret(std::string* value);

  private:
  const std::string& _internal_secret() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_secret(
      const std::string& value);
  std::string* _internal_mutable_secret();

  public:
  // .ownmfa.api.Hash hash = 1;
  void clear_hash() ;
  ::ownmfa::api::Hash hash() const;
  void set_hash(::ownmfa::api::Hash value);

  private:
  ::ownmfa::api::Hash _internal_hash() const;
  void _internal_set_hash(::ownmfa::api::Hash value);

  public:
  // int32 digits = 2 [(.validate.rules) = {
  void clear_digits() ;
  ::int32_t digits() const;
  void set_digits(::int32_t value);

  private:
  ::int32_t _internal_digits() const;
  void _internal_set_digits(::int32_t value);

  public:
  // int32 counter = 3;
  void clear_counter() ;
  ::int32_t counter() const;
  void set_counter(::int32_t value);

  private:
  ::int32_t _internal_counter() const;
  void _internal_set_counter(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:ownmfa.api.HardwareHOTPMethod)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const HardwareHOTPMethod& from_msg);
    ::google::protobuf::internal::ArenaStringPtr secret_;
    int hash_;
    ::int32_t digits_;
    ::int32_t counter_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fownmfa_5fapp_5fidentity_2eproto;
};
// -------------------------------------------------------------------

class GoogleAuthTOTPMethod final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ownmfa.api.GoogleAuthTOTPMethod) */ {
 public:
  inline GoogleAuthTOTPMethod() : GoogleAuthTOTPMethod(nullptr) {}
  ~GoogleAuthTOTPMethod() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GoogleAuthTOTPMethod* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GoogleAuthTOTPMethod));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GoogleAuthTOTPMethod(
      ::google::protobuf::internal::ConstantInitialized);

  inline GoogleAuthTOTPMethod(const GoogleAuthTOTPMethod& from) : GoogleAuthTOTPMethod(nullptr, from) {}
  inline GoogleAuthTOTPMethod(GoogleAuthTOTPMethod&& from) noexcept
      : GoogleAuthTOTPMethod(nullptr, std::move(from)) {}
  inline GoogleAuthTOTPMethod& operator=(const GoogleAuthTOTPMethod& from) {
    CopyFrom(from);
    return *this;
  }
  inline GoogleAuthTOTPMethod& operator=(GoogleAuthTOTPMethod&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GoogleAuthTOTPMethod& default_instance() {
    return *internal_default_instance();
  }
  static inline const GoogleAuthTOTPMethod* internal_default_instance() {
    return reinterpret_cast<const GoogleAuthTOTPMethod*>(
        &_GoogleAuthTOTPMethod_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(GoogleAuthTOTPMethod& a, GoogleAuthTOTPMethod& b) { a.Swap(&b); }
  inline void Swap(GoogleAuthTOTPMethod* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GoogleAuthTOTPMethod* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GoogleAuthTOTPMethod* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GoogleAuthTOTPMethod>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GoogleAuthTOTPMethod& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GoogleAuthTOTPMethod& from) { GoogleAuthTOTPMethod::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GoogleAuthTOTPMethod* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ownmfa.api.GoogleAuthTOTPMethod"; }

 protected:
  explicit GoogleAuthTOTPMethod(::google::protobuf::Arena* arena);
  GoogleAuthTOTPMethod(::google::protobuf::Arena* arena, const GoogleAuthTOTPMethod& from);
  GoogleAuthTOTPMethod(::google::protobuf::Arena* arena, GoogleAuthTOTPMethod&& from) noexcept
      : GoogleAuthTOTPMethod(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAccountNameFieldNumber = 1,
  };
  // string account_name = 1 [(.validate.rules) = {
  void clear_account_name() ;
  const std::string& account_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_account_name(Arg_&& arg, Args_... args);
  std::string* mutable_account_name();
  PROTOBUF_NODISCARD std::string* release_account_name();
  void set_allocated_account_name(std::string* value);

  private:
  const std::string& _internal_account_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account_name(
      const std::string& value);
  std::string* _internal_mutable_account_name();

  public:
  // @@protoc_insertion_point(class_scope:ownmfa.api.GoogleAuthTOTPMethod)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      52, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GoogleAuthTOTPMethod& from_msg);
    ::google::protobuf::internal::ArenaStringPtr account_name_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fownmfa_5fapp_5fidentity_2eproto;
};
// -------------------------------------------------------------------

class GoogleAuthHOTPMethod final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ownmfa.api.GoogleAuthHOTPMethod) */ {
 public:
  inline GoogleAuthHOTPMethod() : GoogleAuthHOTPMethod(nullptr) {}
  ~GoogleAuthHOTPMethod() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GoogleAuthHOTPMethod* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GoogleAuthHOTPMethod));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GoogleAuthHOTPMethod(
      ::google::protobuf::internal::ConstantInitialized);

  inline GoogleAuthHOTPMethod(const GoogleAuthHOTPMethod& from) : GoogleAuthHOTPMethod(nullptr, from) {}
  inline GoogleAuthHOTPMethod(GoogleAuthHOTPMethod&& from) noexcept
      : GoogleAuthHOTPMethod(nullptr, std::move(from)) {}
  inline GoogleAuthHOTPMethod& operator=(const GoogleAuthHOTPMethod& from) {
    CopyFrom(from);
    return *this;
  }
  inline GoogleAuthHOTPMethod& operator=(GoogleAuthHOTPMethod&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GoogleAuthHOTPMethod& default_instance() {
    return *internal_default_instance();
  }
  static inline const GoogleAuthHOTPMethod* internal_default_instance() {
    return reinterpret_cast<const GoogleAuthHOTPMethod*>(
        &_GoogleAuthHOTPMethod_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(GoogleAuthHOTPMethod& a, GoogleAuthHOTPMethod& b) { a.Swap(&b); }
  inline void Swap(GoogleAuthHOTPMethod* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GoogleAuthHOTPMethod* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GoogleAuthHOTPMethod* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GoogleAuthHOTPMethod>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GoogleAuthHOTPMethod& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GoogleAuthHOTPMethod& from) { GoogleAuthHOTPMethod::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GoogleAuthHOTPMethod* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ownmfa.api.GoogleAuthHOTPMethod"; }

 protected:
  explicit GoogleAuthHOTPMethod(::google::protobuf::Arena* arena);
  GoogleAuthHOTPMethod(::google::protobuf::Arena* arena, const GoogleAuthHOTPMethod& from);
  GoogleAuthHOTPMethod(::google::protobuf::Arena* arena, GoogleAuthHOTPMethod&& from) noexcept
      : GoogleAuthHOTPMethod(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAccountNameFieldNumber = 1,
  };
  // string account_name = 1 [(.validate.rules) = {
  void clear_account_name() ;
  const std::string& account_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_account_name(Arg_&& arg, Args_... args);
  std::string* mutable_account_name();
  PROTOBUF_NODISCARD std::string* release_account_name();
  void set_allocated_account_name(std::string* value);

  private:
  const std::string& _internal_account_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account_name(
      const std::string& value);
  std::string* _internal_mutable_account_name();

  public:
  // @@protoc_insertion_point(class_scope:ownmfa.api.GoogleAuthHOTPMethod)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      52, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GoogleAuthHOTPMethod& from_msg);
    ::google::protobuf::internal::ArenaStringPtr account_name_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fownmfa_5fapp_5fidentity_2eproto;
};
// -------------------------------------------------------------------

class GetIdentityRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ownmfa.api.GetIdentityRequest) */ {
 public:
  inline GetIdentityRequest() : GetIdentityRequest(nullptr) {}
  ~GetIdentityRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetIdentityRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetIdentityRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetIdentityRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetIdentityRequest(const GetIdentityRequest& from) : GetIdentityRequest(nullptr, from) {}
  inline GetIdentityRequest(GetIdentityRequest&& from) noexcept
      : GetIdentityRequest(nullptr, std::move(from)) {}
  inline GetIdentityRequest& operator=(const GetIdentityRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetIdentityRequest& operator=(GetIdentityRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetIdentityRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetIdentityRequest* internal_default_instance() {
    return reinterpret_cast<const GetIdentityRequest*>(
        &_GetIdentityRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 25;
  friend void swap(GetIdentityRequest& a, GetIdentityRequest& b) { a.Swap(&b); }
  inline void Swap(GetIdentityRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetIdentityRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetIdentityRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetIdentityRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetIdentityRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetIdentityRequest& from) { GetIdentityRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetIdentityRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ownmfa.api.GetIdentityRequest"; }

 protected:
  explicit GetIdentityRequest(::google::protobuf::Arena* arena);
  GetIdentityRequest(::google::protobuf::Arena* arena, const GetIdentityRequest& from);
  GetIdentityRequest(::google::protobuf::Arena* arena, GetIdentityRequest&& from) noexcept
      : GetIdentityRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kAppIdFieldNumber = 2,
  };
  // string id = 1 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string app_id = 2 [json_name = "appID", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  void clear_app_id() ;
  const std::string& app_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_app_id(Arg_&& arg, Args_... args);
  std::string* mutable_app_id();
  PROTOBUF_NODISCARD std::string* release_app_id();
  void set_allocated_app_id(std::string* value);

  private:
  const std::string& _internal_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_id(
      const std::string& value);
  std::string* _internal_mutable_app_id();

  public:
  // @@protoc_insertion_point(class_scope:ownmfa.api.GetIdentityRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      46, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetIdentityRequest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr app_id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fownmfa_5fapp_5fidentity_2eproto;
};
// -------------------------------------------------------------------

class GetAppRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ownmfa.api.GetAppRequest) */ {
 public:
  inline GetAppRequest() : GetAppRequest(nullptr) {}
  ~GetAppRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetAppRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetAppRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetAppRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetAppRequest(const GetAppRequest& from) : GetAppRequest(nullptr, from) {}
  inline GetAppRequest(GetAppRequest&& from) noexcept
      : GetAppRequest(nullptr, std::move(from)) {}
  inline GetAppRequest& operator=(const GetAppRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAppRequest& operator=(GetAppRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAppRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAppRequest* internal_default_instance() {
    return reinterpret_cast<const GetAppRequest*>(
        &_GetAppRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(GetAppRequest& a, GetAppRequest& b) { a.Swap(&b); }
  inline void Swap(GetAppRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAppRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetAppRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetAppRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetAppRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetAppRequest& from) { GetAppRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetAppRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ownmfa.api.GetAppRequest"; }

 protected:
  explicit GetAppRequest(::google::protobuf::Arena* arena);
  GetAppRequest(::google::protobuf::Arena* arena, const GetAppRequest& from);
  GetAppRequest(::google::protobuf::Arena* arena, GetAppRequest&& from) noexcept
      : GetAppRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // @@protoc_insertion_point(class_scope:ownmfa.api.GetAppRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      35, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetAppRequest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fownmfa_5fapp_5fidentity_2eproto;
};
// -------------------------------------------------------------------

class EmailMethod final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ownmfa.api.EmailMethod) */ {
 public:
  inline EmailMethod() : EmailMethod(nullptr) {}
  ~EmailMethod() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EmailMethod* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EmailMethod));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EmailMethod(
      ::google::protobuf::internal::ConstantInitialized);

  inline EmailMethod(const EmailMethod& from) : EmailMethod(nullptr, from) {}
  inline EmailMethod(EmailMethod&& from) noexcept
      : EmailMethod(nullptr, std::move(from)) {}
  inline EmailMethod& operator=(const EmailMethod& from) {
    CopyFrom(from);
    return *this;
  }
  inline EmailMethod& operator=(EmailMethod&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EmailMethod& default_instance() {
    return *internal_default_instance();
  }
  static inline const EmailMethod* internal_default_instance() {
    return reinterpret_cast<const EmailMethod*>(
        &_EmailMethod_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(EmailMethod& a, EmailMethod& b) { a.Swap(&b); }
  inline void Swap(EmailMethod* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EmailMethod* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EmailMethod* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EmailMethod>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EmailMethod& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EmailMethod& from) { EmailMethod::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EmailMethod* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ownmfa.api.EmailMethod"; }

 protected:
  explicit EmailMethod(::google::protobuf::Arena* arena);
  EmailMethod(::google::protobuf::Arena* arena, const EmailMethod& from);
  EmailMethod(::google::protobuf::Arena* arena, EmailMethod&& from) noexcept
      : EmailMethod(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEmailFieldNumber = 1,
  };
  // string email = 1 [(.validate.rules) = {
  void clear_email() ;
  const std::string& email() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_email(Arg_&& arg, Args_... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* value);

  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(
      const std::string& value);
  std::string* _internal_mutable_email();

  public:
  // @@protoc_insertion_point(class_scope:ownmfa.api.EmailMethod)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      36, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const EmailMethod& from_msg);
    ::google::protobuf::internal::ArenaStringPtr email_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fownmfa_5fapp_5fidentity_2eproto;
};
// -------------------------------------------------------------------

class DeleteIdentityRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ownmfa.api.DeleteIdentityRequest) */ {
 public:
  inline DeleteIdentityRequest() : DeleteIdentityRequest(nullptr) {}
  ~DeleteIdentityRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DeleteIdentityRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DeleteIdentityRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteIdentityRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline DeleteIdentityRequest(const DeleteIdentityRequest& from) : DeleteIdentityRequest(nullptr, from) {}
  inline DeleteIdentityRequest(DeleteIdentityRequest&& from) noexcept
      : DeleteIdentityRequest(nullptr, std::move(from)) {}
  inline DeleteIdentityRequest& operator=(const DeleteIdentityRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteIdentityRequest& operator=(DeleteIdentityRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteIdentityRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteIdentityRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteIdentityRequest*>(
        &_DeleteIdentityRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 26;
  friend void swap(DeleteIdentityRequest& a, DeleteIdentityRequest& b) { a.Swap(&b); }
  inline void Swap(DeleteIdentityRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteIdentityRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteIdentityRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DeleteIdentityRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeleteIdentityRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DeleteIdentityRequest& from) { DeleteIdentityRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DeleteIdentityRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ownmfa.api.DeleteIdentityRequest"; }

 protected:
  explicit DeleteIdentityRequest(::google::protobuf::Arena* arena);
  DeleteIdentityRequest(::google::protobuf::Arena* arena, const DeleteIdentityRequest& from);
  DeleteIdentityRequest(::google::protobuf::Arena* arena, DeleteIdentityRequest&& from) noexcept
      : DeleteIdentityRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kAppIdFieldNumber = 2,
  };
  // string id = 1 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string app_id = 2 [json_name = "appID", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  void clear_app_id() ;
  const std::string& app_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_app_id(Arg_&& arg, Args_... args);
  std::string* mutable_app_id();
  PROTOBUF_NODISCARD std::string* release_app_id();
  void set_allocated_app_id(std::string* value);

  private:
  const std::string& _internal_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_id(
      const std::string& value);
  std::string* _internal_mutable_app_id();

  public:
  // @@protoc_insertion_point(class_scope:ownmfa.api.DeleteIdentityRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      49, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DeleteIdentityRequest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr app_id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fownmfa_5fapp_5fidentity_2eproto;
};
// -------------------------------------------------------------------

class DeleteAppRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ownmfa.api.DeleteAppRequest) */ {
 public:
  inline DeleteAppRequest() : DeleteAppRequest(nullptr) {}
  ~DeleteAppRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(DeleteAppRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(DeleteAppRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteAppRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline DeleteAppRequest(const DeleteAppRequest& from) : DeleteAppRequest(nullptr, from) {}
  inline DeleteAppRequest(DeleteAppRequest&& from) noexcept
      : DeleteAppRequest(nullptr, std::move(from)) {}
  inline DeleteAppRequest& operator=(const DeleteAppRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteAppRequest& operator=(DeleteAppRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteAppRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteAppRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteAppRequest*>(
        &_DeleteAppRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(DeleteAppRequest& a, DeleteAppRequest& b) { a.Swap(&b); }
  inline void Swap(DeleteAppRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteAppRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteAppRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<DeleteAppRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeleteAppRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const DeleteAppRequest& from) { DeleteAppRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(DeleteAppRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ownmfa.api.DeleteAppRequest"; }

 protected:
  explicit DeleteAppRequest(::google::protobuf::Arena* arena);
  DeleteAppRequest(::google::protobuf::Arena* arena, const DeleteAppRequest& from);
  DeleteAppRequest(::google::protobuf::Arena* arena, DeleteAppRequest&& from) noexcept
      : DeleteAppRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // @@protoc_insertion_point(class_scope:ownmfa.api.DeleteAppRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      38, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const DeleteAppRequest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fownmfa_5fapp_5fidentity_2eproto;
};
// -------------------------------------------------------------------

class ChallengeIdentityRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ownmfa.api.ChallengeIdentityRequest) */ {
 public:
  inline ChallengeIdentityRequest() : ChallengeIdentityRequest(nullptr) {}
  ~ChallengeIdentityRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ChallengeIdentityRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ChallengeIdentityRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ChallengeIdentityRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline ChallengeIdentityRequest(const ChallengeIdentityRequest& from) : ChallengeIdentityRequest(nullptr, from) {}
  inline ChallengeIdentityRequest(ChallengeIdentityRequest&& from) noexcept
      : ChallengeIdentityRequest(nullptr, std::move(from)) {}
  inline ChallengeIdentityRequest& operator=(const ChallengeIdentityRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChallengeIdentityRequest& operator=(ChallengeIdentityRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChallengeIdentityRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChallengeIdentityRequest* internal_default_instance() {
    return reinterpret_cast<const ChallengeIdentityRequest*>(
        &_ChallengeIdentityRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 23;
  friend void swap(ChallengeIdentityRequest& a, ChallengeIdentityRequest& b) { a.Swap(&b); }
  inline void Swap(ChallengeIdentityRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChallengeIdentityRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChallengeIdentityRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ChallengeIdentityRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChallengeIdentityRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ChallengeIdentityRequest& from) { ChallengeIdentityRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ChallengeIdentityRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ownmfa.api.ChallengeIdentityRequest"; }

 protected:
  explicit ChallengeIdentityRequest(::google::protobuf::Arena* arena);
  ChallengeIdentityRequest(::google::protobuf::Arena* arena, const ChallengeIdentityRequest& from);
  ChallengeIdentityRequest(::google::protobuf::Arena* arena, ChallengeIdentityRequest&& from) noexcept
      : ChallengeIdentityRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kAppIdFieldNumber = 2,
  };
  // string id = 1 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string app_id = 2 [json_name = "appID", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  void clear_app_id() ;
  const std::string& app_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_app_id(Arg_&& arg, Args_... args);
  std::string* mutable_app_id();
  PROTOBUF_NODISCARD std::string* release_app_id();
  void set_allocated_app_id(std::string* value);

  private:
  const std::string& _internal_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_id(
      const std::string& value);
  std::string* _internal_mutable_app_id();

  public:
  // @@protoc_insertion_point(class_scope:ownmfa.api.ChallengeIdentityRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      52, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ChallengeIdentityRequest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr app_id_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fownmfa_5fapp_5fidentity_2eproto;
};
// -------------------------------------------------------------------

class BackupsCodesMethod final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ownmfa.api.BackupsCodesMethod) */ {
 public:
  inline BackupsCodesMethod() : BackupsCodesMethod(nullptr) {}
  ~BackupsCodesMethod() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BackupsCodesMethod* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BackupsCodesMethod));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BackupsCodesMethod(
      ::google::protobuf::internal::ConstantInitialized);

  inline BackupsCodesMethod(const BackupsCodesMethod& from) : BackupsCodesMethod(nullptr, from) {}
  inline BackupsCodesMethod(BackupsCodesMethod&& from) noexcept
      : BackupsCodesMethod(nullptr, std::move(from)) {}
  inline BackupsCodesMethod& operator=(const BackupsCodesMethod& from) {
    CopyFrom(from);
    return *this;
  }
  inline BackupsCodesMethod& operator=(BackupsCodesMethod&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BackupsCodesMethod& default_instance() {
    return *internal_default_instance();
  }
  static inline const BackupsCodesMethod* internal_default_instance() {
    return reinterpret_cast<const BackupsCodesMethod*>(
        &_BackupsCodesMethod_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(BackupsCodesMethod& a, BackupsCodesMethod& b) { a.Swap(&b); }
  inline void Swap(BackupsCodesMethod* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BackupsCodesMethod* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BackupsCodesMethod* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<BackupsCodesMethod>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BackupsCodesMethod& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BackupsCodesMethod& from) { BackupsCodesMethod::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BackupsCodesMethod* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ownmfa.api.BackupsCodesMethod"; }

 protected:
  explicit BackupsCodesMethod(::google::protobuf::Arena* arena);
  BackupsCodesMethod(::google::protobuf::Arena* arena, const BackupsCodesMethod& from);
  BackupsCodesMethod(::google::protobuf::Arena* arena, BackupsCodesMethod&& from) noexcept
      : BackupsCodesMethod(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPasscodesFieldNumber = 1,
  };
  // int32 passcodes = 1 [(.validate.rules) = {
  void clear_passcodes() ;
  ::int32_t passcodes() const;
  void set_passcodes(::int32_t value);

  private:
  ::int32_t _internal_passcodes() const;
  void _internal_set_passcodes(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:ownmfa.api.BackupsCodesMethod)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const BackupsCodesMethod& from_msg);
    ::int32_t passcodes_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fownmfa_5fapp_5fidentity_2eproto;
};
// -------------------------------------------------------------------

class AppleiOSTOTPMethod final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:ownmfa.api.AppleiOSTOTPMethod) */ {
 public:
  inline AppleiOSTOTPMethod() : AppleiOSTOTPMethod(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(AppleiOSTOTPMethod* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(AppleiOSTOTPMethod));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AppleiOSTOTPMethod(
      ::google::protobuf::internal::ConstantInitialized);

  inline AppleiOSTOTPMethod(const AppleiOSTOTPMethod& from) : AppleiOSTOTPMethod(nullptr, from) {}
  inline AppleiOSTOTPMethod(AppleiOSTOTPMethod&& from) noexcept
      : AppleiOSTOTPMethod(nullptr, std::move(from)) {}
  inline AppleiOSTOTPMethod& operator=(const AppleiOSTOTPMethod& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppleiOSTOTPMethod& operator=(AppleiOSTOTPMethod&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppleiOSTOTPMethod& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppleiOSTOTPMethod* internal_default_instance() {
    return reinterpret_cast<const AppleiOSTOTPMethod*>(
        &_AppleiOSTOTPMethod_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(AppleiOSTOTPMethod& a, AppleiOSTOTPMethod& b) { a.Swap(&b); }
  inline void Swap(AppleiOSTOTPMethod* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppleiOSTOTPMethod* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AppleiOSTOTPMethod* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<AppleiOSTOTPMethod>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AppleiOSTOTPMethod& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AppleiOSTOTPMethod& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ownmfa.api.AppleiOSTOTPMethod"; }

 protected:
  explicit AppleiOSTOTPMethod(::google::protobuf::Arena* arena);
  AppleiOSTOTPMethod(::google::protobuf::Arena* arena, const AppleiOSTOTPMethod& from);
  AppleiOSTOTPMethod(::google::protobuf::Arena* arena, AppleiOSTOTPMethod&& from) noexcept
      : AppleiOSTOTPMethod(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:ownmfa.api.AppleiOSTOTPMethod)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AppleiOSTOTPMethod& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_api_2fownmfa_5fapp_5fidentity_2eproto;
};
// -------------------------------------------------------------------

class ActivateIdentityRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ownmfa.api.ActivateIdentityRequest) */ {
 public:
  inline ActivateIdentityRequest() : ActivateIdentityRequest(nullptr) {}
  ~ActivateIdentityRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ActivateIdentityRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ActivateIdentityRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ActivateIdentityRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline ActivateIdentityRequest(const ActivateIdentityRequest& from) : ActivateIdentityRequest(nullptr, from) {}
  inline ActivateIdentityRequest(ActivateIdentityRequest&& from) noexcept
      : ActivateIdentityRequest(nullptr, std::move(from)) {}
  inline ActivateIdentityRequest& operator=(const ActivateIdentityRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ActivateIdentityRequest& operator=(ActivateIdentityRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ActivateIdentityRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ActivateIdentityRequest* internal_default_instance() {
    return reinterpret_cast<const ActivateIdentityRequest*>(
        &_ActivateIdentityRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 22;
  friend void swap(ActivateIdentityRequest& a, ActivateIdentityRequest& b) { a.Swap(&b); }
  inline void Swap(ActivateIdentityRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ActivateIdentityRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ActivateIdentityRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ActivateIdentityRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ActivateIdentityRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ActivateIdentityRequest& from) { ActivateIdentityRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ActivateIdentityRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ownmfa.api.ActivateIdentityRequest"; }

 protected:
  explicit ActivateIdentityRequest(::google::protobuf::Arena* arena);
  ActivateIdentityRequest(::google::protobuf::Arena* arena, const ActivateIdentityRequest& from);
  ActivateIdentityRequest(::google::protobuf::Arena* arena, ActivateIdentityRequest&& from) noexcept
      : ActivateIdentityRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kAppIdFieldNumber = 2,
    kPasscodeFieldNumber = 3,
  };
  // string id = 1 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string app_id = 2 [json_name = "appID", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  void clear_app_id() ;
  const std::string& app_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_app_id(Arg_&& arg, Args_... args);
  std::string* mutable_app_id();
  PROTOBUF_NODISCARD std::string* release_app_id();
  void set_allocated_app_id(std::string* value);

  private:
  const std::string& _internal_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_id(
      const std::string& value);
  std::string* _internal_mutable_app_id();

  public:
  // string passcode = 3 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  void clear_passcode() ;
  const std::string& passcode() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_passcode(Arg_&& arg, Args_... args);
  std::string* mutable_passcode();
  PROTOBUF_NODISCARD std::string* release_passcode();
  void set_allocated_passcode(std::string* value);

  private:
  const std::string& _internal_passcode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_passcode(
      const std::string& value);
  std::string* _internal_mutable_passcode();

  public:
  // @@protoc_insertion_point(class_scope:ownmfa.api.ActivateIdentityRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      59, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ActivateIdentityRequest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr app_id_;
    ::google::protobuf::internal::ArenaStringPtr passcode_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fownmfa_5fapp_5fidentity_2eproto;
};
// -------------------------------------------------------------------

class Identity final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ownmfa.api.Identity) */ {
 public:
  inline Identity() : Identity(nullptr) {}
  ~Identity() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Identity* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Identity));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Identity(
      ::google::protobuf::internal::ConstantInitialized);

  inline Identity(const Identity& from) : Identity(nullptr, from) {}
  inline Identity(Identity&& from) noexcept
      : Identity(nullptr, std::move(from)) {}
  inline Identity& operator=(const Identity& from) {
    CopyFrom(from);
    return *this;
  }
  inline Identity& operator=(Identity&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Identity& default_instance() {
    return *internal_default_instance();
  }
  enum MethodOneofCase {
    kSoftwareHotpMethod = 16,
    kSoftwareTotpMethod = 6,
    kGoogleAuthHotpMethod = 17,
    kGoogleAuthTotpMethod = 7,
    kAppleIosTotpMethod = 22,
    kHardwareHotpMethod = 18,
    kHardwareTotpMethod = 19,
    kSmsMethod = 8,
    kPushoverMethod = 20,
    kEmailMethod = 9,
    kBackupCodesMethod = 10,
    kSecurityQuestionsMethod = 21,
    METHOD_ONEOF_NOT_SET = 0,
  };
  static inline const Identity* internal_default_instance() {
    return reinterpret_cast<const Identity*>(
        &_Identity_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(Identity& a, Identity& b) { a.Swap(&b); }
  inline void Swap(Identity* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Identity* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Identity* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Identity>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Identity& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Identity& from) { Identity::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Identity* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ownmfa.api.Identity"; }

 protected:
  explicit Identity(::google::protobuf::Arena* arena);
  Identity(::google::protobuf::Arena* arena, const Identity& from);
  Identity(::google::protobuf::Arena* arena, Identity&& from) noexcept
      : Identity(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kOrgIdFieldNumber = 2,
    kAppIdFieldNumber = 3,
    kCommentFieldNumber = 4,
    kCreatedAtFieldNumber = 14,
    kUpdatedAtFieldNumber = 15,
    kStatusFieldNumber = 5,
    kSoftwareHotpMethodFieldNumber = 16,
    kSoftwareTotpMethodFieldNumber = 6,
    kGoogleAuthHotpMethodFieldNumber = 17,
    kGoogleAuthTotpMethodFieldNumber = 7,
    kAppleIosTotpMethodFieldNumber = 22,
    kHardwareHotpMethodFieldNumber = 18,
    kHardwareTotpMethodFieldNumber = 19,
    kSmsMethodFieldNumber = 8,
    kPushoverMethodFieldNumber = 20,
    kEmailMethodFieldNumber = 9,
    kBackupCodesMethodFieldNumber = 10,
    kSecurityQuestionsMethodFieldNumber = 21,
  };
  // string id = 1 [(.google.api.field_behavior) = OUTPUT_ONLY];
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string org_id = 2 [json_name = "orgID", (.google.api.field_behavior) = OUTPUT_ONLY];
  void clear_org_id() ;
  const std::string& org_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_org_id(Arg_&& arg, Args_... args);
  std::string* mutable_org_id();
  PROTOBUF_NODISCARD std::string* release_org_id();
  void set_allocated_org_id(std::string* value);

  private:
  const std::string& _internal_org_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_org_id(
      const std::string& value);
  std::string* _internal_mutable_org_id();

  public:
  // string app_id = 3 [json_name = "appID", (.google.api.field_behavior) = OUTPUT_ONLY];
  void clear_app_id() ;
  const std::string& app_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_app_id(Arg_&& arg, Args_... args);
  std::string* mutable_app_id();
  PROTOBUF_NODISCARD std::string* release_app_id();
  void set_allocated_app_id(std::string* value);

  private:
  const std::string& _internal_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app_id(
      const std::string& value);
  std::string* _internal_mutable_app_id();

  public:
  // string comment = 4 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  void clear_comment() ;
  const std::string& comment() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_comment(Arg_&& arg, Args_... args);
  std::string* mutable_comment();
  PROTOBUF_NODISCARD std::string* release_comment();
  void set_allocated_comment(std::string* value);

  private:
  const std::string& _internal_comment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comment(
      const std::string& value);
  std::string* _internal_mutable_comment();

  public:
  // .google.protobuf.Timestamp created_at = 14 [(.google.api.field_behavior) = OUTPUT_ONLY];
  bool has_created_at() const;
  void clear_created_at() ;
  const ::google::protobuf::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_created_at();
  ::google::protobuf::Timestamp* mutable_created_at();
  void set_allocated_created_at(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_created_at(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_created_at();

  private:
  const ::google::protobuf::Timestamp& _internal_created_at() const;
  ::google::protobuf::Timestamp* _internal_mutable_created_at();

  public:
  // .google.protobuf.Timestamp updated_at = 15 [(.google.api.field_behavior) = OUTPUT_ONLY];
  bool has_updated_at() const;
  void clear_updated_at() ;
  const ::google::protobuf::Timestamp& updated_at() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_updated_at();
  ::google::protobuf::Timestamp* mutable_updated_at();
  void set_allocated_updated_at(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_updated_at(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_updated_at();

  private:
  const ::google::protobuf::Timestamp& _internal_updated_at() const;
  ::google::protobuf::Timestamp* _internal_mutable_updated_at();

  public:
  // .ownmfa.api.IdentityStatus status = 5 [(.google.api.field_behavior) = OUTPUT_ONLY];
  void clear_status() ;
  ::ownmfa::api::IdentityStatus status() const;
  void set_status(::ownmfa::api::IdentityStatus value);

  private:
  ::ownmfa::api::IdentityStatus _internal_status() const;
  void _internal_set_status(::ownmfa::api::IdentityStatus value);

  public:
  // .ownmfa.api.SoftwareHOTPMethod software_hotp_method = 16 [json_name = "softwareHOTPMethod"];
  bool has_software_hotp_method() const;
  private:
  bool _internal_has_software_hotp_method() const;

  public:
  void clear_software_hotp_method() ;
  const ::ownmfa::api::SoftwareHOTPMethod& software_hotp_method() const;
  PROTOBUF_NODISCARD ::ownmfa::api::SoftwareHOTPMethod* release_software_hotp_method();
  ::ownmfa::api::SoftwareHOTPMethod* mutable_software_hotp_method();
  void set_allocated_software_hotp_method(::ownmfa::api::SoftwareHOTPMethod* value);
  void unsafe_arena_set_allocated_software_hotp_method(::ownmfa::api::SoftwareHOTPMethod* value);
  ::ownmfa::api::SoftwareHOTPMethod* unsafe_arena_release_software_hotp_method();

  private:
  const ::ownmfa::api::SoftwareHOTPMethod& _internal_software_hotp_method() const;
  ::ownmfa::api::SoftwareHOTPMethod* _internal_mutable_software_hotp_method();

  public:
  // .ownmfa.api.SoftwareTOTPMethod software_totp_method = 6 [json_name = "softwareTOTPMethod"];
  bool has_software_totp_method() const;
  private:
  bool _internal_has_software_totp_method() const;

  public:
  void clear_software_totp_method() ;
  const ::ownmfa::api::SoftwareTOTPMethod& software_totp_method() const;
  PROTOBUF_NODISCARD ::ownmfa::api::SoftwareTOTPMethod* release_software_totp_method();
  ::ownmfa::api::SoftwareTOTPMethod* mutable_software_totp_method();
  void set_allocated_software_totp_method(::ownmfa::api::SoftwareTOTPMethod* value);
  void unsafe_arena_set_allocated_software_totp_method(::ownmfa::api::SoftwareTOTPMethod* value);
  ::ownmfa::api::SoftwareTOTPMethod* unsafe_arena_release_software_totp_method();

  private:
  const ::ownmfa::api::SoftwareTOTPMethod& _internal_software_totp_method() const;
  ::ownmfa::api::SoftwareTOTPMethod* _internal_mutable_software_totp_method();

  public:
  // .ownmfa.api.GoogleAuthHOTPMethod google_auth_hotp_method = 17 [json_name = "googleAuthHOTPMethod"];
  bool has_google_auth_hotp_method() const;
  private:
  bool _internal_has_google_auth_hotp_method() const;

  public:
  void clear_google_auth_hotp_method() ;
  const ::ownmfa::api::GoogleAuthHOTPMethod& google_auth_hotp_method() const;
  PROTOBUF_NODISCARD ::ownmfa::api::GoogleAuthHOTPMethod* release_google_auth_hotp_method();
  ::ownmfa::api::GoogleAuthHOTPMethod* mutable_google_auth_hotp_method();
  void set_allocated_google_auth_hotp_method(::ownmfa::api::GoogleAuthHOTPMethod* value);
  void unsafe_arena_set_allocated_google_auth_hotp_method(::ownmfa::api::GoogleAuthHOTPMethod* value);
  ::ownmfa::api::GoogleAuthHOTPMethod* unsafe_arena_release_google_auth_hotp_method();

  private:
  const ::ownmfa::api::GoogleAuthHOTPMethod& _internal_google_auth_hotp_method() const;
  ::ownmfa::api::GoogleAuthHOTPMethod* _internal_mutable_google_auth_hotp_method();

  public:
  // .ownmfa.api.GoogleAuthTOTPMethod google_auth_totp_method = 7 [json_name = "googleAuthTOTPMethod"];
  bool has_google_auth_totp_method() const;
  private:
  bool _internal_has_google_auth_totp_method() const;

  public:
  void clear_google_auth_totp_method() ;
  const ::ownmfa::api::GoogleAuthTOTPMethod& google_auth_totp_method() const;
  PROTOBUF_NODISCARD ::ownmfa::api::GoogleAuthTOTPMethod* release_google_auth_totp_method();
  ::ownmfa::api::GoogleAuthTOTPMethod* mutable_google_auth_totp_method();
  void set_allocated_google_auth_totp_method(::ownmfa::api::GoogleAuthTOTPMethod* value);
  void unsafe_arena_set_allocated_google_auth_totp_method(::ownmfa::api::GoogleAuthTOTPMethod* value);
  ::ownmfa::api::GoogleAuthTOTPMethod* unsafe_arena_release_google_auth_totp_method();

  private:
  const ::ownmfa::api::GoogleAuthTOTPMethod& _internal_google_auth_totp_method() const;
  ::ownmfa::api::GoogleAuthTOTPMethod* _internal_mutable_google_auth_totp_method();

  public:
  // .ownmfa.api.AppleiOSTOTPMethod apple_ios_totp_method = 22 [json_name = "appleiOSTOTPMethod"];
  bool has_apple_ios_totp_method() const;
  private:
  bool _internal_has_apple_ios_totp_method() const;

  public:
  void clear_apple_ios_totp_method() ;
  const ::ownmfa::api::AppleiOSTOTPMethod& apple_ios_totp_method() const;
  PROTOBUF_NODISCARD ::ownmfa::api::AppleiOSTOTPMethod* release_apple_ios_totp_method();
  ::ownmfa::api::AppleiOSTOTPMethod* mutable_apple_ios_totp_method();
  void set_allocated_apple_ios_totp_method(::ownmfa::api::AppleiOSTOTPMethod* value);
  void unsafe_arena_set_allocated_apple_ios_totp_method(::ownmfa::api::AppleiOSTOTPMethod* value);
  ::ownmfa::api::AppleiOSTOTPMethod* unsafe_arena_release_apple_ios_totp_method();

  private:
  const ::ownmfa::api::AppleiOSTOTPMethod& _internal_apple_ios_totp_method() const;
  ::ownmfa::api::AppleiOSTOTPMethod* _internal_mutable_apple_ios_totp_method();

  public:
  // .ownmfa.api.HardwareHOTPMethod hardware_hotp_method = 18 [json_name = "hardwareHOTPMethod"];
  bool has_hardware_hotp_method() const;
  private:
  bool _internal_has_hardware_hotp_method() const;

  public:
  void clear_hardware_hotp_method() ;
  const ::ownmfa::api::HardwareHOTPMethod& hardware_hotp_method() const;
  PROTOBUF_NODISCARD ::ownmfa::api::HardwareHOTPMethod* release_hardware_hotp_method();
  ::ownmfa::api::HardwareHOTPMethod* mutable_hardware_hotp_method();
  void set_allocated_hardware_hotp_method(::ownmfa::api::HardwareHOTPMethod* value);
  void unsafe_arena_set_allocated_hardware_hotp_method(::ownmfa::api::HardwareHOTPMethod* value);
  ::ownmfa::api::HardwareHOTPMethod* unsafe_arena_release_hardware_hotp_method();

  private:
  const ::ownmfa::api::HardwareHOTPMethod& _internal_hardware_hotp_method() const;
  ::ownmfa::api::HardwareHOTPMethod* _internal_mutable_hardware_hotp_method();

  public:
  // .ownmfa.api.HardwareTOTPMethod hardware_totp_method = 19 [json_name = "hardwareTOTPMethod"];
  bool has_hardware_totp_method() const;
  private:
  bool _internal_has_hardware_totp_method() const;

  public:
  void clear_hardware_totp_method() ;
  const ::ownmfa::api::HardwareTOTPMethod& hardware_totp_method() const;
  PROTOBUF_NODISCARD ::ownmfa::api::HardwareTOTPMethod* release_hardware_totp_method();
  ::ownmfa::api::HardwareTOTPMethod* mutable_hardware_totp_method();
  void set_allocated_hardware_totp_method(::ownmfa::api::HardwareTOTPMethod* value);
  void unsafe_arena_set_allocated_hardware_totp_method(::ownmfa::api::HardwareTOTPMethod* value);
  ::ownmfa::api::HardwareTOTPMethod* unsafe_arena_release_hardware_totp_method();

  private:
  const ::ownmfa::api::HardwareTOTPMethod& _internal_hardware_totp_method() const;
  ::ownmfa::api::HardwareTOTPMethod* _internal_mutable_hardware_totp_method();

  public:
  // .ownmfa.api.SMSMethod sms_method = 8;
  bool has_sms_method() const;
  private:
  bool _internal_has_sms_method() const;

  public:
  void clear_sms_method() ;
  const ::ownmfa::api::SMSMethod& sms_method() const;
  PROTOBUF_NODISCARD ::ownmfa::api::SMSMethod* release_sms_method();
  ::ownmfa::api::SMSMethod* mutable_sms_method();
  void set_allocated_sms_method(::ownmfa::api::SMSMethod* value);
  void unsafe_arena_set_allocated_sms_method(::ownmfa::api::SMSMethod* value);
  ::ownmfa::api::SMSMethod* unsafe_arena_release_sms_method();

  private:
  const ::ownmfa::api::SMSMethod& _internal_sms_method() const;
  ::ownmfa::api::SMSMethod* _internal_mutable_sms_method();

  public:
  // .ownmfa.api.PushoverMethod pushover_method = 20;
  bool has_pushover_method() const;
  private:
  bool _internal_has_pushover_method() const;

  public:
  void clear_pushover_method() ;
  const ::ownmfa::api::PushoverMethod& pushover_method() const;
  PROTOBUF_NODISCARD ::ownmfa::api::PushoverMethod* release_pushover_method();
  ::ownmfa::api::PushoverMethod* mutable_pushover_method();
  void set_allocated_pushover_method(::ownmfa::api::PushoverMethod* value);
  void unsafe_arena_set_allocated_pushover_method(::ownmfa::api::PushoverMethod* value);
  ::ownmfa::api::PushoverMethod* unsafe_arena_release_pushover_method();

  private:
  const ::ownmfa::api::PushoverMethod& _internal_pushover_method() const;
  ::ownmfa::api::PushoverMethod* _internal_mutable_pushover_method();

  public:
  // .ownmfa.api.EmailMethod email_method = 9;
  bool has_email_method() const;
  private:
  bool _internal_has_email_method() const;

  public:
  void clear_email_method() ;
  const ::ownmfa::api::EmailMethod& email_method() const;
  PROTOBUF_NODISCARD ::ownmfa::api::EmailMethod* release_email_method();
  ::ownmfa::api::EmailMethod* mutable_email_method();
  void set_allocated_email_method(::ownmfa::api::EmailMethod* value);
  void unsafe_arena_set_allocated_email_method(::ownmfa::api::EmailMethod* value);
  ::ownmfa::api::EmailMethod* unsafe_arena_release_email_method();

  private:
  const ::ownmfa::api::EmailMethod& _internal_email_method() const;
  ::ownmfa::api::EmailMethod* _internal_mutable_email_method();

  public:
  // .ownmfa.api.BackupsCodesMethod backup_codes_method = 10;
  bool has_backup_codes_method() const;
  private:
  bool _internal_has_backup_codes_method() const;

  public:
  void clear_backup_codes_method() ;
  const ::ownmfa::api::BackupsCodesMethod& backup_codes_method() const;
  PROTOBUF_NODISCARD ::ownmfa::api::BackupsCodesMethod* release_backup_codes_method();
  ::ownmfa::api::BackupsCodesMethod* mutable_backup_codes_method();
  void set_allocated_backup_codes_method(::ownmfa::api::BackupsCodesMethod* value);
  void unsafe_arena_set_allocated_backup_codes_method(::ownmfa::api::BackupsCodesMethod* value);
  ::ownmfa::api::BackupsCodesMethod* unsafe_arena_release_backup_codes_method();

  private:
  const ::ownmfa::api::BackupsCodesMethod& _internal_backup_codes_method() const;
  ::ownmfa::api::BackupsCodesMethod* _internal_mutable_backup_codes_method();

  public:
  // .ownmfa.api.SecurityQuestionsMethod security_questions_method = 21;
  bool has_security_questions_method() const;
  private:
  bool _internal_has_security_questions_method() const;

  public:
  void clear_security_questions_method() ;
  const ::ownmfa::api::SecurityQuestionsMethod& security_questions_method() const;
  PROTOBUF_NODISCARD ::ownmfa::api::SecurityQuestionsMethod* release_security_questions_method();
  ::ownmfa::api::SecurityQuestionsMethod* mutable_security_questions_method();
  void set_allocated_security_questions_method(::ownmfa::api::SecurityQuestionsMethod* value);
  void unsafe_arena_set_allocated_security_questions_method(::ownmfa::api::SecurityQuestionsMethod* value);
  ::ownmfa::api::SecurityQuestionsMethod* unsafe_arena_release_security_questions_method();

  private:
  const ::ownmfa::api::SecurityQuestionsMethod& _internal_security_questions_method() const;
  ::ownmfa::api::SecurityQuestionsMethod* _internal_mutable_security_questions_method();

  public:
  void clear_method_oneof();
  MethodOneofCase method_oneof_case() const;
  // @@protoc_insertion_point(class_scope:ownmfa.api.Identity)
 private:
  class _Internal;
  void set_has_software_hotp_method();
  void set_has_software_totp_method();
  void set_has_google_auth_hotp_method();
  void set_has_google_auth_totp_method();
  void set_has_apple_ios_totp_method();
  void set_has_hardware_hotp_method();
  void set_has_hardware_totp_method();
  void set_has_sms_method();
  void set_has_pushover_method();
  void set_has_email_method();
  void set_has_backup_codes_method();
  void set_has_security_questions_method();
  inline bool has_method_oneof() const;
  inline void clear_has_method_oneof();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 19, 14,
      65, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Identity& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr org_id_;
    ::google::protobuf::internal::ArenaStringPtr app_id_;
    ::google::protobuf::internal::ArenaStringPtr comment_;
    ::google::protobuf::Timestamp* created_at_;
    ::google::protobuf::Timestamp* updated_at_;
    int status_;
    union MethodOneofUnion {
      constexpr MethodOneofUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::ownmfa::api::SoftwareHOTPMethod* software_hotp_method_;
      ::ownmfa::api::SoftwareTOTPMethod* software_totp_method_;
      ::ownmfa::api::GoogleAuthHOTPMethod* google_auth_hotp_method_;
      ::ownmfa::api::GoogleAuthTOTPMethod* google_auth_totp_method_;
      ::ownmfa::api::AppleiOSTOTPMethod* apple_ios_totp_method_;
      ::ownmfa::api::HardwareHOTPMethod* hardware_hotp_method_;
      ::ownmfa::api::HardwareTOTPMethod* hardware_totp_method_;
      ::ownmfa::api::SMSMethod* sms_method_;
      ::ownmfa::api::PushoverMethod* pushover_method_;
      ::ownmfa::api::EmailMethod* email_method_;
      ::ownmfa::api::BackupsCodesMethod* backup_codes_method_;
      ::ownmfa::api::SecurityQuestionsMethod* security_questions_method_;
    } method_oneof_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fownmfa_5fapp_5fidentity_2eproto;
};
// -------------------------------------------------------------------

class App final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ownmfa.api.App) */ {
 public:
  inline App() : App(nullptr) {}
  ~App() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(App* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(App));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR App(
      ::google::protobuf::internal::ConstantInitialized);

  inline App(const App& from) : App(nullptr, from) {}
  inline App(App&& from) noexcept
      : App(nullptr, std::move(from)) {}
  inline App& operator=(const App& from) {
    CopyFrom(from);
    return *this;
  }
  inline App& operator=(App&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const App& default_instance() {
    return *internal_default_instance();
  }
  static inline const App* internal_default_instance() {
    return reinterpret_cast<const App*>(
        &_App_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(App& a, App& b) { a.Swap(&b); }
  inline void Swap(App* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(App* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  App* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<App>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const App& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const App& from) { App::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(App* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ownmfa.api.App"; }

 protected:
  explicit App(::google::protobuf::Arena* arena);
  App(::google::protobuf::Arena* arena, const App& from);
  App(::google::protobuf::Arena* arena, App&& from) noexcept
      : App(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kOrgIdFieldNumber = 2,
    kNameFieldNumber = 3,
    kDisplayNameFieldNumber = 4,
    kEmailFieldNumber = 5,
    kPushoverKeyFieldNumber = 6,
    kSubjectTemplateFieldNumber = 7,
    kTextBodyTemplateFieldNumber = 8,
    kHtmlBodyTemplateFieldNumber = 9,
    kCreatedAtFieldNumber = 10,
    kUpdatedAtFieldNumber = 11,
  };
  // string id = 1 [(.google.api.field_behavior) = OUTPUT_ONLY];
  void clear_id() ;
  const std::string& id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_id(Arg_&& arg, Args_... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* value);

  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
      const std::string& value);
  std::string* _internal_mutable_id();

  public:
  // string org_id = 2 [json_name = "orgID", (.google.api.field_behavior) = OUTPUT_ONLY];
  void clear_org_id() ;
  const std::string& org_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_org_id(Arg_&& arg, Args_... args);
  std::string* mutable_org_id();
  PROTOBUF_NODISCARD std::string* release_org_id();
  void set_allocated_org_id(std::string* value);

  private:
  const std::string& _internal_org_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_org_id(
      const std::string& value);
  std::string* _internal_mutable_org_id();

  public:
  // string name = 3 [(.validate.rules) = {
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string display_name = 4 [(.validate.rules) = {
  void clear_display_name() ;
  const std::string& display_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_display_name(Arg_&& arg, Args_... args);
  std::string* mutable_display_name();
  PROTOBUF_NODISCARD std::string* release_display_name();
  void set_allocated_display_name(std::string* value);

  private:
  const std::string& _internal_display_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_display_name(
      const std::string& value);
  std::string* _internal_mutable_display_name();

  public:
  // string email = 5 [(.validate.rules) = {
  void clear_email() ;
  const std::string& email() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_email(Arg_&& arg, Args_... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* value);

  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(
      const std::string& value);
  std::string* _internal_mutable_email();

  public:
  // string pushover_key = 6 [(.validate.rules) = {
  void clear_pushover_key() ;
  const std::string& pushover_key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_pushover_key(Arg_&& arg, Args_... args);
  std::string* mutable_pushover_key();
  PROTOBUF_NODISCARD std::string* release_pushover_key();
  void set_allocated_pushover_key(std::string* value);

  private:
  const std::string& _internal_pushover_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pushover_key(
      const std::string& value);
  std::string* _internal_mutable_pushover_key();

  public:
  // string subject_template = 7 [(.validate.rules) = {
  void clear_subject_template() ;
  const std::string& subject_template() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_subject_template(Arg_&& arg, Args_... args);
  std::string* mutable_subject_template();
  PROTOBUF_NODISCARD std::string* release_subject_template();
  void set_allocated_subject_template(std::string* value);

  private:
  const std::string& _internal_subject_template() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subject_template(
      const std::string& value);
  std::string* _internal_mutable_subject_template();

  public:
  // string text_body_template = 8 [(.validate.rules) = {
  void clear_text_body_template() ;
  const std::string& text_body_template() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_text_body_template(Arg_&& arg, Args_... args);
  std::string* mutable_text_body_template();
  PROTOBUF_NODISCARD std::string* release_text_body_template();
  void set_allocated_text_body_template(std::string* value);

  private:
  const std::string& _internal_text_body_template() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text_body_template(
      const std::string& value);
  std::string* _internal_mutable_text_body_template();

  public:
  // bytes html_body_template = 9 [(.validate.rules) = {
  void clear_html_body_template() ;
  const std::string& html_body_template() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_html_body_template(Arg_&& arg, Args_... args);
  std::string* mutable_html_body_template();
  PROTOBUF_NODISCARD std::string* release_html_body_template();
  void set_allocated_html_body_template(std::string* value);

  private:
  const std::string& _internal_html_body_template() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_html_body_template(
      const std::string& value);
  std::string* _internal_mutable_html_body_template();

  public:
  // .google.protobuf.Timestamp created_at = 10 [(.google.api.field_behavior) = OUTPUT_ONLY];
  bool has_created_at() const;
  void clear_created_at() ;
  const ::google::protobuf::Timestamp& created_at() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_created_at();
  ::google::protobuf::Timestamp* mutable_created_at();
  void set_allocated_created_at(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_created_at(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_created_at();

  private:
  const ::google::protobuf::Timestamp& _internal_created_at() const;
  ::google::protobuf::Timestamp* _internal_mutable_created_at();

  public:
  // .google.protobuf.Timestamp updated_at = 11 [(.google.api.field_behavior) = OUTPUT_ONLY];
  bool has_updated_at() const;
  void clear_updated_at() ;
  const ::google::protobuf::Timestamp& updated_at() const;
  PROTOBUF_NODISCARD ::google::protobuf::Timestamp* release_updated_at();
  ::google::protobuf::Timestamp* mutable_updated_at();
  void set_allocated_updated_at(::google::protobuf::Timestamp* value);
  void unsafe_arena_set_allocated_updated_at(::google::protobuf::Timestamp* value);
  ::google::protobuf::Timestamp* unsafe_arena_release_updated_at();

  private:
  const ::google::protobuf::Timestamp& _internal_updated_at() const;
  ::google::protobuf::Timestamp* _internal_mutable_updated_at();

  public:
  // @@protoc_insertion_point(class_scope:ownmfa.api.App)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 11, 2,
      106, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const App& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr id_;
    ::google::protobuf::internal::ArenaStringPtr org_id_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr display_name_;
    ::google::protobuf::internal::ArenaStringPtr email_;
    ::google::protobuf::internal::ArenaStringPtr pushover_key_;
    ::google::protobuf::internal::ArenaStringPtr subject_template_;
    ::google::protobuf::internal::ArenaStringPtr text_body_template_;
    ::google::protobuf::internal::ArenaStringPtr html_body_template_;
    ::google::protobuf::Timestamp* created_at_;
    ::google::protobuf::Timestamp* updated_at_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fownmfa_5fapp_5fidentity_2eproto;
};
// -------------------------------------------------------------------

class UpdateAppRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ownmfa.api.UpdateAppRequest) */ {
 public:
  inline UpdateAppRequest() : UpdateAppRequest(nullptr) {}
  ~UpdateAppRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(UpdateAppRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(UpdateAppRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateAppRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline UpdateAppRequest(const UpdateAppRequest& from) : UpdateAppRequest(nullptr, from) {}
  inline UpdateAppRequest(UpdateAppRequest&& from) noexcept
      : UpdateAppRequest(nullptr, std::move(from)) {}
  inline UpdateAppRequest& operator=(const UpdateAppRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateAppRequest& operator=(UpdateAppRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateAppRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateAppRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateAppRequest*>(
        &_UpdateAppRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(UpdateAppRequest& a, UpdateAppRequest& b) { a.Swap(&b); }
  inline void Swap(UpdateAppRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateAppRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateAppRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<UpdateAppRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateAppRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UpdateAppRequest& from) { UpdateAppRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(UpdateAppRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ownmfa.api.UpdateAppRequest"; }

 protected:
  explicit UpdateAppRequest(::google::protobuf::Arena* arena);
  UpdateAppRequest(::google::protobuf::Arena* arena, const UpdateAppRequest& from);
  UpdateAppRequest(::google::protobuf::Arena* arena, UpdateAppRequest&& from) noexcept
      : UpdateAppRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAppFieldNumber = 1,
    kUpdateMaskFieldNumber = 2,
  };
  // .ownmfa.api.App app = 1 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  bool has_app() const;
  void clear_app() ;
  const ::ownmfa::api::App& app() const;
  PROTOBUF_NODISCARD ::ownmfa::api::App* release_app();
  ::ownmfa::api::App* mutable_app();
  void set_allocated_app(::ownmfa::api::App* value);
  void unsafe_arena_set_allocated_app(::ownmfa::api::App* value);
  ::ownmfa::api::App* unsafe_arena_release_app();

  private:
  const ::ownmfa::api::App& _internal_app() const;
  ::ownmfa::api::App* _internal_mutable_app();

  public:
  // .google.protobuf.FieldMask update_mask = 2;
  bool has_update_mask() const;
  void clear_update_mask() ;
  const ::google::protobuf::FieldMask& update_mask() const;
  PROTOBUF_NODISCARD ::google::protobuf::FieldMask* release_update_mask();
  ::google::protobuf::FieldMask* mutable_update_mask();
  void set_allocated_update_mask(::google::protobuf::FieldMask* value);
  void unsafe_arena_set_allocated_update_mask(::google::protobuf::FieldMask* value);
  ::google::protobuf::FieldMask* unsafe_arena_release_update_mask();

  private:
  const ::google::protobuf::FieldMask& _internal_update_mask() const;
  ::google::protobuf::FieldMask* _internal_mutable_update_mask();

  public:
  // @@protoc_insertion_point(class_scope:ownmfa.api.UpdateAppRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const UpdateAppRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::ownmfa::api::App* app_;
    ::google::protobuf::FieldMask* update_mask_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fownmfa_5fapp_5fidentity_2eproto;
};
// -------------------------------------------------------------------

class ListIdentitiesResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ownmfa.api.ListIdentitiesResponse) */ {
 public:
  inline ListIdentitiesResponse() : ListIdentitiesResponse(nullptr) {}
  ~ListIdentitiesResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ListIdentitiesResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ListIdentitiesResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ListIdentitiesResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline ListIdentitiesResponse(const ListIdentitiesResponse& from) : ListIdentitiesResponse(nullptr, from) {}
  inline ListIdentitiesResponse(ListIdentitiesResponse&& from) noexcept
      : ListIdentitiesResponse(nullptr, std::move(from)) {}
  inline ListIdentitiesResponse& operator=(const ListIdentitiesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListIdentitiesResponse& operator=(ListIdentitiesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListIdentitiesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListIdentitiesResponse* internal_default_instance() {
    return reinterpret_cast<const ListIdentitiesResponse*>(
        &_ListIdentitiesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 28;
  friend void swap(ListIdentitiesResponse& a, ListIdentitiesResponse& b) { a.Swap(&b); }
  inline void Swap(ListIdentitiesResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListIdentitiesResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListIdentitiesResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ListIdentitiesResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListIdentitiesResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ListIdentitiesResponse& from) { ListIdentitiesResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ListIdentitiesResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ownmfa.api.ListIdentitiesResponse"; }

 protected:
  explicit ListIdentitiesResponse(::google::protobuf::Arena* arena);
  ListIdentitiesResponse(::google::protobuf::Arena* arena, const ListIdentitiesResponse& from);
  ListIdentitiesResponse(::google::protobuf::Arena* arena, ListIdentitiesResponse&& from) noexcept
      : ListIdentitiesResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdentitiesFieldNumber = 1,
    kNextPageTokenFieldNumber = 2,
    kTotalSizeFieldNumber = 3,
  };
  // repeated .ownmfa.api.Identity identities = 1;
  int identities_size() const;
  private:
  int _internal_identities_size() const;

  public:
  void clear_identities() ;
  ::ownmfa::api::Identity* mutable_identities(int index);
  ::google::protobuf::RepeatedPtrField<::ownmfa::api::Identity>* mutable_identities();

  private:
  const ::google::protobuf::RepeatedPtrField<::ownmfa::api::Identity>& _internal_identities() const;
  ::google::protobuf::RepeatedPtrField<::ownmfa::api::Identity>* _internal_mutable_identities();
  public:
  const ::ownmfa::api::Identity& identities(int index) const;
  ::ownmfa::api::Identity* add_identities();
  const ::google::protobuf::RepeatedPtrField<::ownmfa::api::Identity>& identities() const;
  // string next_page_token = 2;
  void clear_next_page_token() ;
  const std::string& next_page_token() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_next_page_token(Arg_&& arg, Args_... args);
  std::string* mutable_next_page_token();
  PROTOBUF_NODISCARD std::string* release_next_page_token();
  void set_allocated_next_page_token(std::string* value);

  private:
  const std::string& _internal_next_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_page_token(
      const std::string& value);
  std::string* _internal_mutable_next_page_token();

  public:
  // int32 total_size = 3;
  void clear_total_size() ;
  ::int32_t total_size() const;
  void set_total_size(::int32_t value);

  private:
  ::int32_t _internal_total_size() const;
  void _internal_set_total_size(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:ownmfa.api.ListIdentitiesResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      57, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ListIdentitiesResponse& from_msg);
    ::google::protobuf::RepeatedPtrField< ::ownmfa::api::Identity > identities_;
    ::google::protobuf::internal::ArenaStringPtr next_page_token_;
    ::int32_t total_size_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fownmfa_5fapp_5fidentity_2eproto;
};
// -------------------------------------------------------------------

class ListAppsResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ownmfa.api.ListAppsResponse) */ {
 public:
  inline ListAppsResponse() : ListAppsResponse(nullptr) {}
  ~ListAppsResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(ListAppsResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(ListAppsResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ListAppsResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline ListAppsResponse(const ListAppsResponse& from) : ListAppsResponse(nullptr, from) {}
  inline ListAppsResponse(ListAppsResponse&& from) noexcept
      : ListAppsResponse(nullptr, std::move(from)) {}
  inline ListAppsResponse& operator=(const ListAppsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListAppsResponse& operator=(ListAppsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListAppsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListAppsResponse* internal_default_instance() {
    return reinterpret_cast<const ListAppsResponse*>(
        &_ListAppsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(ListAppsResponse& a, ListAppsResponse& b) { a.Swap(&b); }
  inline void Swap(ListAppsResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListAppsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListAppsResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<ListAppsResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListAppsResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ListAppsResponse& from) { ListAppsResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(ListAppsResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ownmfa.api.ListAppsResponse"; }

 protected:
  explicit ListAppsResponse(::google::protobuf::Arena* arena);
  ListAppsResponse(::google::protobuf::Arena* arena, const ListAppsResponse& from);
  ListAppsResponse(::google::protobuf::Arena* arena, ListAppsResponse&& from) noexcept
      : ListAppsResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAppsFieldNumber = 1,
    kNextPageTokenFieldNumber = 2,
    kTotalSizeFieldNumber = 3,
  };
  // repeated .ownmfa.api.App apps = 1;
  int apps_size() const;
  private:
  int _internal_apps_size() const;

  public:
  void clear_apps() ;
  ::ownmfa::api::App* mutable_apps(int index);
  ::google::protobuf::RepeatedPtrField<::ownmfa::api::App>* mutable_apps();

  private:
  const ::google::protobuf::RepeatedPtrField<::ownmfa::api::App>& _internal_apps() const;
  ::google::protobuf::RepeatedPtrField<::ownmfa::api::App>* _internal_mutable_apps();
  public:
  const ::ownmfa::api::App& apps(int index) const;
  ::ownmfa::api::App* add_apps();
  const ::google::protobuf::RepeatedPtrField<::ownmfa::api::App>& apps() const;
  // string next_page_token = 2;
  void clear_next_page_token() ;
  const std::string& next_page_token() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_next_page_token(Arg_&& arg, Args_... args);
  std::string* mutable_next_page_token();
  PROTOBUF_NODISCARD std::string* release_next_page_token();
  void set_allocated_next_page_token(std::string* value);

  private:
  const std::string& _internal_next_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_page_token(
      const std::string& value);
  std::string* _internal_mutable_next_page_token();

  public:
  // int32 total_size = 3;
  void clear_total_size() ;
  ::int32_t total_size() const;
  void set_total_size(::int32_t value);

  private:
  ::int32_t _internal_total_size() const;
  void _internal_set_total_size(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:ownmfa.api.ListAppsResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      51, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ListAppsResponse& from_msg);
    ::google::protobuf::RepeatedPtrField< ::ownmfa::api::App > apps_;
    ::google::protobuf::internal::ArenaStringPtr next_page_token_;
    ::int32_t total_size_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fownmfa_5fapp_5fidentity_2eproto;
};
// -------------------------------------------------------------------

class CreateIdentityResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ownmfa.api.CreateIdentityResponse) */ {
 public:
  inline CreateIdentityResponse() : CreateIdentityResponse(nullptr) {}
  ~CreateIdentityResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CreateIdentityResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CreateIdentityResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CreateIdentityResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline CreateIdentityResponse(const CreateIdentityResponse& from) : CreateIdentityResponse(nullptr, from) {}
  inline CreateIdentityResponse(CreateIdentityResponse&& from) noexcept
      : CreateIdentityResponse(nullptr, std::move(from)) {}
  inline CreateIdentityResponse& operator=(const CreateIdentityResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateIdentityResponse& operator=(CreateIdentityResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateIdentityResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateIdentityResponse* internal_default_instance() {
    return reinterpret_cast<const CreateIdentityResponse*>(
        &_CreateIdentityResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 21;
  friend void swap(CreateIdentityResponse& a, CreateIdentityResponse& b) { a.Swap(&b); }
  inline void Swap(CreateIdentityResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateIdentityResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateIdentityResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CreateIdentityResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateIdentityResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CreateIdentityResponse& from) { CreateIdentityResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CreateIdentityResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ownmfa.api.CreateIdentityResponse"; }

 protected:
  explicit CreateIdentityResponse(::google::protobuf::Arena* arena);
  CreateIdentityResponse(::google::protobuf::Arena* arena, const CreateIdentityResponse& from);
  CreateIdentityResponse(::google::protobuf::Arena* arena, CreateIdentityResponse&& from) noexcept
      : CreateIdentityResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPasscodesFieldNumber = 4,
    kSecretFieldNumber = 2,
    kQrFieldNumber = 3,
    kIdentityFieldNumber = 1,
  };
  // repeated string passcodes = 4;
  int passcodes_size() const;
  private:
  int _internal_passcodes_size() const;

  public:
  void clear_passcodes() ;
  const std::string& passcodes(int index) const;
  std::string* mutable_passcodes(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_passcodes(int index, Arg_&& value, Args_... args);
  std::string* add_passcodes();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_passcodes(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& passcodes() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_passcodes();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_passcodes() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_passcodes();

  public:
  // string secret = 2;
  void clear_secret() ;
  const std::string& secret() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_secret(Arg_&& arg, Args_... args);
  std::string* mutable_secret();
  PROTOBUF_NODISCARD std::string* release_secret();
  void set_allocated_secret(std::string* value);

  private:
  const std::string& _internal_secret() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_secret(
      const std::string& value);
  std::string* _internal_mutable_secret();

  public:
  // bytes qr = 3;
  void clear_qr() ;
  const std::string& qr() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_qr(Arg_&& arg, Args_... args);
  std::string* mutable_qr();
  PROTOBUF_NODISCARD std::string* release_qr();
  void set_allocated_qr(std::string* value);

  private:
  const std::string& _internal_qr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_qr(
      const std::string& value);
  std::string* _internal_mutable_qr();

  public:
  // .ownmfa.api.Identity identity = 1;
  bool has_identity() const;
  void clear_identity() ;
  const ::ownmfa::api::Identity& identity() const;
  PROTOBUF_NODISCARD ::ownmfa::api::Identity* release_identity();
  ::ownmfa::api::Identity* mutable_identity();
  void set_allocated_identity(::ownmfa::api::Identity* value);
  void unsafe_arena_set_allocated_identity(::ownmfa::api::Identity* value);
  ::ownmfa::api::Identity* unsafe_arena_release_identity();

  private:
  const ::ownmfa::api::Identity& _internal_identity() const;
  ::ownmfa::api::Identity* _internal_mutable_identity();

  public:
  // @@protoc_insertion_point(class_scope:ownmfa.api.CreateIdentityResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      57, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CreateIdentityResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> passcodes_;
    ::google::protobuf::internal::ArenaStringPtr secret_;
    ::google::protobuf::internal::ArenaStringPtr qr_;
    ::ownmfa::api::Identity* identity_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fownmfa_5fapp_5fidentity_2eproto;
};
// -------------------------------------------------------------------

class CreateIdentityRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ownmfa.api.CreateIdentityRequest) */ {
 public:
  inline CreateIdentityRequest() : CreateIdentityRequest(nullptr) {}
  ~CreateIdentityRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CreateIdentityRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CreateIdentityRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CreateIdentityRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline CreateIdentityRequest(const CreateIdentityRequest& from) : CreateIdentityRequest(nullptr, from) {}
  inline CreateIdentityRequest(CreateIdentityRequest&& from) noexcept
      : CreateIdentityRequest(nullptr, std::move(from)) {}
  inline CreateIdentityRequest& operator=(const CreateIdentityRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateIdentityRequest& operator=(CreateIdentityRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateIdentityRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateIdentityRequest* internal_default_instance() {
    return reinterpret_cast<const CreateIdentityRequest*>(
        &_CreateIdentityRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(CreateIdentityRequest& a, CreateIdentityRequest& b) { a.Swap(&b); }
  inline void Swap(CreateIdentityRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateIdentityRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateIdentityRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CreateIdentityRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateIdentityRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CreateIdentityRequest& from) { CreateIdentityRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CreateIdentityRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ownmfa.api.CreateIdentityRequest"; }

 protected:
  explicit CreateIdentityRequest(::google::protobuf::Arena* arena);
  CreateIdentityRequest(::google::protobuf::Arena* arena, const CreateIdentityRequest& from);
  CreateIdentityRequest(::google::protobuf::Arena* arena, CreateIdentityRequest&& from) noexcept
      : CreateIdentityRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdentityFieldNumber = 1,
  };
  // .ownmfa.api.Identity identity = 1 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  bool has_identity() const;
  void clear_identity() ;
  const ::ownmfa::api::Identity& identity() const;
  PROTOBUF_NODISCARD ::ownmfa::api::Identity* release_identity();
  ::ownmfa::api::Identity* mutable_identity();
  void set_allocated_identity(::ownmfa::api::Identity* value);
  void unsafe_arena_set_allocated_identity(::ownmfa::api::Identity* value);
  ::ownmfa::api::Identity* unsafe_arena_release_identity();

  private:
  const ::ownmfa::api::Identity& _internal_identity() const;
  ::ownmfa::api::Identity* _internal_mutable_identity();

  public:
  // @@protoc_insertion_point(class_scope:ownmfa.api.CreateIdentityRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CreateIdentityRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::ownmfa::api::Identity* identity_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fownmfa_5fapp_5fidentity_2eproto;
};
// -------------------------------------------------------------------

class CreateAppRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:ownmfa.api.CreateAppRequest) */ {
 public:
  inline CreateAppRequest() : CreateAppRequest(nullptr) {}
  ~CreateAppRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(CreateAppRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(CreateAppRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR CreateAppRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline CreateAppRequest(const CreateAppRequest& from) : CreateAppRequest(nullptr, from) {}
  inline CreateAppRequest(CreateAppRequest&& from) noexcept
      : CreateAppRequest(nullptr, std::move(from)) {}
  inline CreateAppRequest& operator=(const CreateAppRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateAppRequest& operator=(CreateAppRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateAppRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateAppRequest* internal_default_instance() {
    return reinterpret_cast<const CreateAppRequest*>(
        &_CreateAppRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(CreateAppRequest& a, CreateAppRequest& b) { a.Swap(&b); }
  inline void Swap(CreateAppRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateAppRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateAppRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<CreateAppRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateAppRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const CreateAppRequest& from) { CreateAppRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(CreateAppRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "ownmfa.api.CreateAppRequest"; }

 protected:
  explicit CreateAppRequest(::google::protobuf::Arena* arena);
  CreateAppRequest(::google::protobuf::Arena* arena, const CreateAppRequest& from);
  CreateAppRequest(::google::protobuf::Arena* arena, CreateAppRequest&& from) noexcept
      : CreateAppRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAppFieldNumber = 1,
  };
  // .ownmfa.api.App app = 1 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
  bool has_app() const;
  void clear_app() ;
  const ::ownmfa::api::App& app() const;
  PROTOBUF_NODISCARD ::ownmfa::api::App* release_app();
  ::ownmfa::api::App* mutable_app();
  void set_allocated_app(::ownmfa::api::App* value);
  void unsafe_arena_set_allocated_app(::ownmfa::api::App* value);
  ::ownmfa::api::App* unsafe_arena_release_app();

  private:
  const ::ownmfa::api::App& _internal_app() const;
  ::ownmfa::api::App* _internal_mutable_app();

  public:
  // @@protoc_insertion_point(class_scope:ownmfa.api.CreateAppRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const CreateAppRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::ownmfa::api::App* app_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_api_2fownmfa_5fapp_5fidentity_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// App

// string id = 1 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline void App::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& App::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.App.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void App::set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ownmfa.api.App.id)
}
inline std::string* App::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.App.id)
  return _s;
}
inline const std::string& App::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void App::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(value, GetArena());
}
inline std::string* App::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* App::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ownmfa.api.App.id)
  return _impl_.id_.Release();
}
inline void App::set_allocated_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.App.id)
}

// string org_id = 2 [json_name = "orgID", (.google.api.field_behavior) = OUTPUT_ONLY];
inline void App::clear_org_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.org_id_.ClearToEmpty();
}
inline const std::string& App::org_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.App.org_id)
  return _internal_org_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void App::set_org_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.org_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ownmfa.api.App.org_id)
}
inline std::string* App::mutable_org_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_org_id();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.App.org_id)
  return _s;
}
inline const std::string& App::_internal_org_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.org_id_.Get();
}
inline void App::_internal_set_org_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.org_id_.Set(value, GetArena());
}
inline std::string* App::_internal_mutable_org_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.org_id_.Mutable( GetArena());
}
inline std::string* App::release_org_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ownmfa.api.App.org_id)
  return _impl_.org_id_.Release();
}
inline void App::set_allocated_org_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.org_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.org_id_.IsDefault()) {
    _impl_.org_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.App.org_id)
}

// string name = 3 [(.validate.rules) = {
inline void App::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& App::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.App.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void App::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ownmfa.api.App.name)
}
inline std::string* App::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.App.name)
  return _s;
}
inline const std::string& App::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void App::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* App::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* App::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ownmfa.api.App.name)
  return _impl_.name_.Release();
}
inline void App::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.App.name)
}

// string display_name = 4 [(.validate.rules) = {
inline void App::clear_display_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.display_name_.ClearToEmpty();
}
inline const std::string& App::display_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.App.display_name)
  return _internal_display_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void App::set_display_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.display_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ownmfa.api.App.display_name)
}
inline std::string* App::mutable_display_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_display_name();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.App.display_name)
  return _s;
}
inline const std::string& App::_internal_display_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.display_name_.Get();
}
inline void App::_internal_set_display_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.display_name_.Set(value, GetArena());
}
inline std::string* App::_internal_mutable_display_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.display_name_.Mutable( GetArena());
}
inline std::string* App::release_display_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ownmfa.api.App.display_name)
  return _impl_.display_name_.Release();
}
inline void App::set_allocated_display_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.display_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.display_name_.IsDefault()) {
    _impl_.display_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.App.display_name)
}

// string email = 5 [(.validate.rules) = {
inline void App::clear_email() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.email_.ClearToEmpty();
}
inline const std::string& App::email() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.App.email)
  return _internal_email();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void App::set_email(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.email_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ownmfa.api.App.email)
}
inline std::string* App::mutable_email() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.App.email)
  return _s;
}
inline const std::string& App::_internal_email() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.email_.Get();
}
inline void App::_internal_set_email(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.email_.Set(value, GetArena());
}
inline std::string* App::_internal_mutable_email() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.email_.Mutable( GetArena());
}
inline std::string* App::release_email() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ownmfa.api.App.email)
  return _impl_.email_.Release();
}
inline void App::set_allocated_email(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.email_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.email_.IsDefault()) {
    _impl_.email_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.App.email)
}

// string pushover_key = 6 [(.validate.rules) = {
inline void App::clear_pushover_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pushover_key_.ClearToEmpty();
}
inline const std::string& App::pushover_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.App.pushover_key)
  return _internal_pushover_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void App::set_pushover_key(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pushover_key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ownmfa.api.App.pushover_key)
}
inline std::string* App::mutable_pushover_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_pushover_key();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.App.pushover_key)
  return _s;
}
inline const std::string& App::_internal_pushover_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.pushover_key_.Get();
}
inline void App::_internal_set_pushover_key(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pushover_key_.Set(value, GetArena());
}
inline std::string* App::_internal_mutable_pushover_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.pushover_key_.Mutable( GetArena());
}
inline std::string* App::release_pushover_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ownmfa.api.App.pushover_key)
  return _impl_.pushover_key_.Release();
}
inline void App::set_allocated_pushover_key(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pushover_key_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.pushover_key_.IsDefault()) {
    _impl_.pushover_key_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.App.pushover_key)
}

// string subject_template = 7 [(.validate.rules) = {
inline void App::clear_subject_template() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.subject_template_.ClearToEmpty();
}
inline const std::string& App::subject_template() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.App.subject_template)
  return _internal_subject_template();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void App::set_subject_template(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.subject_template_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ownmfa.api.App.subject_template)
}
inline std::string* App::mutable_subject_template() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_subject_template();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.App.subject_template)
  return _s;
}
inline const std::string& App::_internal_subject_template() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.subject_template_.Get();
}
inline void App::_internal_set_subject_template(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.subject_template_.Set(value, GetArena());
}
inline std::string* App::_internal_mutable_subject_template() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.subject_template_.Mutable( GetArena());
}
inline std::string* App::release_subject_template() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ownmfa.api.App.subject_template)
  return _impl_.subject_template_.Release();
}
inline void App::set_allocated_subject_template(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.subject_template_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.subject_template_.IsDefault()) {
    _impl_.subject_template_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.App.subject_template)
}

// string text_body_template = 8 [(.validate.rules) = {
inline void App::clear_text_body_template() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.text_body_template_.ClearToEmpty();
}
inline const std::string& App::text_body_template() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.App.text_body_template)
  return _internal_text_body_template();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void App::set_text_body_template(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.text_body_template_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ownmfa.api.App.text_body_template)
}
inline std::string* App::mutable_text_body_template() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_text_body_template();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.App.text_body_template)
  return _s;
}
inline const std::string& App::_internal_text_body_template() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.text_body_template_.Get();
}
inline void App::_internal_set_text_body_template(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.text_body_template_.Set(value, GetArena());
}
inline std::string* App::_internal_mutable_text_body_template() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.text_body_template_.Mutable( GetArena());
}
inline std::string* App::release_text_body_template() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ownmfa.api.App.text_body_template)
  return _impl_.text_body_template_.Release();
}
inline void App::set_allocated_text_body_template(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.text_body_template_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.text_body_template_.IsDefault()) {
    _impl_.text_body_template_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.App.text_body_template)
}

// bytes html_body_template = 9 [(.validate.rules) = {
inline void App::clear_html_body_template() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.html_body_template_.ClearToEmpty();
}
inline const std::string& App::html_body_template() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.App.html_body_template)
  return _internal_html_body_template();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void App::set_html_body_template(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.html_body_template_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ownmfa.api.App.html_body_template)
}
inline std::string* App::mutable_html_body_template() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_html_body_template();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.App.html_body_template)
  return _s;
}
inline const std::string& App::_internal_html_body_template() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.html_body_template_.Get();
}
inline void App::_internal_set_html_body_template(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.html_body_template_.Set(value, GetArena());
}
inline std::string* App::_internal_mutable_html_body_template() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.html_body_template_.Mutable( GetArena());
}
inline std::string* App::release_html_body_template() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ownmfa.api.App.html_body_template)
  return _impl_.html_body_template_.Release();
}
inline void App::set_allocated_html_body_template(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.html_body_template_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.html_body_template_.IsDefault()) {
    _impl_.html_body_template_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.App.html_body_template)
}

// .google.protobuf.Timestamp created_at = 10 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline bool App::has_created_at() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.created_at_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& App::_internal_created_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& App::created_at() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.App.created_at)
  return _internal_created_at();
}
inline void App::unsafe_arena_set_allocated_created_at(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ownmfa.api.App.created_at)
}
inline ::google::protobuf::Timestamp* App::release_created_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* App::unsafe_arena_release_created_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ownmfa.api.App.created_at)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* App::_internal_mutable_created_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.created_at_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.created_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.created_at_;
}
inline ::google::protobuf::Timestamp* App::mutable_created_at() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.App.created_at)
  return _msg;
}
inline void App::set_allocated_created_at(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.created_at_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.created_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.App.created_at)
}

// .google.protobuf.Timestamp updated_at = 11 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline bool App::has_updated_at() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.updated_at_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& App::_internal_updated_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.updated_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& App::updated_at() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.App.updated_at)
  return _internal_updated_at();
}
inline void App::unsafe_arena_set_allocated_updated_at(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.updated_at_);
  }
  _impl_.updated_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ownmfa.api.App.updated_at)
}
inline ::google::protobuf::Timestamp* App::release_updated_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* released = _impl_.updated_at_;
  _impl_.updated_at_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* App::unsafe_arena_release_updated_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ownmfa.api.App.updated_at)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* temp = _impl_.updated_at_;
  _impl_.updated_at_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* App::_internal_mutable_updated_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.updated_at_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.updated_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.updated_at_;
}
inline ::google::protobuf::Timestamp* App::mutable_updated_at() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_updated_at();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.App.updated_at)
  return _msg;
}
inline void App::set_allocated_updated_at(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.updated_at_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.updated_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.App.updated_at)
}

// -------------------------------------------------------------------

// CreateAppRequest

// .ownmfa.api.App app = 1 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline bool CreateAppRequest::has_app() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.app_ != nullptr);
  return value;
}
inline void CreateAppRequest::clear_app() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.app_ != nullptr) _impl_.app_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::ownmfa::api::App& CreateAppRequest::_internal_app() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::ownmfa::api::App* p = _impl_.app_;
  return p != nullptr ? *p : reinterpret_cast<const ::ownmfa::api::App&>(::ownmfa::api::_App_default_instance_);
}
inline const ::ownmfa::api::App& CreateAppRequest::app() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.CreateAppRequest.app)
  return _internal_app();
}
inline void CreateAppRequest::unsafe_arena_set_allocated_app(::ownmfa::api::App* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.app_);
  }
  _impl_.app_ = reinterpret_cast<::ownmfa::api::App*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ownmfa.api.CreateAppRequest.app)
}
inline ::ownmfa::api::App* CreateAppRequest::release_app() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ownmfa::api::App* released = _impl_.app_;
  _impl_.app_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::ownmfa::api::App* CreateAppRequest::unsafe_arena_release_app() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ownmfa.api.CreateAppRequest.app)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ownmfa::api::App* temp = _impl_.app_;
  _impl_.app_ = nullptr;
  return temp;
}
inline ::ownmfa::api::App* CreateAppRequest::_internal_mutable_app() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.app_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::ownmfa::api::App>(GetArena());
    _impl_.app_ = reinterpret_cast<::ownmfa::api::App*>(p);
  }
  return _impl_.app_;
}
inline ::ownmfa::api::App* CreateAppRequest::mutable_app() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::ownmfa::api::App* _msg = _internal_mutable_app();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.CreateAppRequest.app)
  return _msg;
}
inline void CreateAppRequest::set_allocated_app(::ownmfa::api::App* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.app_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.app_ = reinterpret_cast<::ownmfa::api::App*>(value);
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.CreateAppRequest.app)
}

// -------------------------------------------------------------------

// GetAppRequest

// string id = 1 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline void GetAppRequest::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& GetAppRequest::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.GetAppRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetAppRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ownmfa.api.GetAppRequest.id)
}
inline std::string* GetAppRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.GetAppRequest.id)
  return _s;
}
inline const std::string& GetAppRequest::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void GetAppRequest::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(value, GetArena());
}
inline std::string* GetAppRequest::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* GetAppRequest::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ownmfa.api.GetAppRequest.id)
  return _impl_.id_.Release();
}
inline void GetAppRequest::set_allocated_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.GetAppRequest.id)
}

// -------------------------------------------------------------------

// UpdateAppRequest

// .ownmfa.api.App app = 1 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline bool UpdateAppRequest::has_app() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.app_ != nullptr);
  return value;
}
inline void UpdateAppRequest::clear_app() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.app_ != nullptr) _impl_.app_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::ownmfa::api::App& UpdateAppRequest::_internal_app() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::ownmfa::api::App* p = _impl_.app_;
  return p != nullptr ? *p : reinterpret_cast<const ::ownmfa::api::App&>(::ownmfa::api::_App_default_instance_);
}
inline const ::ownmfa::api::App& UpdateAppRequest::app() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.UpdateAppRequest.app)
  return _internal_app();
}
inline void UpdateAppRequest::unsafe_arena_set_allocated_app(::ownmfa::api::App* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.app_);
  }
  _impl_.app_ = reinterpret_cast<::ownmfa::api::App*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ownmfa.api.UpdateAppRequest.app)
}
inline ::ownmfa::api::App* UpdateAppRequest::release_app() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ownmfa::api::App* released = _impl_.app_;
  _impl_.app_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::ownmfa::api::App* UpdateAppRequest::unsafe_arena_release_app() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ownmfa.api.UpdateAppRequest.app)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ownmfa::api::App* temp = _impl_.app_;
  _impl_.app_ = nullptr;
  return temp;
}
inline ::ownmfa::api::App* UpdateAppRequest::_internal_mutable_app() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.app_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::ownmfa::api::App>(GetArena());
    _impl_.app_ = reinterpret_cast<::ownmfa::api::App*>(p);
  }
  return _impl_.app_;
}
inline ::ownmfa::api::App* UpdateAppRequest::mutable_app() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::ownmfa::api::App* _msg = _internal_mutable_app();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.UpdateAppRequest.app)
  return _msg;
}
inline void UpdateAppRequest::set_allocated_app(::ownmfa::api::App* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.app_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.app_ = reinterpret_cast<::ownmfa::api::App*>(value);
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.UpdateAppRequest.app)
}

// .google.protobuf.FieldMask update_mask = 2;
inline bool UpdateAppRequest::has_update_mask() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.update_mask_ != nullptr);
  return value;
}
inline const ::google::protobuf::FieldMask& UpdateAppRequest::_internal_update_mask() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::FieldMask* p = _impl_.update_mask_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::FieldMask&>(::google::protobuf::_FieldMask_default_instance_);
}
inline const ::google::protobuf::FieldMask& UpdateAppRequest::update_mask() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.UpdateAppRequest.update_mask)
  return _internal_update_mask();
}
inline void UpdateAppRequest::unsafe_arena_set_allocated_update_mask(::google::protobuf::FieldMask* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.update_mask_);
  }
  _impl_.update_mask_ = reinterpret_cast<::google::protobuf::FieldMask*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ownmfa.api.UpdateAppRequest.update_mask)
}
inline ::google::protobuf::FieldMask* UpdateAppRequest::release_update_mask() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::FieldMask* released = _impl_.update_mask_;
  _impl_.update_mask_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::FieldMask* UpdateAppRequest::unsafe_arena_release_update_mask() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ownmfa.api.UpdateAppRequest.update_mask)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::FieldMask* temp = _impl_.update_mask_;
  _impl_.update_mask_ = nullptr;
  return temp;
}
inline ::google::protobuf::FieldMask* UpdateAppRequest::_internal_mutable_update_mask() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.update_mask_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::FieldMask>(GetArena());
    _impl_.update_mask_ = reinterpret_cast<::google::protobuf::FieldMask*>(p);
  }
  return _impl_.update_mask_;
}
inline ::google::protobuf::FieldMask* UpdateAppRequest::mutable_update_mask() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::google::protobuf::FieldMask* _msg = _internal_mutable_update_mask();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.UpdateAppRequest.update_mask)
  return _msg;
}
inline void UpdateAppRequest::set_allocated_update_mask(::google::protobuf::FieldMask* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.update_mask_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.update_mask_ = reinterpret_cast<::google::protobuf::FieldMask*>(value);
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.UpdateAppRequest.update_mask)
}

// -------------------------------------------------------------------

// DeleteAppRequest

// string id = 1 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline void DeleteAppRequest::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& DeleteAppRequest::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.DeleteAppRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DeleteAppRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ownmfa.api.DeleteAppRequest.id)
}
inline std::string* DeleteAppRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.DeleteAppRequest.id)
  return _s;
}
inline const std::string& DeleteAppRequest::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void DeleteAppRequest::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(value, GetArena());
}
inline std::string* DeleteAppRequest::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* DeleteAppRequest::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ownmfa.api.DeleteAppRequest.id)
  return _impl_.id_.Release();
}
inline void DeleteAppRequest::set_allocated_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.DeleteAppRequest.id)
}

// -------------------------------------------------------------------

// ListAppsRequest

// int32 page_size = 1 [(.validate.rules) = {
inline void ListAppsRequest::clear_page_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.page_size_ = 0;
}
inline ::int32_t ListAppsRequest::page_size() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.ListAppsRequest.page_size)
  return _internal_page_size();
}
inline void ListAppsRequest::set_page_size(::int32_t value) {
  _internal_set_page_size(value);
  // @@protoc_insertion_point(field_set:ownmfa.api.ListAppsRequest.page_size)
}
inline ::int32_t ListAppsRequest::_internal_page_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.page_size_;
}
inline void ListAppsRequest::_internal_set_page_size(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.page_size_ = value;
}

// string page_token = 2;
inline void ListAppsRequest::clear_page_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.page_token_.ClearToEmpty();
}
inline const std::string& ListAppsRequest::page_token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.ListAppsRequest.page_token)
  return _internal_page_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ListAppsRequest::set_page_token(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.page_token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ownmfa.api.ListAppsRequest.page_token)
}
inline std::string* ListAppsRequest::mutable_page_token() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.ListAppsRequest.page_token)
  return _s;
}
inline const std::string& ListAppsRequest::_internal_page_token() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.page_token_.Get();
}
inline void ListAppsRequest::_internal_set_page_token(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.page_token_.Set(value, GetArena());
}
inline std::string* ListAppsRequest::_internal_mutable_page_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.page_token_.Mutable( GetArena());
}
inline std::string* ListAppsRequest::release_page_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ownmfa.api.ListAppsRequest.page_token)
  return _impl_.page_token_.Release();
}
inline void ListAppsRequest::set_allocated_page_token(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.page_token_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.page_token_.IsDefault()) {
    _impl_.page_token_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.ListAppsRequest.page_token)
}

// -------------------------------------------------------------------

// ListAppsResponse

// repeated .ownmfa.api.App apps = 1;
inline int ListAppsResponse::_internal_apps_size() const {
  return _internal_apps().size();
}
inline int ListAppsResponse::apps_size() const {
  return _internal_apps_size();
}
inline void ListAppsResponse::clear_apps() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.apps_.Clear();
}
inline ::ownmfa::api::App* ListAppsResponse::mutable_apps(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:ownmfa.api.ListAppsResponse.apps)
  return _internal_mutable_apps()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::ownmfa::api::App>* ListAppsResponse::mutable_apps()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:ownmfa.api.ListAppsResponse.apps)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_apps();
}
inline const ::ownmfa::api::App& ListAppsResponse::apps(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.ListAppsResponse.apps)
  return _internal_apps().Get(index);
}
inline ::ownmfa::api::App* ListAppsResponse::add_apps() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::ownmfa::api::App* _add = _internal_mutable_apps()->Add();
  // @@protoc_insertion_point(field_add:ownmfa.api.ListAppsResponse.apps)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::ownmfa::api::App>& ListAppsResponse::apps() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:ownmfa.api.ListAppsResponse.apps)
  return _internal_apps();
}
inline const ::google::protobuf::RepeatedPtrField<::ownmfa::api::App>&
ListAppsResponse::_internal_apps() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.apps_;
}
inline ::google::protobuf::RepeatedPtrField<::ownmfa::api::App>*
ListAppsResponse::_internal_mutable_apps() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.apps_;
}

// string next_page_token = 2;
inline void ListAppsResponse::clear_next_page_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_page_token_.ClearToEmpty();
}
inline const std::string& ListAppsResponse::next_page_token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.ListAppsResponse.next_page_token)
  return _internal_next_page_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ListAppsResponse::set_next_page_token(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_page_token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ownmfa.api.ListAppsResponse.next_page_token)
}
inline std::string* ListAppsResponse::mutable_next_page_token() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_next_page_token();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.ListAppsResponse.next_page_token)
  return _s;
}
inline const std::string& ListAppsResponse::_internal_next_page_token() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.next_page_token_.Get();
}
inline void ListAppsResponse::_internal_set_next_page_token(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_page_token_.Set(value, GetArena());
}
inline std::string* ListAppsResponse::_internal_mutable_next_page_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.next_page_token_.Mutable( GetArena());
}
inline std::string* ListAppsResponse::release_next_page_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ownmfa.api.ListAppsResponse.next_page_token)
  return _impl_.next_page_token_.Release();
}
inline void ListAppsResponse::set_allocated_next_page_token(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_page_token_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.next_page_token_.IsDefault()) {
    _impl_.next_page_token_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.ListAppsResponse.next_page_token)
}

// int32 total_size = 3;
inline void ListAppsResponse::clear_total_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_size_ = 0;
}
inline ::int32_t ListAppsResponse::total_size() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.ListAppsResponse.total_size)
  return _internal_total_size();
}
inline void ListAppsResponse::set_total_size(::int32_t value) {
  _internal_set_total_size(value);
  // @@protoc_insertion_point(field_set:ownmfa.api.ListAppsResponse.total_size)
}
inline ::int32_t ListAppsResponse::_internal_total_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.total_size_;
}
inline void ListAppsResponse::_internal_set_total_size(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_size_ = value;
}

// -------------------------------------------------------------------

// SoftwareHOTPMethod

// .ownmfa.api.Hash hash = 1;
inline void SoftwareHOTPMethod::clear_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hash_ = 0;
}
inline ::ownmfa::api::Hash SoftwareHOTPMethod::hash() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.SoftwareHOTPMethod.hash)
  return _internal_hash();
}
inline void SoftwareHOTPMethod::set_hash(::ownmfa::api::Hash value) {
  _internal_set_hash(value);
  // @@protoc_insertion_point(field_set:ownmfa.api.SoftwareHOTPMethod.hash)
}
inline ::ownmfa::api::Hash SoftwareHOTPMethod::_internal_hash() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::ownmfa::api::Hash>(_impl_.hash_);
}
inline void SoftwareHOTPMethod::_internal_set_hash(::ownmfa::api::Hash value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hash_ = value;
}

// int32 digits = 2 [(.validate.rules) = {
inline void SoftwareHOTPMethod::clear_digits() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.digits_ = 0;
}
inline ::int32_t SoftwareHOTPMethod::digits() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.SoftwareHOTPMethod.digits)
  return _internal_digits();
}
inline void SoftwareHOTPMethod::set_digits(::int32_t value) {
  _internal_set_digits(value);
  // @@protoc_insertion_point(field_set:ownmfa.api.SoftwareHOTPMethod.digits)
}
inline ::int32_t SoftwareHOTPMethod::_internal_digits() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.digits_;
}
inline void SoftwareHOTPMethod::_internal_set_digits(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.digits_ = value;
}

// int32 counter = 3;
inline void SoftwareHOTPMethod::clear_counter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.counter_ = 0;
}
inline ::int32_t SoftwareHOTPMethod::counter() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.SoftwareHOTPMethod.counter)
  return _internal_counter();
}
inline void SoftwareHOTPMethod::set_counter(::int32_t value) {
  _internal_set_counter(value);
  // @@protoc_insertion_point(field_set:ownmfa.api.SoftwareHOTPMethod.counter)
}
inline ::int32_t SoftwareHOTPMethod::_internal_counter() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.counter_;
}
inline void SoftwareHOTPMethod::_internal_set_counter(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.counter_ = value;
}

// string account_name = 4 [(.validate.rules) = {
inline void SoftwareHOTPMethod::clear_account_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.account_name_.ClearToEmpty();
}
inline const std::string& SoftwareHOTPMethod::account_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.SoftwareHOTPMethod.account_name)
  return _internal_account_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SoftwareHOTPMethod::set_account_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.account_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ownmfa.api.SoftwareHOTPMethod.account_name)
}
inline std::string* SoftwareHOTPMethod::mutable_account_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_account_name();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.SoftwareHOTPMethod.account_name)
  return _s;
}
inline const std::string& SoftwareHOTPMethod::_internal_account_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.account_name_.Get();
}
inline void SoftwareHOTPMethod::_internal_set_account_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.account_name_.Set(value, GetArena());
}
inline std::string* SoftwareHOTPMethod::_internal_mutable_account_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.account_name_.Mutable( GetArena());
}
inline std::string* SoftwareHOTPMethod::release_account_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ownmfa.api.SoftwareHOTPMethod.account_name)
  return _impl_.account_name_.Release();
}
inline void SoftwareHOTPMethod::set_allocated_account_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.account_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.account_name_.IsDefault()) {
    _impl_.account_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.SoftwareHOTPMethod.account_name)
}

// -------------------------------------------------------------------

// SoftwareTOTPMethod

// .ownmfa.api.Hash hash = 1;
inline void SoftwareTOTPMethod::clear_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hash_ = 0;
}
inline ::ownmfa::api::Hash SoftwareTOTPMethod::hash() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.SoftwareTOTPMethod.hash)
  return _internal_hash();
}
inline void SoftwareTOTPMethod::set_hash(::ownmfa::api::Hash value) {
  _internal_set_hash(value);
  // @@protoc_insertion_point(field_set:ownmfa.api.SoftwareTOTPMethod.hash)
}
inline ::ownmfa::api::Hash SoftwareTOTPMethod::_internal_hash() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::ownmfa::api::Hash>(_impl_.hash_);
}
inline void SoftwareTOTPMethod::_internal_set_hash(::ownmfa::api::Hash value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hash_ = value;
}

// int32 digits = 2 [(.validate.rules) = {
inline void SoftwareTOTPMethod::clear_digits() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.digits_ = 0;
}
inline ::int32_t SoftwareTOTPMethod::digits() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.SoftwareTOTPMethod.digits)
  return _internal_digits();
}
inline void SoftwareTOTPMethod::set_digits(::int32_t value) {
  _internal_set_digits(value);
  // @@protoc_insertion_point(field_set:ownmfa.api.SoftwareTOTPMethod.digits)
}
inline ::int32_t SoftwareTOTPMethod::_internal_digits() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.digits_;
}
inline void SoftwareTOTPMethod::_internal_set_digits(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.digits_ = value;
}

// string account_name = 3 [(.validate.rules) = {
inline void SoftwareTOTPMethod::clear_account_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.account_name_.ClearToEmpty();
}
inline const std::string& SoftwareTOTPMethod::account_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.SoftwareTOTPMethod.account_name)
  return _internal_account_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SoftwareTOTPMethod::set_account_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.account_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ownmfa.api.SoftwareTOTPMethod.account_name)
}
inline std::string* SoftwareTOTPMethod::mutable_account_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_account_name();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.SoftwareTOTPMethod.account_name)
  return _s;
}
inline const std::string& SoftwareTOTPMethod::_internal_account_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.account_name_.Get();
}
inline void SoftwareTOTPMethod::_internal_set_account_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.account_name_.Set(value, GetArena());
}
inline std::string* SoftwareTOTPMethod::_internal_mutable_account_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.account_name_.Mutable( GetArena());
}
inline std::string* SoftwareTOTPMethod::release_account_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ownmfa.api.SoftwareTOTPMethod.account_name)
  return _impl_.account_name_.Release();
}
inline void SoftwareTOTPMethod::set_allocated_account_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.account_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.account_name_.IsDefault()) {
    _impl_.account_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.SoftwareTOTPMethod.account_name)
}

// -------------------------------------------------------------------

// GoogleAuthHOTPMethod

// string account_name = 1 [(.validate.rules) = {
inline void GoogleAuthHOTPMethod::clear_account_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.account_name_.ClearToEmpty();
}
inline const std::string& GoogleAuthHOTPMethod::account_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.GoogleAuthHOTPMethod.account_name)
  return _internal_account_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GoogleAuthHOTPMethod::set_account_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.account_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ownmfa.api.GoogleAuthHOTPMethod.account_name)
}
inline std::string* GoogleAuthHOTPMethod::mutable_account_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_account_name();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.GoogleAuthHOTPMethod.account_name)
  return _s;
}
inline const std::string& GoogleAuthHOTPMethod::_internal_account_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.account_name_.Get();
}
inline void GoogleAuthHOTPMethod::_internal_set_account_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.account_name_.Set(value, GetArena());
}
inline std::string* GoogleAuthHOTPMethod::_internal_mutable_account_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.account_name_.Mutable( GetArena());
}
inline std::string* GoogleAuthHOTPMethod::release_account_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ownmfa.api.GoogleAuthHOTPMethod.account_name)
  return _impl_.account_name_.Release();
}
inline void GoogleAuthHOTPMethod::set_allocated_account_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.account_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.account_name_.IsDefault()) {
    _impl_.account_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.GoogleAuthHOTPMethod.account_name)
}

// -------------------------------------------------------------------

// GoogleAuthTOTPMethod

// string account_name = 1 [(.validate.rules) = {
inline void GoogleAuthTOTPMethod::clear_account_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.account_name_.ClearToEmpty();
}
inline const std::string& GoogleAuthTOTPMethod::account_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.GoogleAuthTOTPMethod.account_name)
  return _internal_account_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GoogleAuthTOTPMethod::set_account_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.account_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ownmfa.api.GoogleAuthTOTPMethod.account_name)
}
inline std::string* GoogleAuthTOTPMethod::mutable_account_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_account_name();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.GoogleAuthTOTPMethod.account_name)
  return _s;
}
inline const std::string& GoogleAuthTOTPMethod::_internal_account_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.account_name_.Get();
}
inline void GoogleAuthTOTPMethod::_internal_set_account_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.account_name_.Set(value, GetArena());
}
inline std::string* GoogleAuthTOTPMethod::_internal_mutable_account_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.account_name_.Mutable( GetArena());
}
inline std::string* GoogleAuthTOTPMethod::release_account_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ownmfa.api.GoogleAuthTOTPMethod.account_name)
  return _impl_.account_name_.Release();
}
inline void GoogleAuthTOTPMethod::set_allocated_account_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.account_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.account_name_.IsDefault()) {
    _impl_.account_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.GoogleAuthTOTPMethod.account_name)
}

// -------------------------------------------------------------------

// AppleiOSTOTPMethod

// -------------------------------------------------------------------

// HardwareHOTPMethod

// .ownmfa.api.Hash hash = 1;
inline void HardwareHOTPMethod::clear_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hash_ = 0;
}
inline ::ownmfa::api::Hash HardwareHOTPMethod::hash() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.HardwareHOTPMethod.hash)
  return _internal_hash();
}
inline void HardwareHOTPMethod::set_hash(::ownmfa::api::Hash value) {
  _internal_set_hash(value);
  // @@protoc_insertion_point(field_set:ownmfa.api.HardwareHOTPMethod.hash)
}
inline ::ownmfa::api::Hash HardwareHOTPMethod::_internal_hash() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::ownmfa::api::Hash>(_impl_.hash_);
}
inline void HardwareHOTPMethod::_internal_set_hash(::ownmfa::api::Hash value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hash_ = value;
}

// int32 digits = 2 [(.validate.rules) = {
inline void HardwareHOTPMethod::clear_digits() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.digits_ = 0;
}
inline ::int32_t HardwareHOTPMethod::digits() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.HardwareHOTPMethod.digits)
  return _internal_digits();
}
inline void HardwareHOTPMethod::set_digits(::int32_t value) {
  _internal_set_digits(value);
  // @@protoc_insertion_point(field_set:ownmfa.api.HardwareHOTPMethod.digits)
}
inline ::int32_t HardwareHOTPMethod::_internal_digits() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.digits_;
}
inline void HardwareHOTPMethod::_internal_set_digits(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.digits_ = value;
}

// int32 counter = 3;
inline void HardwareHOTPMethod::clear_counter() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.counter_ = 0;
}
inline ::int32_t HardwareHOTPMethod::counter() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.HardwareHOTPMethod.counter)
  return _internal_counter();
}
inline void HardwareHOTPMethod::set_counter(::int32_t value) {
  _internal_set_counter(value);
  // @@protoc_insertion_point(field_set:ownmfa.api.HardwareHOTPMethod.counter)
}
inline ::int32_t HardwareHOTPMethod::_internal_counter() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.counter_;
}
inline void HardwareHOTPMethod::_internal_set_counter(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.counter_ = value;
}

// bytes secret = 4 [(.validate.rules) = {
inline void HardwareHOTPMethod::clear_secret() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.secret_.ClearToEmpty();
}
inline const std::string& HardwareHOTPMethod::secret() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.HardwareHOTPMethod.secret)
  return _internal_secret();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HardwareHOTPMethod::set_secret(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.secret_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ownmfa.api.HardwareHOTPMethod.secret)
}
inline std::string* HardwareHOTPMethod::mutable_secret() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_secret();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.HardwareHOTPMethod.secret)
  return _s;
}
inline const std::string& HardwareHOTPMethod::_internal_secret() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.secret_.Get();
}
inline void HardwareHOTPMethod::_internal_set_secret(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.secret_.Set(value, GetArena());
}
inline std::string* HardwareHOTPMethod::_internal_mutable_secret() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.secret_.Mutable( GetArena());
}
inline std::string* HardwareHOTPMethod::release_secret() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ownmfa.api.HardwareHOTPMethod.secret)
  return _impl_.secret_.Release();
}
inline void HardwareHOTPMethod::set_allocated_secret(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.secret_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.secret_.IsDefault()) {
    _impl_.secret_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.HardwareHOTPMethod.secret)
}

// -------------------------------------------------------------------

// HardwareTOTPMethod

// .ownmfa.api.Hash hash = 1;
inline void HardwareTOTPMethod::clear_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hash_ = 0;
}
inline ::ownmfa::api::Hash HardwareTOTPMethod::hash() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.HardwareTOTPMethod.hash)
  return _internal_hash();
}
inline void HardwareTOTPMethod::set_hash(::ownmfa::api::Hash value) {
  _internal_set_hash(value);
  // @@protoc_insertion_point(field_set:ownmfa.api.HardwareTOTPMethod.hash)
}
inline ::ownmfa::api::Hash HardwareTOTPMethod::_internal_hash() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::ownmfa::api::Hash>(_impl_.hash_);
}
inline void HardwareTOTPMethod::_internal_set_hash(::ownmfa::api::Hash value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hash_ = value;
}

// int32 digits = 2 [(.validate.rules) = {
inline void HardwareTOTPMethod::clear_digits() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.digits_ = 0;
}
inline ::int32_t HardwareTOTPMethod::digits() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.HardwareTOTPMethod.digits)
  return _internal_digits();
}
inline void HardwareTOTPMethod::set_digits(::int32_t value) {
  _internal_set_digits(value);
  // @@protoc_insertion_point(field_set:ownmfa.api.HardwareTOTPMethod.digits)
}
inline ::int32_t HardwareTOTPMethod::_internal_digits() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.digits_;
}
inline void HardwareTOTPMethod::_internal_set_digits(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.digits_ = value;
}

// bytes secret = 3 [(.validate.rules) = {
inline void HardwareTOTPMethod::clear_secret() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.secret_.ClearToEmpty();
}
inline const std::string& HardwareTOTPMethod::secret() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.HardwareTOTPMethod.secret)
  return _internal_secret();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HardwareTOTPMethod::set_secret(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.secret_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ownmfa.api.HardwareTOTPMethod.secret)
}
inline std::string* HardwareTOTPMethod::mutable_secret() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_secret();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.HardwareTOTPMethod.secret)
  return _s;
}
inline const std::string& HardwareTOTPMethod::_internal_secret() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.secret_.Get();
}
inline void HardwareTOTPMethod::_internal_set_secret(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.secret_.Set(value, GetArena());
}
inline std::string* HardwareTOTPMethod::_internal_mutable_secret() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.secret_.Mutable( GetArena());
}
inline std::string* HardwareTOTPMethod::release_secret() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ownmfa.api.HardwareTOTPMethod.secret)
  return _impl_.secret_.Release();
}
inline void HardwareTOTPMethod::set_allocated_secret(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.secret_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.secret_.IsDefault()) {
    _impl_.secret_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.HardwareTOTPMethod.secret)
}

// -------------------------------------------------------------------

// SMSMethod

// string phone = 1 [(.validate.rules) = {
inline void SMSMethod::clear_phone() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.phone_.ClearToEmpty();
}
inline const std::string& SMSMethod::phone() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.SMSMethod.phone)
  return _internal_phone();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SMSMethod::set_phone(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.phone_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ownmfa.api.SMSMethod.phone)
}
inline std::string* SMSMethod::mutable_phone() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_phone();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.SMSMethod.phone)
  return _s;
}
inline const std::string& SMSMethod::_internal_phone() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.phone_.Get();
}
inline void SMSMethod::_internal_set_phone(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.phone_.Set(value, GetArena());
}
inline std::string* SMSMethod::_internal_mutable_phone() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.phone_.Mutable( GetArena());
}
inline std::string* SMSMethod::release_phone() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ownmfa.api.SMSMethod.phone)
  return _impl_.phone_.Release();
}
inline void SMSMethod::set_allocated_phone(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.phone_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.phone_.IsDefault()) {
    _impl_.phone_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.SMSMethod.phone)
}

// -------------------------------------------------------------------

// PushoverMethod

// string pushover_key = 1 [(.validate.rules) = {
inline void PushoverMethod::clear_pushover_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pushover_key_.ClearToEmpty();
}
inline const std::string& PushoverMethod::pushover_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.PushoverMethod.pushover_key)
  return _internal_pushover_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void PushoverMethod::set_pushover_key(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pushover_key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ownmfa.api.PushoverMethod.pushover_key)
}
inline std::string* PushoverMethod::mutable_pushover_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_pushover_key();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.PushoverMethod.pushover_key)
  return _s;
}
inline const std::string& PushoverMethod::_internal_pushover_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.pushover_key_.Get();
}
inline void PushoverMethod::_internal_set_pushover_key(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pushover_key_.Set(value, GetArena());
}
inline std::string* PushoverMethod::_internal_mutable_pushover_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.pushover_key_.Mutable( GetArena());
}
inline std::string* PushoverMethod::release_pushover_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ownmfa.api.PushoverMethod.pushover_key)
  return _impl_.pushover_key_.Release();
}
inline void PushoverMethod::set_allocated_pushover_key(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pushover_key_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.pushover_key_.IsDefault()) {
    _impl_.pushover_key_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.PushoverMethod.pushover_key)
}

// -------------------------------------------------------------------

// EmailMethod

// string email = 1 [(.validate.rules) = {
inline void EmailMethod::clear_email() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.email_.ClearToEmpty();
}
inline const std::string& EmailMethod::email() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.EmailMethod.email)
  return _internal_email();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EmailMethod::set_email(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.email_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ownmfa.api.EmailMethod.email)
}
inline std::string* EmailMethod::mutable_email() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.EmailMethod.email)
  return _s;
}
inline const std::string& EmailMethod::_internal_email() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.email_.Get();
}
inline void EmailMethod::_internal_set_email(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.email_.Set(value, GetArena());
}
inline std::string* EmailMethod::_internal_mutable_email() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.email_.Mutable( GetArena());
}
inline std::string* EmailMethod::release_email() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ownmfa.api.EmailMethod.email)
  return _impl_.email_.Release();
}
inline void EmailMethod::set_allocated_email(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.email_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.email_.IsDefault()) {
    _impl_.email_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.EmailMethod.email)
}

// -------------------------------------------------------------------

// BackupsCodesMethod

// int32 passcodes = 1 [(.validate.rules) = {
inline void BackupsCodesMethod::clear_passcodes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.passcodes_ = 0;
}
inline ::int32_t BackupsCodesMethod::passcodes() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.BackupsCodesMethod.passcodes)
  return _internal_passcodes();
}
inline void BackupsCodesMethod::set_passcodes(::int32_t value) {
  _internal_set_passcodes(value);
  // @@protoc_insertion_point(field_set:ownmfa.api.BackupsCodesMethod.passcodes)
}
inline ::int32_t BackupsCodesMethod::_internal_passcodes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.passcodes_;
}
inline void BackupsCodesMethod::_internal_set_passcodes(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.passcodes_ = value;
}

// -------------------------------------------------------------------

// SecurityQuestionsMethod

// string answer = 1 [(.validate.rules) = {
inline void SecurityQuestionsMethod::clear_answer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.answer_.ClearToEmpty();
}
inline const std::string& SecurityQuestionsMethod::answer() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.SecurityQuestionsMethod.answer)
  return _internal_answer();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SecurityQuestionsMethod::set_answer(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.answer_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ownmfa.api.SecurityQuestionsMethod.answer)
}
inline std::string* SecurityQuestionsMethod::mutable_answer() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_answer();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.SecurityQuestionsMethod.answer)
  return _s;
}
inline const std::string& SecurityQuestionsMethod::_internal_answer() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.answer_.Get();
}
inline void SecurityQuestionsMethod::_internal_set_answer(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.answer_.Set(value, GetArena());
}
inline std::string* SecurityQuestionsMethod::_internal_mutable_answer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.answer_.Mutable( GetArena());
}
inline std::string* SecurityQuestionsMethod::release_answer() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ownmfa.api.SecurityQuestionsMethod.answer)
  return _impl_.answer_.Release();
}
inline void SecurityQuestionsMethod::set_allocated_answer(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.answer_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.answer_.IsDefault()) {
    _impl_.answer_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.SecurityQuestionsMethod.answer)
}

// -------------------------------------------------------------------

// Identity

// string id = 1 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline void Identity::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& Identity::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.Identity.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Identity::set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ownmfa.api.Identity.id)
}
inline std::string* Identity::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.Identity.id)
  return _s;
}
inline const std::string& Identity::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void Identity::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(value, GetArena());
}
inline std::string* Identity::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* Identity::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ownmfa.api.Identity.id)
  return _impl_.id_.Release();
}
inline void Identity::set_allocated_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.Identity.id)
}

// string org_id = 2 [json_name = "orgID", (.google.api.field_behavior) = OUTPUT_ONLY];
inline void Identity::clear_org_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.org_id_.ClearToEmpty();
}
inline const std::string& Identity::org_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.Identity.org_id)
  return _internal_org_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Identity::set_org_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.org_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ownmfa.api.Identity.org_id)
}
inline std::string* Identity::mutable_org_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_org_id();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.Identity.org_id)
  return _s;
}
inline const std::string& Identity::_internal_org_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.org_id_.Get();
}
inline void Identity::_internal_set_org_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.org_id_.Set(value, GetArena());
}
inline std::string* Identity::_internal_mutable_org_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.org_id_.Mutable( GetArena());
}
inline std::string* Identity::release_org_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ownmfa.api.Identity.org_id)
  return _impl_.org_id_.Release();
}
inline void Identity::set_allocated_org_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.org_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.org_id_.IsDefault()) {
    _impl_.org_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.Identity.org_id)
}

// string app_id = 3 [json_name = "appID", (.google.api.field_behavior) = OUTPUT_ONLY];
inline void Identity::clear_app_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.app_id_.ClearToEmpty();
}
inline const std::string& Identity::app_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.Identity.app_id)
  return _internal_app_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Identity::set_app_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.app_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ownmfa.api.Identity.app_id)
}
inline std::string* Identity::mutable_app_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_app_id();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.Identity.app_id)
  return _s;
}
inline const std::string& Identity::_internal_app_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.app_id_.Get();
}
inline void Identity::_internal_set_app_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.app_id_.Set(value, GetArena());
}
inline std::string* Identity::_internal_mutable_app_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.app_id_.Mutable( GetArena());
}
inline std::string* Identity::release_app_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ownmfa.api.Identity.app_id)
  return _impl_.app_id_.Release();
}
inline void Identity::set_allocated_app_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.app_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.app_id_.IsDefault()) {
    _impl_.app_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.Identity.app_id)
}

// string comment = 4 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline void Identity::clear_comment() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.comment_.ClearToEmpty();
}
inline const std::string& Identity::comment() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.Identity.comment)
  return _internal_comment();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Identity::set_comment(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.comment_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ownmfa.api.Identity.comment)
}
inline std::string* Identity::mutable_comment() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_comment();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.Identity.comment)
  return _s;
}
inline const std::string& Identity::_internal_comment() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.comment_.Get();
}
inline void Identity::_internal_set_comment(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.comment_.Set(value, GetArena());
}
inline std::string* Identity::_internal_mutable_comment() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.comment_.Mutable( GetArena());
}
inline std::string* Identity::release_comment() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ownmfa.api.Identity.comment)
  return _impl_.comment_.Release();
}
inline void Identity::set_allocated_comment(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.comment_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.comment_.IsDefault()) {
    _impl_.comment_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.Identity.comment)
}

// .ownmfa.api.IdentityStatus status = 5 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline void Identity::clear_status() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = 0;
}
inline ::ownmfa::api::IdentityStatus Identity::status() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.Identity.status)
  return _internal_status();
}
inline void Identity::set_status(::ownmfa::api::IdentityStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:ownmfa.api.Identity.status)
}
inline ::ownmfa::api::IdentityStatus Identity::_internal_status() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::ownmfa::api::IdentityStatus>(_impl_.status_);
}
inline void Identity::_internal_set_status(::ownmfa::api::IdentityStatus value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.status_ = value;
}

// .ownmfa.api.SoftwareHOTPMethod software_hotp_method = 16 [json_name = "softwareHOTPMethod"];
inline bool Identity::has_software_hotp_method() const {
  return method_oneof_case() == kSoftwareHotpMethod;
}
inline bool Identity::_internal_has_software_hotp_method() const {
  return method_oneof_case() == kSoftwareHotpMethod;
}
inline void Identity::set_has_software_hotp_method() {
  _impl_._oneof_case_[0] = kSoftwareHotpMethod;
}
inline void Identity::clear_software_hotp_method() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (method_oneof_case() == kSoftwareHotpMethod) {
    if (GetArena() == nullptr) {
      delete _impl_.method_oneof_.software_hotp_method_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.method_oneof_.software_hotp_method_);
    }
    clear_has_method_oneof();
  }
}
inline ::ownmfa::api::SoftwareHOTPMethod* Identity::release_software_hotp_method() {
  // @@protoc_insertion_point(field_release:ownmfa.api.Identity.software_hotp_method)
  if (method_oneof_case() == kSoftwareHotpMethod) {
    clear_has_method_oneof();
    auto* temp = _impl_.method_oneof_.software_hotp_method_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.method_oneof_.software_hotp_method_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ownmfa::api::SoftwareHOTPMethod& Identity::_internal_software_hotp_method() const {
  return method_oneof_case() == kSoftwareHotpMethod ? *_impl_.method_oneof_.software_hotp_method_ : reinterpret_cast<::ownmfa::api::SoftwareHOTPMethod&>(::ownmfa::api::_SoftwareHOTPMethod_default_instance_);
}
inline const ::ownmfa::api::SoftwareHOTPMethod& Identity::software_hotp_method() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.Identity.software_hotp_method)
  return _internal_software_hotp_method();
}
inline ::ownmfa::api::SoftwareHOTPMethod* Identity::unsafe_arena_release_software_hotp_method() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ownmfa.api.Identity.software_hotp_method)
  if (method_oneof_case() == kSoftwareHotpMethod) {
    clear_has_method_oneof();
    auto* temp = _impl_.method_oneof_.software_hotp_method_;
    _impl_.method_oneof_.software_hotp_method_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Identity::unsafe_arena_set_allocated_software_hotp_method(::ownmfa::api::SoftwareHOTPMethod* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_method_oneof();
  if (value) {
    set_has_software_hotp_method();
    _impl_.method_oneof_.software_hotp_method_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ownmfa.api.Identity.software_hotp_method)
}
inline ::ownmfa::api::SoftwareHOTPMethod* Identity::_internal_mutable_software_hotp_method() {
  if (method_oneof_case() != kSoftwareHotpMethod) {
    clear_method_oneof();
    set_has_software_hotp_method();
    _impl_.method_oneof_.software_hotp_method_ =
        ::google::protobuf::Message::DefaultConstruct<::ownmfa::api::SoftwareHOTPMethod>(GetArena());
  }
  return _impl_.method_oneof_.software_hotp_method_;
}
inline ::ownmfa::api::SoftwareHOTPMethod* Identity::mutable_software_hotp_method() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ownmfa::api::SoftwareHOTPMethod* _msg = _internal_mutable_software_hotp_method();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.Identity.software_hotp_method)
  return _msg;
}

// .ownmfa.api.SoftwareTOTPMethod software_totp_method = 6 [json_name = "softwareTOTPMethod"];
inline bool Identity::has_software_totp_method() const {
  return method_oneof_case() == kSoftwareTotpMethod;
}
inline bool Identity::_internal_has_software_totp_method() const {
  return method_oneof_case() == kSoftwareTotpMethod;
}
inline void Identity::set_has_software_totp_method() {
  _impl_._oneof_case_[0] = kSoftwareTotpMethod;
}
inline void Identity::clear_software_totp_method() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (method_oneof_case() == kSoftwareTotpMethod) {
    if (GetArena() == nullptr) {
      delete _impl_.method_oneof_.software_totp_method_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.method_oneof_.software_totp_method_);
    }
    clear_has_method_oneof();
  }
}
inline ::ownmfa::api::SoftwareTOTPMethod* Identity::release_software_totp_method() {
  // @@protoc_insertion_point(field_release:ownmfa.api.Identity.software_totp_method)
  if (method_oneof_case() == kSoftwareTotpMethod) {
    clear_has_method_oneof();
    auto* temp = _impl_.method_oneof_.software_totp_method_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.method_oneof_.software_totp_method_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ownmfa::api::SoftwareTOTPMethod& Identity::_internal_software_totp_method() const {
  return method_oneof_case() == kSoftwareTotpMethod ? *_impl_.method_oneof_.software_totp_method_ : reinterpret_cast<::ownmfa::api::SoftwareTOTPMethod&>(::ownmfa::api::_SoftwareTOTPMethod_default_instance_);
}
inline const ::ownmfa::api::SoftwareTOTPMethod& Identity::software_totp_method() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.Identity.software_totp_method)
  return _internal_software_totp_method();
}
inline ::ownmfa::api::SoftwareTOTPMethod* Identity::unsafe_arena_release_software_totp_method() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ownmfa.api.Identity.software_totp_method)
  if (method_oneof_case() == kSoftwareTotpMethod) {
    clear_has_method_oneof();
    auto* temp = _impl_.method_oneof_.software_totp_method_;
    _impl_.method_oneof_.software_totp_method_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Identity::unsafe_arena_set_allocated_software_totp_method(::ownmfa::api::SoftwareTOTPMethod* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_method_oneof();
  if (value) {
    set_has_software_totp_method();
    _impl_.method_oneof_.software_totp_method_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ownmfa.api.Identity.software_totp_method)
}
inline ::ownmfa::api::SoftwareTOTPMethod* Identity::_internal_mutable_software_totp_method() {
  if (method_oneof_case() != kSoftwareTotpMethod) {
    clear_method_oneof();
    set_has_software_totp_method();
    _impl_.method_oneof_.software_totp_method_ =
        ::google::protobuf::Message::DefaultConstruct<::ownmfa::api::SoftwareTOTPMethod>(GetArena());
  }
  return _impl_.method_oneof_.software_totp_method_;
}
inline ::ownmfa::api::SoftwareTOTPMethod* Identity::mutable_software_totp_method() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ownmfa::api::SoftwareTOTPMethod* _msg = _internal_mutable_software_totp_method();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.Identity.software_totp_method)
  return _msg;
}

// .ownmfa.api.GoogleAuthHOTPMethod google_auth_hotp_method = 17 [json_name = "googleAuthHOTPMethod"];
inline bool Identity::has_google_auth_hotp_method() const {
  return method_oneof_case() == kGoogleAuthHotpMethod;
}
inline bool Identity::_internal_has_google_auth_hotp_method() const {
  return method_oneof_case() == kGoogleAuthHotpMethod;
}
inline void Identity::set_has_google_auth_hotp_method() {
  _impl_._oneof_case_[0] = kGoogleAuthHotpMethod;
}
inline void Identity::clear_google_auth_hotp_method() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (method_oneof_case() == kGoogleAuthHotpMethod) {
    if (GetArena() == nullptr) {
      delete _impl_.method_oneof_.google_auth_hotp_method_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.method_oneof_.google_auth_hotp_method_);
    }
    clear_has_method_oneof();
  }
}
inline ::ownmfa::api::GoogleAuthHOTPMethod* Identity::release_google_auth_hotp_method() {
  // @@protoc_insertion_point(field_release:ownmfa.api.Identity.google_auth_hotp_method)
  if (method_oneof_case() == kGoogleAuthHotpMethod) {
    clear_has_method_oneof();
    auto* temp = _impl_.method_oneof_.google_auth_hotp_method_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.method_oneof_.google_auth_hotp_method_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ownmfa::api::GoogleAuthHOTPMethod& Identity::_internal_google_auth_hotp_method() const {
  return method_oneof_case() == kGoogleAuthHotpMethod ? *_impl_.method_oneof_.google_auth_hotp_method_ : reinterpret_cast<::ownmfa::api::GoogleAuthHOTPMethod&>(::ownmfa::api::_GoogleAuthHOTPMethod_default_instance_);
}
inline const ::ownmfa::api::GoogleAuthHOTPMethod& Identity::google_auth_hotp_method() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.Identity.google_auth_hotp_method)
  return _internal_google_auth_hotp_method();
}
inline ::ownmfa::api::GoogleAuthHOTPMethod* Identity::unsafe_arena_release_google_auth_hotp_method() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ownmfa.api.Identity.google_auth_hotp_method)
  if (method_oneof_case() == kGoogleAuthHotpMethod) {
    clear_has_method_oneof();
    auto* temp = _impl_.method_oneof_.google_auth_hotp_method_;
    _impl_.method_oneof_.google_auth_hotp_method_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Identity::unsafe_arena_set_allocated_google_auth_hotp_method(::ownmfa::api::GoogleAuthHOTPMethod* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_method_oneof();
  if (value) {
    set_has_google_auth_hotp_method();
    _impl_.method_oneof_.google_auth_hotp_method_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ownmfa.api.Identity.google_auth_hotp_method)
}
inline ::ownmfa::api::GoogleAuthHOTPMethod* Identity::_internal_mutable_google_auth_hotp_method() {
  if (method_oneof_case() != kGoogleAuthHotpMethod) {
    clear_method_oneof();
    set_has_google_auth_hotp_method();
    _impl_.method_oneof_.google_auth_hotp_method_ =
        ::google::protobuf::Message::DefaultConstruct<::ownmfa::api::GoogleAuthHOTPMethod>(GetArena());
  }
  return _impl_.method_oneof_.google_auth_hotp_method_;
}
inline ::ownmfa::api::GoogleAuthHOTPMethod* Identity::mutable_google_auth_hotp_method() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ownmfa::api::GoogleAuthHOTPMethod* _msg = _internal_mutable_google_auth_hotp_method();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.Identity.google_auth_hotp_method)
  return _msg;
}

// .ownmfa.api.GoogleAuthTOTPMethod google_auth_totp_method = 7 [json_name = "googleAuthTOTPMethod"];
inline bool Identity::has_google_auth_totp_method() const {
  return method_oneof_case() == kGoogleAuthTotpMethod;
}
inline bool Identity::_internal_has_google_auth_totp_method() const {
  return method_oneof_case() == kGoogleAuthTotpMethod;
}
inline void Identity::set_has_google_auth_totp_method() {
  _impl_._oneof_case_[0] = kGoogleAuthTotpMethod;
}
inline void Identity::clear_google_auth_totp_method() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (method_oneof_case() == kGoogleAuthTotpMethod) {
    if (GetArena() == nullptr) {
      delete _impl_.method_oneof_.google_auth_totp_method_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.method_oneof_.google_auth_totp_method_);
    }
    clear_has_method_oneof();
  }
}
inline ::ownmfa::api::GoogleAuthTOTPMethod* Identity::release_google_auth_totp_method() {
  // @@protoc_insertion_point(field_release:ownmfa.api.Identity.google_auth_totp_method)
  if (method_oneof_case() == kGoogleAuthTotpMethod) {
    clear_has_method_oneof();
    auto* temp = _impl_.method_oneof_.google_auth_totp_method_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.method_oneof_.google_auth_totp_method_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ownmfa::api::GoogleAuthTOTPMethod& Identity::_internal_google_auth_totp_method() const {
  return method_oneof_case() == kGoogleAuthTotpMethod ? *_impl_.method_oneof_.google_auth_totp_method_ : reinterpret_cast<::ownmfa::api::GoogleAuthTOTPMethod&>(::ownmfa::api::_GoogleAuthTOTPMethod_default_instance_);
}
inline const ::ownmfa::api::GoogleAuthTOTPMethod& Identity::google_auth_totp_method() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.Identity.google_auth_totp_method)
  return _internal_google_auth_totp_method();
}
inline ::ownmfa::api::GoogleAuthTOTPMethod* Identity::unsafe_arena_release_google_auth_totp_method() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ownmfa.api.Identity.google_auth_totp_method)
  if (method_oneof_case() == kGoogleAuthTotpMethod) {
    clear_has_method_oneof();
    auto* temp = _impl_.method_oneof_.google_auth_totp_method_;
    _impl_.method_oneof_.google_auth_totp_method_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Identity::unsafe_arena_set_allocated_google_auth_totp_method(::ownmfa::api::GoogleAuthTOTPMethod* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_method_oneof();
  if (value) {
    set_has_google_auth_totp_method();
    _impl_.method_oneof_.google_auth_totp_method_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ownmfa.api.Identity.google_auth_totp_method)
}
inline ::ownmfa::api::GoogleAuthTOTPMethod* Identity::_internal_mutable_google_auth_totp_method() {
  if (method_oneof_case() != kGoogleAuthTotpMethod) {
    clear_method_oneof();
    set_has_google_auth_totp_method();
    _impl_.method_oneof_.google_auth_totp_method_ =
        ::google::protobuf::Message::DefaultConstruct<::ownmfa::api::GoogleAuthTOTPMethod>(GetArena());
  }
  return _impl_.method_oneof_.google_auth_totp_method_;
}
inline ::ownmfa::api::GoogleAuthTOTPMethod* Identity::mutable_google_auth_totp_method() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ownmfa::api::GoogleAuthTOTPMethod* _msg = _internal_mutable_google_auth_totp_method();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.Identity.google_auth_totp_method)
  return _msg;
}

// .ownmfa.api.AppleiOSTOTPMethod apple_ios_totp_method = 22 [json_name = "appleiOSTOTPMethod"];
inline bool Identity::has_apple_ios_totp_method() const {
  return method_oneof_case() == kAppleIosTotpMethod;
}
inline bool Identity::_internal_has_apple_ios_totp_method() const {
  return method_oneof_case() == kAppleIosTotpMethod;
}
inline void Identity::set_has_apple_ios_totp_method() {
  _impl_._oneof_case_[0] = kAppleIosTotpMethod;
}
inline void Identity::clear_apple_ios_totp_method() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (method_oneof_case() == kAppleIosTotpMethod) {
    if (GetArena() == nullptr) {
      delete _impl_.method_oneof_.apple_ios_totp_method_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.method_oneof_.apple_ios_totp_method_);
    }
    clear_has_method_oneof();
  }
}
inline ::ownmfa::api::AppleiOSTOTPMethod* Identity::release_apple_ios_totp_method() {
  // @@protoc_insertion_point(field_release:ownmfa.api.Identity.apple_ios_totp_method)
  if (method_oneof_case() == kAppleIosTotpMethod) {
    clear_has_method_oneof();
    auto* temp = _impl_.method_oneof_.apple_ios_totp_method_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.method_oneof_.apple_ios_totp_method_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ownmfa::api::AppleiOSTOTPMethod& Identity::_internal_apple_ios_totp_method() const {
  return method_oneof_case() == kAppleIosTotpMethod ? *_impl_.method_oneof_.apple_ios_totp_method_ : reinterpret_cast<::ownmfa::api::AppleiOSTOTPMethod&>(::ownmfa::api::_AppleiOSTOTPMethod_default_instance_);
}
inline const ::ownmfa::api::AppleiOSTOTPMethod& Identity::apple_ios_totp_method() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.Identity.apple_ios_totp_method)
  return _internal_apple_ios_totp_method();
}
inline ::ownmfa::api::AppleiOSTOTPMethod* Identity::unsafe_arena_release_apple_ios_totp_method() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ownmfa.api.Identity.apple_ios_totp_method)
  if (method_oneof_case() == kAppleIosTotpMethod) {
    clear_has_method_oneof();
    auto* temp = _impl_.method_oneof_.apple_ios_totp_method_;
    _impl_.method_oneof_.apple_ios_totp_method_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Identity::unsafe_arena_set_allocated_apple_ios_totp_method(::ownmfa::api::AppleiOSTOTPMethod* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_method_oneof();
  if (value) {
    set_has_apple_ios_totp_method();
    _impl_.method_oneof_.apple_ios_totp_method_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ownmfa.api.Identity.apple_ios_totp_method)
}
inline ::ownmfa::api::AppleiOSTOTPMethod* Identity::_internal_mutable_apple_ios_totp_method() {
  if (method_oneof_case() != kAppleIosTotpMethod) {
    clear_method_oneof();
    set_has_apple_ios_totp_method();
    _impl_.method_oneof_.apple_ios_totp_method_ =
        ::google::protobuf::Message::DefaultConstruct<::ownmfa::api::AppleiOSTOTPMethod>(GetArena());
  }
  return _impl_.method_oneof_.apple_ios_totp_method_;
}
inline ::ownmfa::api::AppleiOSTOTPMethod* Identity::mutable_apple_ios_totp_method() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ownmfa::api::AppleiOSTOTPMethod* _msg = _internal_mutable_apple_ios_totp_method();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.Identity.apple_ios_totp_method)
  return _msg;
}

// .ownmfa.api.HardwareHOTPMethod hardware_hotp_method = 18 [json_name = "hardwareHOTPMethod"];
inline bool Identity::has_hardware_hotp_method() const {
  return method_oneof_case() == kHardwareHotpMethod;
}
inline bool Identity::_internal_has_hardware_hotp_method() const {
  return method_oneof_case() == kHardwareHotpMethod;
}
inline void Identity::set_has_hardware_hotp_method() {
  _impl_._oneof_case_[0] = kHardwareHotpMethod;
}
inline void Identity::clear_hardware_hotp_method() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (method_oneof_case() == kHardwareHotpMethod) {
    if (GetArena() == nullptr) {
      delete _impl_.method_oneof_.hardware_hotp_method_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.method_oneof_.hardware_hotp_method_);
    }
    clear_has_method_oneof();
  }
}
inline ::ownmfa::api::HardwareHOTPMethod* Identity::release_hardware_hotp_method() {
  // @@protoc_insertion_point(field_release:ownmfa.api.Identity.hardware_hotp_method)
  if (method_oneof_case() == kHardwareHotpMethod) {
    clear_has_method_oneof();
    auto* temp = _impl_.method_oneof_.hardware_hotp_method_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.method_oneof_.hardware_hotp_method_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ownmfa::api::HardwareHOTPMethod& Identity::_internal_hardware_hotp_method() const {
  return method_oneof_case() == kHardwareHotpMethod ? *_impl_.method_oneof_.hardware_hotp_method_ : reinterpret_cast<::ownmfa::api::HardwareHOTPMethod&>(::ownmfa::api::_HardwareHOTPMethod_default_instance_);
}
inline const ::ownmfa::api::HardwareHOTPMethod& Identity::hardware_hotp_method() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.Identity.hardware_hotp_method)
  return _internal_hardware_hotp_method();
}
inline ::ownmfa::api::HardwareHOTPMethod* Identity::unsafe_arena_release_hardware_hotp_method() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ownmfa.api.Identity.hardware_hotp_method)
  if (method_oneof_case() == kHardwareHotpMethod) {
    clear_has_method_oneof();
    auto* temp = _impl_.method_oneof_.hardware_hotp_method_;
    _impl_.method_oneof_.hardware_hotp_method_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Identity::unsafe_arena_set_allocated_hardware_hotp_method(::ownmfa::api::HardwareHOTPMethod* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_method_oneof();
  if (value) {
    set_has_hardware_hotp_method();
    _impl_.method_oneof_.hardware_hotp_method_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ownmfa.api.Identity.hardware_hotp_method)
}
inline ::ownmfa::api::HardwareHOTPMethod* Identity::_internal_mutable_hardware_hotp_method() {
  if (method_oneof_case() != kHardwareHotpMethod) {
    clear_method_oneof();
    set_has_hardware_hotp_method();
    _impl_.method_oneof_.hardware_hotp_method_ =
        ::google::protobuf::Message::DefaultConstruct<::ownmfa::api::HardwareHOTPMethod>(GetArena());
  }
  return _impl_.method_oneof_.hardware_hotp_method_;
}
inline ::ownmfa::api::HardwareHOTPMethod* Identity::mutable_hardware_hotp_method() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ownmfa::api::HardwareHOTPMethod* _msg = _internal_mutable_hardware_hotp_method();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.Identity.hardware_hotp_method)
  return _msg;
}

// .ownmfa.api.HardwareTOTPMethod hardware_totp_method = 19 [json_name = "hardwareTOTPMethod"];
inline bool Identity::has_hardware_totp_method() const {
  return method_oneof_case() == kHardwareTotpMethod;
}
inline bool Identity::_internal_has_hardware_totp_method() const {
  return method_oneof_case() == kHardwareTotpMethod;
}
inline void Identity::set_has_hardware_totp_method() {
  _impl_._oneof_case_[0] = kHardwareTotpMethod;
}
inline void Identity::clear_hardware_totp_method() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (method_oneof_case() == kHardwareTotpMethod) {
    if (GetArena() == nullptr) {
      delete _impl_.method_oneof_.hardware_totp_method_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.method_oneof_.hardware_totp_method_);
    }
    clear_has_method_oneof();
  }
}
inline ::ownmfa::api::HardwareTOTPMethod* Identity::release_hardware_totp_method() {
  // @@protoc_insertion_point(field_release:ownmfa.api.Identity.hardware_totp_method)
  if (method_oneof_case() == kHardwareTotpMethod) {
    clear_has_method_oneof();
    auto* temp = _impl_.method_oneof_.hardware_totp_method_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.method_oneof_.hardware_totp_method_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ownmfa::api::HardwareTOTPMethod& Identity::_internal_hardware_totp_method() const {
  return method_oneof_case() == kHardwareTotpMethod ? *_impl_.method_oneof_.hardware_totp_method_ : reinterpret_cast<::ownmfa::api::HardwareTOTPMethod&>(::ownmfa::api::_HardwareTOTPMethod_default_instance_);
}
inline const ::ownmfa::api::HardwareTOTPMethod& Identity::hardware_totp_method() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.Identity.hardware_totp_method)
  return _internal_hardware_totp_method();
}
inline ::ownmfa::api::HardwareTOTPMethod* Identity::unsafe_arena_release_hardware_totp_method() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ownmfa.api.Identity.hardware_totp_method)
  if (method_oneof_case() == kHardwareTotpMethod) {
    clear_has_method_oneof();
    auto* temp = _impl_.method_oneof_.hardware_totp_method_;
    _impl_.method_oneof_.hardware_totp_method_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Identity::unsafe_arena_set_allocated_hardware_totp_method(::ownmfa::api::HardwareTOTPMethod* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_method_oneof();
  if (value) {
    set_has_hardware_totp_method();
    _impl_.method_oneof_.hardware_totp_method_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ownmfa.api.Identity.hardware_totp_method)
}
inline ::ownmfa::api::HardwareTOTPMethod* Identity::_internal_mutable_hardware_totp_method() {
  if (method_oneof_case() != kHardwareTotpMethod) {
    clear_method_oneof();
    set_has_hardware_totp_method();
    _impl_.method_oneof_.hardware_totp_method_ =
        ::google::protobuf::Message::DefaultConstruct<::ownmfa::api::HardwareTOTPMethod>(GetArena());
  }
  return _impl_.method_oneof_.hardware_totp_method_;
}
inline ::ownmfa::api::HardwareTOTPMethod* Identity::mutable_hardware_totp_method() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ownmfa::api::HardwareTOTPMethod* _msg = _internal_mutable_hardware_totp_method();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.Identity.hardware_totp_method)
  return _msg;
}

// .ownmfa.api.SMSMethod sms_method = 8;
inline bool Identity::has_sms_method() const {
  return method_oneof_case() == kSmsMethod;
}
inline bool Identity::_internal_has_sms_method() const {
  return method_oneof_case() == kSmsMethod;
}
inline void Identity::set_has_sms_method() {
  _impl_._oneof_case_[0] = kSmsMethod;
}
inline void Identity::clear_sms_method() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (method_oneof_case() == kSmsMethod) {
    if (GetArena() == nullptr) {
      delete _impl_.method_oneof_.sms_method_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.method_oneof_.sms_method_);
    }
    clear_has_method_oneof();
  }
}
inline ::ownmfa::api::SMSMethod* Identity::release_sms_method() {
  // @@protoc_insertion_point(field_release:ownmfa.api.Identity.sms_method)
  if (method_oneof_case() == kSmsMethod) {
    clear_has_method_oneof();
    auto* temp = _impl_.method_oneof_.sms_method_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.method_oneof_.sms_method_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ownmfa::api::SMSMethod& Identity::_internal_sms_method() const {
  return method_oneof_case() == kSmsMethod ? *_impl_.method_oneof_.sms_method_ : reinterpret_cast<::ownmfa::api::SMSMethod&>(::ownmfa::api::_SMSMethod_default_instance_);
}
inline const ::ownmfa::api::SMSMethod& Identity::sms_method() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.Identity.sms_method)
  return _internal_sms_method();
}
inline ::ownmfa::api::SMSMethod* Identity::unsafe_arena_release_sms_method() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ownmfa.api.Identity.sms_method)
  if (method_oneof_case() == kSmsMethod) {
    clear_has_method_oneof();
    auto* temp = _impl_.method_oneof_.sms_method_;
    _impl_.method_oneof_.sms_method_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Identity::unsafe_arena_set_allocated_sms_method(::ownmfa::api::SMSMethod* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_method_oneof();
  if (value) {
    set_has_sms_method();
    _impl_.method_oneof_.sms_method_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ownmfa.api.Identity.sms_method)
}
inline ::ownmfa::api::SMSMethod* Identity::_internal_mutable_sms_method() {
  if (method_oneof_case() != kSmsMethod) {
    clear_method_oneof();
    set_has_sms_method();
    _impl_.method_oneof_.sms_method_ =
        ::google::protobuf::Message::DefaultConstruct<::ownmfa::api::SMSMethod>(GetArena());
  }
  return _impl_.method_oneof_.sms_method_;
}
inline ::ownmfa::api::SMSMethod* Identity::mutable_sms_method() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ownmfa::api::SMSMethod* _msg = _internal_mutable_sms_method();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.Identity.sms_method)
  return _msg;
}

// .ownmfa.api.PushoverMethod pushover_method = 20;
inline bool Identity::has_pushover_method() const {
  return method_oneof_case() == kPushoverMethod;
}
inline bool Identity::_internal_has_pushover_method() const {
  return method_oneof_case() == kPushoverMethod;
}
inline void Identity::set_has_pushover_method() {
  _impl_._oneof_case_[0] = kPushoverMethod;
}
inline void Identity::clear_pushover_method() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (method_oneof_case() == kPushoverMethod) {
    if (GetArena() == nullptr) {
      delete _impl_.method_oneof_.pushover_method_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.method_oneof_.pushover_method_);
    }
    clear_has_method_oneof();
  }
}
inline ::ownmfa::api::PushoverMethod* Identity::release_pushover_method() {
  // @@protoc_insertion_point(field_release:ownmfa.api.Identity.pushover_method)
  if (method_oneof_case() == kPushoverMethod) {
    clear_has_method_oneof();
    auto* temp = _impl_.method_oneof_.pushover_method_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.method_oneof_.pushover_method_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ownmfa::api::PushoverMethod& Identity::_internal_pushover_method() const {
  return method_oneof_case() == kPushoverMethod ? *_impl_.method_oneof_.pushover_method_ : reinterpret_cast<::ownmfa::api::PushoverMethod&>(::ownmfa::api::_PushoverMethod_default_instance_);
}
inline const ::ownmfa::api::PushoverMethod& Identity::pushover_method() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.Identity.pushover_method)
  return _internal_pushover_method();
}
inline ::ownmfa::api::PushoverMethod* Identity::unsafe_arena_release_pushover_method() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ownmfa.api.Identity.pushover_method)
  if (method_oneof_case() == kPushoverMethod) {
    clear_has_method_oneof();
    auto* temp = _impl_.method_oneof_.pushover_method_;
    _impl_.method_oneof_.pushover_method_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Identity::unsafe_arena_set_allocated_pushover_method(::ownmfa::api::PushoverMethod* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_method_oneof();
  if (value) {
    set_has_pushover_method();
    _impl_.method_oneof_.pushover_method_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ownmfa.api.Identity.pushover_method)
}
inline ::ownmfa::api::PushoverMethod* Identity::_internal_mutable_pushover_method() {
  if (method_oneof_case() != kPushoverMethod) {
    clear_method_oneof();
    set_has_pushover_method();
    _impl_.method_oneof_.pushover_method_ =
        ::google::protobuf::Message::DefaultConstruct<::ownmfa::api::PushoverMethod>(GetArena());
  }
  return _impl_.method_oneof_.pushover_method_;
}
inline ::ownmfa::api::PushoverMethod* Identity::mutable_pushover_method() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ownmfa::api::PushoverMethod* _msg = _internal_mutable_pushover_method();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.Identity.pushover_method)
  return _msg;
}

// .ownmfa.api.EmailMethod email_method = 9;
inline bool Identity::has_email_method() const {
  return method_oneof_case() == kEmailMethod;
}
inline bool Identity::_internal_has_email_method() const {
  return method_oneof_case() == kEmailMethod;
}
inline void Identity::set_has_email_method() {
  _impl_._oneof_case_[0] = kEmailMethod;
}
inline void Identity::clear_email_method() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (method_oneof_case() == kEmailMethod) {
    if (GetArena() == nullptr) {
      delete _impl_.method_oneof_.email_method_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.method_oneof_.email_method_);
    }
    clear_has_method_oneof();
  }
}
inline ::ownmfa::api::EmailMethod* Identity::release_email_method() {
  // @@protoc_insertion_point(field_release:ownmfa.api.Identity.email_method)
  if (method_oneof_case() == kEmailMethod) {
    clear_has_method_oneof();
    auto* temp = _impl_.method_oneof_.email_method_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.method_oneof_.email_method_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ownmfa::api::EmailMethod& Identity::_internal_email_method() const {
  return method_oneof_case() == kEmailMethod ? *_impl_.method_oneof_.email_method_ : reinterpret_cast<::ownmfa::api::EmailMethod&>(::ownmfa::api::_EmailMethod_default_instance_);
}
inline const ::ownmfa::api::EmailMethod& Identity::email_method() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.Identity.email_method)
  return _internal_email_method();
}
inline ::ownmfa::api::EmailMethod* Identity::unsafe_arena_release_email_method() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ownmfa.api.Identity.email_method)
  if (method_oneof_case() == kEmailMethod) {
    clear_has_method_oneof();
    auto* temp = _impl_.method_oneof_.email_method_;
    _impl_.method_oneof_.email_method_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Identity::unsafe_arena_set_allocated_email_method(::ownmfa::api::EmailMethod* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_method_oneof();
  if (value) {
    set_has_email_method();
    _impl_.method_oneof_.email_method_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ownmfa.api.Identity.email_method)
}
inline ::ownmfa::api::EmailMethod* Identity::_internal_mutable_email_method() {
  if (method_oneof_case() != kEmailMethod) {
    clear_method_oneof();
    set_has_email_method();
    _impl_.method_oneof_.email_method_ =
        ::google::protobuf::Message::DefaultConstruct<::ownmfa::api::EmailMethod>(GetArena());
  }
  return _impl_.method_oneof_.email_method_;
}
inline ::ownmfa::api::EmailMethod* Identity::mutable_email_method() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ownmfa::api::EmailMethod* _msg = _internal_mutable_email_method();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.Identity.email_method)
  return _msg;
}

// .ownmfa.api.BackupsCodesMethod backup_codes_method = 10;
inline bool Identity::has_backup_codes_method() const {
  return method_oneof_case() == kBackupCodesMethod;
}
inline bool Identity::_internal_has_backup_codes_method() const {
  return method_oneof_case() == kBackupCodesMethod;
}
inline void Identity::set_has_backup_codes_method() {
  _impl_._oneof_case_[0] = kBackupCodesMethod;
}
inline void Identity::clear_backup_codes_method() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (method_oneof_case() == kBackupCodesMethod) {
    if (GetArena() == nullptr) {
      delete _impl_.method_oneof_.backup_codes_method_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.method_oneof_.backup_codes_method_);
    }
    clear_has_method_oneof();
  }
}
inline ::ownmfa::api::BackupsCodesMethod* Identity::release_backup_codes_method() {
  // @@protoc_insertion_point(field_release:ownmfa.api.Identity.backup_codes_method)
  if (method_oneof_case() == kBackupCodesMethod) {
    clear_has_method_oneof();
    auto* temp = _impl_.method_oneof_.backup_codes_method_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.method_oneof_.backup_codes_method_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ownmfa::api::BackupsCodesMethod& Identity::_internal_backup_codes_method() const {
  return method_oneof_case() == kBackupCodesMethod ? *_impl_.method_oneof_.backup_codes_method_ : reinterpret_cast<::ownmfa::api::BackupsCodesMethod&>(::ownmfa::api::_BackupsCodesMethod_default_instance_);
}
inline const ::ownmfa::api::BackupsCodesMethod& Identity::backup_codes_method() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.Identity.backup_codes_method)
  return _internal_backup_codes_method();
}
inline ::ownmfa::api::BackupsCodesMethod* Identity::unsafe_arena_release_backup_codes_method() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ownmfa.api.Identity.backup_codes_method)
  if (method_oneof_case() == kBackupCodesMethod) {
    clear_has_method_oneof();
    auto* temp = _impl_.method_oneof_.backup_codes_method_;
    _impl_.method_oneof_.backup_codes_method_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Identity::unsafe_arena_set_allocated_backup_codes_method(::ownmfa::api::BackupsCodesMethod* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_method_oneof();
  if (value) {
    set_has_backup_codes_method();
    _impl_.method_oneof_.backup_codes_method_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ownmfa.api.Identity.backup_codes_method)
}
inline ::ownmfa::api::BackupsCodesMethod* Identity::_internal_mutable_backup_codes_method() {
  if (method_oneof_case() != kBackupCodesMethod) {
    clear_method_oneof();
    set_has_backup_codes_method();
    _impl_.method_oneof_.backup_codes_method_ =
        ::google::protobuf::Message::DefaultConstruct<::ownmfa::api::BackupsCodesMethod>(GetArena());
  }
  return _impl_.method_oneof_.backup_codes_method_;
}
inline ::ownmfa::api::BackupsCodesMethod* Identity::mutable_backup_codes_method() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ownmfa::api::BackupsCodesMethod* _msg = _internal_mutable_backup_codes_method();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.Identity.backup_codes_method)
  return _msg;
}

// .ownmfa.api.SecurityQuestionsMethod security_questions_method = 21;
inline bool Identity::has_security_questions_method() const {
  return method_oneof_case() == kSecurityQuestionsMethod;
}
inline bool Identity::_internal_has_security_questions_method() const {
  return method_oneof_case() == kSecurityQuestionsMethod;
}
inline void Identity::set_has_security_questions_method() {
  _impl_._oneof_case_[0] = kSecurityQuestionsMethod;
}
inline void Identity::clear_security_questions_method() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (method_oneof_case() == kSecurityQuestionsMethod) {
    if (GetArena() == nullptr) {
      delete _impl_.method_oneof_.security_questions_method_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.method_oneof_.security_questions_method_);
    }
    clear_has_method_oneof();
  }
}
inline ::ownmfa::api::SecurityQuestionsMethod* Identity::release_security_questions_method() {
  // @@protoc_insertion_point(field_release:ownmfa.api.Identity.security_questions_method)
  if (method_oneof_case() == kSecurityQuestionsMethod) {
    clear_has_method_oneof();
    auto* temp = _impl_.method_oneof_.security_questions_method_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.method_oneof_.security_questions_method_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ownmfa::api::SecurityQuestionsMethod& Identity::_internal_security_questions_method() const {
  return method_oneof_case() == kSecurityQuestionsMethod ? *_impl_.method_oneof_.security_questions_method_ : reinterpret_cast<::ownmfa::api::SecurityQuestionsMethod&>(::ownmfa::api::_SecurityQuestionsMethod_default_instance_);
}
inline const ::ownmfa::api::SecurityQuestionsMethod& Identity::security_questions_method() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.Identity.security_questions_method)
  return _internal_security_questions_method();
}
inline ::ownmfa::api::SecurityQuestionsMethod* Identity::unsafe_arena_release_security_questions_method() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ownmfa.api.Identity.security_questions_method)
  if (method_oneof_case() == kSecurityQuestionsMethod) {
    clear_has_method_oneof();
    auto* temp = _impl_.method_oneof_.security_questions_method_;
    _impl_.method_oneof_.security_questions_method_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Identity::unsafe_arena_set_allocated_security_questions_method(::ownmfa::api::SecurityQuestionsMethod* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_method_oneof();
  if (value) {
    set_has_security_questions_method();
    _impl_.method_oneof_.security_questions_method_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ownmfa.api.Identity.security_questions_method)
}
inline ::ownmfa::api::SecurityQuestionsMethod* Identity::_internal_mutable_security_questions_method() {
  if (method_oneof_case() != kSecurityQuestionsMethod) {
    clear_method_oneof();
    set_has_security_questions_method();
    _impl_.method_oneof_.security_questions_method_ =
        ::google::protobuf::Message::DefaultConstruct<::ownmfa::api::SecurityQuestionsMethod>(GetArena());
  }
  return _impl_.method_oneof_.security_questions_method_;
}
inline ::ownmfa::api::SecurityQuestionsMethod* Identity::mutable_security_questions_method() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::ownmfa::api::SecurityQuestionsMethod* _msg = _internal_mutable_security_questions_method();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.Identity.security_questions_method)
  return _msg;
}

// .google.protobuf.Timestamp created_at = 14 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline bool Identity::has_created_at() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.created_at_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& Identity::_internal_created_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.created_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& Identity::created_at() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.Identity.created_at)
  return _internal_created_at();
}
inline void Identity::unsafe_arena_set_allocated_created_at(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.created_at_);
  }
  _impl_.created_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ownmfa.api.Identity.created_at)
}
inline ::google::protobuf::Timestamp* Identity::release_created_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* released = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* Identity::unsafe_arena_release_created_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ownmfa.api.Identity.created_at)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Timestamp* temp = _impl_.created_at_;
  _impl_.created_at_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* Identity::_internal_mutable_created_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.created_at_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.created_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.created_at_;
}
inline ::google::protobuf::Timestamp* Identity::mutable_created_at() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_created_at();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.Identity.created_at)
  return _msg;
}
inline void Identity::set_allocated_created_at(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.created_at_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.created_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.Identity.created_at)
}

// .google.protobuf.Timestamp updated_at = 15 [(.google.api.field_behavior) = OUTPUT_ONLY];
inline bool Identity::has_updated_at() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.updated_at_ != nullptr);
  return value;
}
inline const ::google::protobuf::Timestamp& Identity::_internal_updated_at() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::google::protobuf::Timestamp* p = _impl_.updated_at_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Timestamp&>(::google::protobuf::_Timestamp_default_instance_);
}
inline const ::google::protobuf::Timestamp& Identity::updated_at() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.Identity.updated_at)
  return _internal_updated_at();
}
inline void Identity::unsafe_arena_set_allocated_updated_at(::google::protobuf::Timestamp* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.updated_at_);
  }
  _impl_.updated_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ownmfa.api.Identity.updated_at)
}
inline ::google::protobuf::Timestamp* Identity::release_updated_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* released = _impl_.updated_at_;
  _impl_.updated_at_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::google::protobuf::Timestamp* Identity::unsafe_arena_release_updated_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ownmfa.api.Identity.updated_at)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Timestamp* temp = _impl_.updated_at_;
  _impl_.updated_at_ = nullptr;
  return temp;
}
inline ::google::protobuf::Timestamp* Identity::_internal_mutable_updated_at() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.updated_at_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Timestamp>(GetArena());
    _impl_.updated_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(p);
  }
  return _impl_.updated_at_;
}
inline ::google::protobuf::Timestamp* Identity::mutable_updated_at() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::google::protobuf::Timestamp* _msg = _internal_mutable_updated_at();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.Identity.updated_at)
  return _msg;
}
inline void Identity::set_allocated_updated_at(::google::protobuf::Timestamp* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.updated_at_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.updated_at_ = reinterpret_cast<::google::protobuf::Timestamp*>(value);
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.Identity.updated_at)
}

inline bool Identity::has_method_oneof() const {
  return method_oneof_case() != METHOD_ONEOF_NOT_SET;
}
inline void Identity::clear_has_method_oneof() {
  _impl_._oneof_case_[0] = METHOD_ONEOF_NOT_SET;
}
inline Identity::MethodOneofCase Identity::method_oneof_case() const {
  return Identity::MethodOneofCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// CreateIdentityRequest

// .ownmfa.api.Identity identity = 1 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline bool CreateIdentityRequest::has_identity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.identity_ != nullptr);
  return value;
}
inline void CreateIdentityRequest::clear_identity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.identity_ != nullptr) _impl_.identity_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::ownmfa::api::Identity& CreateIdentityRequest::_internal_identity() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::ownmfa::api::Identity* p = _impl_.identity_;
  return p != nullptr ? *p : reinterpret_cast<const ::ownmfa::api::Identity&>(::ownmfa::api::_Identity_default_instance_);
}
inline const ::ownmfa::api::Identity& CreateIdentityRequest::identity() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.CreateIdentityRequest.identity)
  return _internal_identity();
}
inline void CreateIdentityRequest::unsafe_arena_set_allocated_identity(::ownmfa::api::Identity* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.identity_);
  }
  _impl_.identity_ = reinterpret_cast<::ownmfa::api::Identity*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ownmfa.api.CreateIdentityRequest.identity)
}
inline ::ownmfa::api::Identity* CreateIdentityRequest::release_identity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ownmfa::api::Identity* released = _impl_.identity_;
  _impl_.identity_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::ownmfa::api::Identity* CreateIdentityRequest::unsafe_arena_release_identity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ownmfa.api.CreateIdentityRequest.identity)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ownmfa::api::Identity* temp = _impl_.identity_;
  _impl_.identity_ = nullptr;
  return temp;
}
inline ::ownmfa::api::Identity* CreateIdentityRequest::_internal_mutable_identity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.identity_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::ownmfa::api::Identity>(GetArena());
    _impl_.identity_ = reinterpret_cast<::ownmfa::api::Identity*>(p);
  }
  return _impl_.identity_;
}
inline ::ownmfa::api::Identity* CreateIdentityRequest::mutable_identity() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::ownmfa::api::Identity* _msg = _internal_mutable_identity();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.CreateIdentityRequest.identity)
  return _msg;
}
inline void CreateIdentityRequest::set_allocated_identity(::ownmfa::api::Identity* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.identity_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.identity_ = reinterpret_cast<::ownmfa::api::Identity*>(value);
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.CreateIdentityRequest.identity)
}

// -------------------------------------------------------------------

// CreateIdentityResponse

// .ownmfa.api.Identity identity = 1;
inline bool CreateIdentityResponse::has_identity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.identity_ != nullptr);
  return value;
}
inline void CreateIdentityResponse::clear_identity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.identity_ != nullptr) _impl_.identity_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::ownmfa::api::Identity& CreateIdentityResponse::_internal_identity() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::ownmfa::api::Identity* p = _impl_.identity_;
  return p != nullptr ? *p : reinterpret_cast<const ::ownmfa::api::Identity&>(::ownmfa::api::_Identity_default_instance_);
}
inline const ::ownmfa::api::Identity& CreateIdentityResponse::identity() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.CreateIdentityResponse.identity)
  return _internal_identity();
}
inline void CreateIdentityResponse::unsafe_arena_set_allocated_identity(::ownmfa::api::Identity* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.identity_);
  }
  _impl_.identity_ = reinterpret_cast<::ownmfa::api::Identity*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ownmfa.api.CreateIdentityResponse.identity)
}
inline ::ownmfa::api::Identity* CreateIdentityResponse::release_identity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ownmfa::api::Identity* released = _impl_.identity_;
  _impl_.identity_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::ownmfa::api::Identity* CreateIdentityResponse::unsafe_arena_release_identity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ownmfa.api.CreateIdentityResponse.identity)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::ownmfa::api::Identity* temp = _impl_.identity_;
  _impl_.identity_ = nullptr;
  return temp;
}
inline ::ownmfa::api::Identity* CreateIdentityResponse::_internal_mutable_identity() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.identity_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::ownmfa::api::Identity>(GetArena());
    _impl_.identity_ = reinterpret_cast<::ownmfa::api::Identity*>(p);
  }
  return _impl_.identity_;
}
inline ::ownmfa::api::Identity* CreateIdentityResponse::mutable_identity() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::ownmfa::api::Identity* _msg = _internal_mutable_identity();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.CreateIdentityResponse.identity)
  return _msg;
}
inline void CreateIdentityResponse::set_allocated_identity(::ownmfa::api::Identity* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.identity_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.identity_ = reinterpret_cast<::ownmfa::api::Identity*>(value);
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.CreateIdentityResponse.identity)
}

// string secret = 2;
inline void CreateIdentityResponse::clear_secret() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.secret_.ClearToEmpty();
}
inline const std::string& CreateIdentityResponse::secret() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.CreateIdentityResponse.secret)
  return _internal_secret();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreateIdentityResponse::set_secret(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.secret_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ownmfa.api.CreateIdentityResponse.secret)
}
inline std::string* CreateIdentityResponse::mutable_secret() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_secret();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.CreateIdentityResponse.secret)
  return _s;
}
inline const std::string& CreateIdentityResponse::_internal_secret() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.secret_.Get();
}
inline void CreateIdentityResponse::_internal_set_secret(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.secret_.Set(value, GetArena());
}
inline std::string* CreateIdentityResponse::_internal_mutable_secret() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.secret_.Mutable( GetArena());
}
inline std::string* CreateIdentityResponse::release_secret() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ownmfa.api.CreateIdentityResponse.secret)
  return _impl_.secret_.Release();
}
inline void CreateIdentityResponse::set_allocated_secret(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.secret_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.secret_.IsDefault()) {
    _impl_.secret_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.CreateIdentityResponse.secret)
}

// bytes qr = 3;
inline void CreateIdentityResponse::clear_qr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.qr_.ClearToEmpty();
}
inline const std::string& CreateIdentityResponse::qr() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.CreateIdentityResponse.qr)
  return _internal_qr();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreateIdentityResponse::set_qr(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.qr_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ownmfa.api.CreateIdentityResponse.qr)
}
inline std::string* CreateIdentityResponse::mutable_qr() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_qr();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.CreateIdentityResponse.qr)
  return _s;
}
inline const std::string& CreateIdentityResponse::_internal_qr() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.qr_.Get();
}
inline void CreateIdentityResponse::_internal_set_qr(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.qr_.Set(value, GetArena());
}
inline std::string* CreateIdentityResponse::_internal_mutable_qr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.qr_.Mutable( GetArena());
}
inline std::string* CreateIdentityResponse::release_qr() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ownmfa.api.CreateIdentityResponse.qr)
  return _impl_.qr_.Release();
}
inline void CreateIdentityResponse::set_allocated_qr(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.qr_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.qr_.IsDefault()) {
    _impl_.qr_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.CreateIdentityResponse.qr)
}

// repeated string passcodes = 4;
inline int CreateIdentityResponse::_internal_passcodes_size() const {
  return _internal_passcodes().size();
}
inline int CreateIdentityResponse::passcodes_size() const {
  return _internal_passcodes_size();
}
inline void CreateIdentityResponse::clear_passcodes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.passcodes_.Clear();
}
inline std::string* CreateIdentityResponse::add_passcodes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_passcodes()->Add();
  // @@protoc_insertion_point(field_add_mutable:ownmfa.api.CreateIdentityResponse.passcodes)
  return _s;
}
inline const std::string& CreateIdentityResponse::passcodes(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.CreateIdentityResponse.passcodes)
  return _internal_passcodes().Get(index);
}
inline std::string* CreateIdentityResponse::mutable_passcodes(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:ownmfa.api.CreateIdentityResponse.passcodes)
  return _internal_mutable_passcodes()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void CreateIdentityResponse::set_passcodes(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_passcodes()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:ownmfa.api.CreateIdentityResponse.passcodes)
}
template <typename Arg_, typename... Args_>
inline void CreateIdentityResponse::add_passcodes(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_passcodes(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:ownmfa.api.CreateIdentityResponse.passcodes)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
CreateIdentityResponse::passcodes() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:ownmfa.api.CreateIdentityResponse.passcodes)
  return _internal_passcodes();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
CreateIdentityResponse::mutable_passcodes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:ownmfa.api.CreateIdentityResponse.passcodes)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_passcodes();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
CreateIdentityResponse::_internal_passcodes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.passcodes_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
CreateIdentityResponse::_internal_mutable_passcodes() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.passcodes_;
}

// -------------------------------------------------------------------

// ActivateIdentityRequest

// string id = 1 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline void ActivateIdentityRequest::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& ActivateIdentityRequest::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.ActivateIdentityRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ActivateIdentityRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ownmfa.api.ActivateIdentityRequest.id)
}
inline std::string* ActivateIdentityRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.ActivateIdentityRequest.id)
  return _s;
}
inline const std::string& ActivateIdentityRequest::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void ActivateIdentityRequest::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(value, GetArena());
}
inline std::string* ActivateIdentityRequest::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* ActivateIdentityRequest::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ownmfa.api.ActivateIdentityRequest.id)
  return _impl_.id_.Release();
}
inline void ActivateIdentityRequest::set_allocated_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.ActivateIdentityRequest.id)
}

// string app_id = 2 [json_name = "appID", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline void ActivateIdentityRequest::clear_app_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.app_id_.ClearToEmpty();
}
inline const std::string& ActivateIdentityRequest::app_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.ActivateIdentityRequest.app_id)
  return _internal_app_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ActivateIdentityRequest::set_app_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.app_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ownmfa.api.ActivateIdentityRequest.app_id)
}
inline std::string* ActivateIdentityRequest::mutable_app_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_app_id();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.ActivateIdentityRequest.app_id)
  return _s;
}
inline const std::string& ActivateIdentityRequest::_internal_app_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.app_id_.Get();
}
inline void ActivateIdentityRequest::_internal_set_app_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.app_id_.Set(value, GetArena());
}
inline std::string* ActivateIdentityRequest::_internal_mutable_app_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.app_id_.Mutable( GetArena());
}
inline std::string* ActivateIdentityRequest::release_app_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ownmfa.api.ActivateIdentityRequest.app_id)
  return _impl_.app_id_.Release();
}
inline void ActivateIdentityRequest::set_allocated_app_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.app_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.app_id_.IsDefault()) {
    _impl_.app_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.ActivateIdentityRequest.app_id)
}

// string passcode = 3 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline void ActivateIdentityRequest::clear_passcode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.passcode_.ClearToEmpty();
}
inline const std::string& ActivateIdentityRequest::passcode() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.ActivateIdentityRequest.passcode)
  return _internal_passcode();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ActivateIdentityRequest::set_passcode(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.passcode_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ownmfa.api.ActivateIdentityRequest.passcode)
}
inline std::string* ActivateIdentityRequest::mutable_passcode() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_passcode();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.ActivateIdentityRequest.passcode)
  return _s;
}
inline const std::string& ActivateIdentityRequest::_internal_passcode() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.passcode_.Get();
}
inline void ActivateIdentityRequest::_internal_set_passcode(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.passcode_.Set(value, GetArena());
}
inline std::string* ActivateIdentityRequest::_internal_mutable_passcode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.passcode_.Mutable( GetArena());
}
inline std::string* ActivateIdentityRequest::release_passcode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ownmfa.api.ActivateIdentityRequest.passcode)
  return _impl_.passcode_.Release();
}
inline void ActivateIdentityRequest::set_allocated_passcode(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.passcode_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.passcode_.IsDefault()) {
    _impl_.passcode_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.ActivateIdentityRequest.passcode)
}

// -------------------------------------------------------------------

// ChallengeIdentityRequest

// string id = 1 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline void ChallengeIdentityRequest::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& ChallengeIdentityRequest::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.ChallengeIdentityRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChallengeIdentityRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ownmfa.api.ChallengeIdentityRequest.id)
}
inline std::string* ChallengeIdentityRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.ChallengeIdentityRequest.id)
  return _s;
}
inline const std::string& ChallengeIdentityRequest::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void ChallengeIdentityRequest::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(value, GetArena());
}
inline std::string* ChallengeIdentityRequest::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* ChallengeIdentityRequest::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ownmfa.api.ChallengeIdentityRequest.id)
  return _impl_.id_.Release();
}
inline void ChallengeIdentityRequest::set_allocated_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.ChallengeIdentityRequest.id)
}

// string app_id = 2 [json_name = "appID", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline void ChallengeIdentityRequest::clear_app_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.app_id_.ClearToEmpty();
}
inline const std::string& ChallengeIdentityRequest::app_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.ChallengeIdentityRequest.app_id)
  return _internal_app_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChallengeIdentityRequest::set_app_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.app_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ownmfa.api.ChallengeIdentityRequest.app_id)
}
inline std::string* ChallengeIdentityRequest::mutable_app_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_app_id();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.ChallengeIdentityRequest.app_id)
  return _s;
}
inline const std::string& ChallengeIdentityRequest::_internal_app_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.app_id_.Get();
}
inline void ChallengeIdentityRequest::_internal_set_app_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.app_id_.Set(value, GetArena());
}
inline std::string* ChallengeIdentityRequest::_internal_mutable_app_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.app_id_.Mutable( GetArena());
}
inline std::string* ChallengeIdentityRequest::release_app_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ownmfa.api.ChallengeIdentityRequest.app_id)
  return _impl_.app_id_.Release();
}
inline void ChallengeIdentityRequest::set_allocated_app_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.app_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.app_id_.IsDefault()) {
    _impl_.app_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.ChallengeIdentityRequest.app_id)
}

// -------------------------------------------------------------------

// VerifyIdentityRequest

// string id = 1 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline void VerifyIdentityRequest::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& VerifyIdentityRequest::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.VerifyIdentityRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VerifyIdentityRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ownmfa.api.VerifyIdentityRequest.id)
}
inline std::string* VerifyIdentityRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.VerifyIdentityRequest.id)
  return _s;
}
inline const std::string& VerifyIdentityRequest::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void VerifyIdentityRequest::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(value, GetArena());
}
inline std::string* VerifyIdentityRequest::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* VerifyIdentityRequest::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ownmfa.api.VerifyIdentityRequest.id)
  return _impl_.id_.Release();
}
inline void VerifyIdentityRequest::set_allocated_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.VerifyIdentityRequest.id)
}

// string app_id = 2 [json_name = "appID", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline void VerifyIdentityRequest::clear_app_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.app_id_.ClearToEmpty();
}
inline const std::string& VerifyIdentityRequest::app_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.VerifyIdentityRequest.app_id)
  return _internal_app_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VerifyIdentityRequest::set_app_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.app_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ownmfa.api.VerifyIdentityRequest.app_id)
}
inline std::string* VerifyIdentityRequest::mutable_app_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_app_id();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.VerifyIdentityRequest.app_id)
  return _s;
}
inline const std::string& VerifyIdentityRequest::_internal_app_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.app_id_.Get();
}
inline void VerifyIdentityRequest::_internal_set_app_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.app_id_.Set(value, GetArena());
}
inline std::string* VerifyIdentityRequest::_internal_mutable_app_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.app_id_.Mutable( GetArena());
}
inline std::string* VerifyIdentityRequest::release_app_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ownmfa.api.VerifyIdentityRequest.app_id)
  return _impl_.app_id_.Release();
}
inline void VerifyIdentityRequest::set_allocated_app_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.app_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.app_id_.IsDefault()) {
    _impl_.app_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.VerifyIdentityRequest.app_id)
}

// string passcode = 3 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline void VerifyIdentityRequest::clear_passcode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.passcode_.ClearToEmpty();
}
inline const std::string& VerifyIdentityRequest::passcode() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.VerifyIdentityRequest.passcode)
  return _internal_passcode();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VerifyIdentityRequest::set_passcode(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.passcode_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ownmfa.api.VerifyIdentityRequest.passcode)
}
inline std::string* VerifyIdentityRequest::mutable_passcode() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_passcode();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.VerifyIdentityRequest.passcode)
  return _s;
}
inline const std::string& VerifyIdentityRequest::_internal_passcode() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.passcode_.Get();
}
inline void VerifyIdentityRequest::_internal_set_passcode(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.passcode_.Set(value, GetArena());
}
inline std::string* VerifyIdentityRequest::_internal_mutable_passcode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.passcode_.Mutable( GetArena());
}
inline std::string* VerifyIdentityRequest::release_passcode() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ownmfa.api.VerifyIdentityRequest.passcode)
  return _impl_.passcode_.Release();
}
inline void VerifyIdentityRequest::set_allocated_passcode(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.passcode_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.passcode_.IsDefault()) {
    _impl_.passcode_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.VerifyIdentityRequest.passcode)
}

// -------------------------------------------------------------------

// GetIdentityRequest

// string id = 1 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline void GetIdentityRequest::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& GetIdentityRequest::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.GetIdentityRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetIdentityRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ownmfa.api.GetIdentityRequest.id)
}
inline std::string* GetIdentityRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.GetIdentityRequest.id)
  return _s;
}
inline const std::string& GetIdentityRequest::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void GetIdentityRequest::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(value, GetArena());
}
inline std::string* GetIdentityRequest::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* GetIdentityRequest::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ownmfa.api.GetIdentityRequest.id)
  return _impl_.id_.Release();
}
inline void GetIdentityRequest::set_allocated_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.GetIdentityRequest.id)
}

// string app_id = 2 [json_name = "appID", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline void GetIdentityRequest::clear_app_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.app_id_.ClearToEmpty();
}
inline const std::string& GetIdentityRequest::app_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.GetIdentityRequest.app_id)
  return _internal_app_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetIdentityRequest::set_app_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.app_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ownmfa.api.GetIdentityRequest.app_id)
}
inline std::string* GetIdentityRequest::mutable_app_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_app_id();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.GetIdentityRequest.app_id)
  return _s;
}
inline const std::string& GetIdentityRequest::_internal_app_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.app_id_.Get();
}
inline void GetIdentityRequest::_internal_set_app_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.app_id_.Set(value, GetArena());
}
inline std::string* GetIdentityRequest::_internal_mutable_app_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.app_id_.Mutable( GetArena());
}
inline std::string* GetIdentityRequest::release_app_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ownmfa.api.GetIdentityRequest.app_id)
  return _impl_.app_id_.Release();
}
inline void GetIdentityRequest::set_allocated_app_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.app_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.app_id_.IsDefault()) {
    _impl_.app_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.GetIdentityRequest.app_id)
}

// -------------------------------------------------------------------

// DeleteIdentityRequest

// string id = 1 [(.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline void DeleteIdentityRequest::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.ClearToEmpty();
}
inline const std::string& DeleteIdentityRequest::id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.DeleteIdentityRequest.id)
  return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DeleteIdentityRequest::set_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ownmfa.api.DeleteIdentityRequest.id)
}
inline std::string* DeleteIdentityRequest::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.DeleteIdentityRequest.id)
  return _s;
}
inline const std::string& DeleteIdentityRequest::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_.Get();
}
inline void DeleteIdentityRequest::_internal_set_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.Set(value, GetArena());
}
inline std::string* DeleteIdentityRequest::_internal_mutable_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.id_.Mutable( GetArena());
}
inline std::string* DeleteIdentityRequest::release_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ownmfa.api.DeleteIdentityRequest.id)
  return _impl_.id_.Release();
}
inline void DeleteIdentityRequest::set_allocated_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.DeleteIdentityRequest.id)
}

// string app_id = 2 [json_name = "appID", (.google.api.field_behavior) = REQUIRED, (.validate.rules) = {
inline void DeleteIdentityRequest::clear_app_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.app_id_.ClearToEmpty();
}
inline const std::string& DeleteIdentityRequest::app_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.DeleteIdentityRequest.app_id)
  return _internal_app_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DeleteIdentityRequest::set_app_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.app_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ownmfa.api.DeleteIdentityRequest.app_id)
}
inline std::string* DeleteIdentityRequest::mutable_app_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_app_id();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.DeleteIdentityRequest.app_id)
  return _s;
}
inline const std::string& DeleteIdentityRequest::_internal_app_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.app_id_.Get();
}
inline void DeleteIdentityRequest::_internal_set_app_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.app_id_.Set(value, GetArena());
}
inline std::string* DeleteIdentityRequest::_internal_mutable_app_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.app_id_.Mutable( GetArena());
}
inline std::string* DeleteIdentityRequest::release_app_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ownmfa.api.DeleteIdentityRequest.app_id)
  return _impl_.app_id_.Release();
}
inline void DeleteIdentityRequest::set_allocated_app_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.app_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.app_id_.IsDefault()) {
    _impl_.app_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.DeleteIdentityRequest.app_id)
}

// -------------------------------------------------------------------

// ListIdentitiesRequest

// int32 page_size = 1 [(.validate.rules) = {
inline void ListIdentitiesRequest::clear_page_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.page_size_ = 0;
}
inline ::int32_t ListIdentitiesRequest::page_size() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.ListIdentitiesRequest.page_size)
  return _internal_page_size();
}
inline void ListIdentitiesRequest::set_page_size(::int32_t value) {
  _internal_set_page_size(value);
  // @@protoc_insertion_point(field_set:ownmfa.api.ListIdentitiesRequest.page_size)
}
inline ::int32_t ListIdentitiesRequest::_internal_page_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.page_size_;
}
inline void ListIdentitiesRequest::_internal_set_page_size(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.page_size_ = value;
}

// string page_token = 2;
inline void ListIdentitiesRequest::clear_page_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.page_token_.ClearToEmpty();
}
inline const std::string& ListIdentitiesRequest::page_token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.ListIdentitiesRequest.page_token)
  return _internal_page_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ListIdentitiesRequest::set_page_token(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.page_token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ownmfa.api.ListIdentitiesRequest.page_token)
}
inline std::string* ListIdentitiesRequest::mutable_page_token() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_page_token();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.ListIdentitiesRequest.page_token)
  return _s;
}
inline const std::string& ListIdentitiesRequest::_internal_page_token() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.page_token_.Get();
}
inline void ListIdentitiesRequest::_internal_set_page_token(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.page_token_.Set(value, GetArena());
}
inline std::string* ListIdentitiesRequest::_internal_mutable_page_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.page_token_.Mutable( GetArena());
}
inline std::string* ListIdentitiesRequest::release_page_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ownmfa.api.ListIdentitiesRequest.page_token)
  return _impl_.page_token_.Release();
}
inline void ListIdentitiesRequest::set_allocated_page_token(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.page_token_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.page_token_.IsDefault()) {
    _impl_.page_token_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.ListIdentitiesRequest.page_token)
}

// string app_id = 3 [json_name = "appID", (.validate.rules) = {
inline void ListIdentitiesRequest::clear_app_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.app_id_.ClearToEmpty();
}
inline const std::string& ListIdentitiesRequest::app_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.ListIdentitiesRequest.app_id)
  return _internal_app_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ListIdentitiesRequest::set_app_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.app_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ownmfa.api.ListIdentitiesRequest.app_id)
}
inline std::string* ListIdentitiesRequest::mutable_app_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_app_id();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.ListIdentitiesRequest.app_id)
  return _s;
}
inline const std::string& ListIdentitiesRequest::_internal_app_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.app_id_.Get();
}
inline void ListIdentitiesRequest::_internal_set_app_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.app_id_.Set(value, GetArena());
}
inline std::string* ListIdentitiesRequest::_internal_mutable_app_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.app_id_.Mutable( GetArena());
}
inline std::string* ListIdentitiesRequest::release_app_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ownmfa.api.ListIdentitiesRequest.app_id)
  return _impl_.app_id_.Release();
}
inline void ListIdentitiesRequest::set_allocated_app_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.app_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.app_id_.IsDefault()) {
    _impl_.app_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.ListIdentitiesRequest.app_id)
}

// -------------------------------------------------------------------

// ListIdentitiesResponse

// repeated .ownmfa.api.Identity identities = 1;
inline int ListIdentitiesResponse::_internal_identities_size() const {
  return _internal_identities().size();
}
inline int ListIdentitiesResponse::identities_size() const {
  return _internal_identities_size();
}
inline void ListIdentitiesResponse::clear_identities() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.identities_.Clear();
}
inline ::ownmfa::api::Identity* ListIdentitiesResponse::mutable_identities(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:ownmfa.api.ListIdentitiesResponse.identities)
  return _internal_mutable_identities()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::ownmfa::api::Identity>* ListIdentitiesResponse::mutable_identities()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:ownmfa.api.ListIdentitiesResponse.identities)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_identities();
}
inline const ::ownmfa::api::Identity& ListIdentitiesResponse::identities(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.ListIdentitiesResponse.identities)
  return _internal_identities().Get(index);
}
inline ::ownmfa::api::Identity* ListIdentitiesResponse::add_identities() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::ownmfa::api::Identity* _add = _internal_mutable_identities()->Add();
  // @@protoc_insertion_point(field_add:ownmfa.api.ListIdentitiesResponse.identities)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::ownmfa::api::Identity>& ListIdentitiesResponse::identities() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:ownmfa.api.ListIdentitiesResponse.identities)
  return _internal_identities();
}
inline const ::google::protobuf::RepeatedPtrField<::ownmfa::api::Identity>&
ListIdentitiesResponse::_internal_identities() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.identities_;
}
inline ::google::protobuf::RepeatedPtrField<::ownmfa::api::Identity>*
ListIdentitiesResponse::_internal_mutable_identities() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.identities_;
}

// string next_page_token = 2;
inline void ListIdentitiesResponse::clear_next_page_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_page_token_.ClearToEmpty();
}
inline const std::string& ListIdentitiesResponse::next_page_token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:ownmfa.api.ListIdentitiesResponse.next_page_token)
  return _internal_next_page_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ListIdentitiesResponse::set_next_page_token(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_page_token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:ownmfa.api.ListIdentitiesResponse.next_page_token)
}
inline std::string* ListIdentitiesResponse::mutable_next_page_token() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_next_page_token();
  // @@protoc_insertion_point(field_mutable:ownmfa.api.ListIdentitiesResponse.next_page_token)
  return _s;
}
inline const std::string& ListIdentitiesResponse::_internal_next_page_token() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.next_page_token_.Get();
}
inline void ListIdentitiesResponse::_internal_set_next_page_token(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_page_token_.Set(value, GetArena());
}
inline std::string* ListIdentitiesResponse::_internal_mutable_next_page_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.next_page_token_.Mutable( GetArena());
}
inline std::string* ListIdentitiesResponse::release_next_page_token() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:ownmfa.api.ListIdentitiesResponse.next_page_token)
  return _impl_.next_page_token_.Release();
}
inline void ListIdentitiesResponse::set_allocated_next_page_token(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.next_page_token_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.next_page_token_.IsDefault()) {
    _impl_.next_page_token_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:ownmfa.api.ListIdentitiesResponse.next_page_token)
}

// int32 total_size = 3;
inline void ListIdentitiesResponse::clear_total_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_size_ = 0;
}
inline ::int32_t ListIdentitiesResponse::total_size() const {
  // @@protoc_insertion_point(field_get:ownmfa.api.ListIdentitiesResponse.total_size)
  return _internal_total_size();
}
inline void ListIdentitiesResponse::set_total_size(::int32_t value) {
  _internal_set_total_size(value);
  // @@protoc_insertion_point(field_set:ownmfa.api.ListIdentitiesResponse.total_size)
}
inline ::int32_t ListIdentitiesResponse::_internal_total_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.total_size_;
}
inline void ListIdentitiesResponse::_internal_set_total_size(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_size_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace api
}  // namespace ownmfa


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::ownmfa::api::IdentityStatus> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::ownmfa::api::IdentityStatus>() {
  return ::ownmfa::api::IdentityStatus_descriptor();
}
template <>
struct is_proto_enum<::ownmfa::api::Hash> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::ownmfa::api::Hash>() {
  return ::ownmfa::api::Hash_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // api_2fownmfa_5fapp_5fidentity_2eproto_2epb_2eh
